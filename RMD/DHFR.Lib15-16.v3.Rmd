---
title: "Broad Mutational Scanning for Antibiotic Resistance in the DHFR Family"
author: 'Authors: [Karl J. Romanowicz](https://kromanowicz.github.io/), Carmen Resnick, Samuel R. Hinton, Calin Plesa'
output:
  html_notebook:
    theme: spacelab
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  html_document:
    toc: yes
    toc_depth: '5'
    df_print: paged
  pdf_document:
    toc: yes
    toc_depth: '5'
---

**GitHub Repository:** [https://github.com/PlesaLab/DHFR](https://github.com/PlesaLab/DHFR)

# Experiment

This R Notebook provides complete reproducibility of the data analysis presented in ***"Broad mutational scanning of the dihydrofolate reductase protein family"*** by Romanowicz, Resnick, Hinton, and Plesa (*In Prep*).

<font color="green">This pipeline analyzes a set of 1,536 DHFR homologs and their corresponding mutants designed with two-fold redundancy (two codon libraries). It generates fitness scores from multiple time points during a multiplexed in-vivo assay that evaluates how these homologs and mutants complement the functionality of an E. coli knockout strain (dFolA|dThyA). Sequence data were generated using the Illumina NextSeq platform using paired-end sequencing read amplicons.</font>

![Methods overview to achieve a broad-mutational scan for DHFR homologs.](images/DHFR.Diagram.png)

```{css}
.badCode {
background-color: lightpink;
font-weight: bold;
}

.goodCode {
background-color: lightgreen;
font-weight: bold;
}

.sharedCode {
background-color: lightblue;
font-weight: bold;
}

table {
  margin: auto;
  border-top: 1px solid #666;
  border-bottom: 1px solid #666;
}
table thead th { border-bottom: 1px solid #ddd; }
th, td { padding: 5px; }
thead, tfoot, tr:nth-child(even) { background: #eee; }
```

```{r setup, include=FALSE}
# Set global options for notebook
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = TRUE, message = TRUE)
knitr::opts_chunk$set(echo = TRUE, class.source = "bg-success")

# Getting the path of your current open file and set as wd
current_path = rstudioapi::getActiveDocumentContext()$path 
setwd(dirname(current_path))
print(getwd())
```

# Packages
The following R packages must be installed prior to loading into the R session. See the **Reproducibility** tab for a complete list of packages and their versions used in this workflow.
```{r message=FALSE, warning=FALSE, results='hide'}
# Make a vector of required packages
required.packages <- c("ape", "Biostrings", "castor", "cowplot", "devtools", 
                       "dplyr", "ggExtra", "ggnewscale", "ggplot2", "ggridges", 
                       "ggtree", "ggtreeExtra", "gridExtra", "knitr", "matrixStats", 
                       "patchwork", "pscl", "RColorBrewer", "reshape", "ROCR", 
                       "seqinr", "scales", "stringr", "stringi", "tidyr", 
                       "tidytree", "viridis")

# Load required packages with error handling
loaded.packages <- lapply(required.packages, function(package) {
  if (!require(package, character.only = TRUE)) {
    install.packages(package, dependencies = TRUE)
    if (!require(package, character.only = TRUE)) {
      message("Package ", package, " could not be installed and loaded.")
      return(NULL)
    }
  }
  return(package)
})

# Remove NULL entries from loaded packages
loaded.packages <- loaded.packages[!sapply(loaded.packages, is.null)]
```

```{r class.output="sharedCode", echo=FALSE}
# Print loaded packages
cat("Loaded packages:", paste(loaded.packages, collapse = ", "), "\n")
```

```{r include=FALSE}
# set.seed is used to fix the random number generation to make the results repeatable
set.seed(123)
```

# Load Data
<font color="blue">**This section is based on the R file: "R_load_data.R".**</font> It describes how to load all of the pre-existing barcode mapping data necessary for downstream analysis.

**Pre-Existing Data Files to Import**

* **BCinfo:** Mapping Information (one for each library)
* **mutIDinfo:** Mutant Information (one for each library)
* **BCs:** Everything Sequenced (one for each library)
* **BCmut:** Only Mapped Barcodes (one for each library)

## Barcode Info
**Begin the analysis by loading in the barcode information for each codon-version library.** This data represents each **barcode** [`BC`] recovered from the complementation process, linked to each **homolog or mutant** [`mutID`], the **number of mutations** observed in the sequence relative to its designed homolog [`mutations`], a list of where the **mutations occurred** along the protein sequence[`cigar`], and the **number of reads** associated with each barcode [`reads`]:
```{r}
# Library 15 (Codon 1)
BCinfo15 = read.csv("for_Karl/15_HiFi_BC_mutID_all.csv", head=TRUE)  # read csv file

# Library 16 (Codon 2)
BCinfo16 = read.csv("for_Karl/16_HiFi_BC_mutID_all.csv", head=TRUE)  # read csv file
```

### Filter Mutations

Filter each dataset to ensure each mutant has >=0 mutations
```{r class.output="goodCode"}
## Make sure each mutant has >=0 mutations by removing rows with negative values
BCinfo15 <- BCinfo15 %>%
  filter(mutations >= 0)

# Check mutate count for Lib15 (should be "0"):
min(BCinfo15$mutations)

## Make sure each mutant has >=0 mutations by removing rows with negative values
BCinfo16 <- BCinfo16 %>%
  filter(mutations >= 0)

# Check mutate count for Lib16 (should be "0"):
min(BCinfo16$mutations)
```

<font color="green">**Preview of BCinfo**</font>
```{r echo=FALSE}
# Library 15
head(BCinfo15)

# Library 16
head(BCinfo16)
```

### Unique BC Counts

**Total BCs:** Count the number of unique barcodes for each library
```{r class.output="goodCode"}
# Count the number of unique barcodes for Library 15
BCinfo15.count <- length(unique(BCinfo15$BC))
format(BCinfo15.count, big.mark = ",")

# Count the number of unique barcodes for Library 16
BCinfo16.count <- length(unique(BCinfo16$BC))
format(BCinfo16.count, big.mark = ",")
```

**Perfects BCs:** Count the number of unique barcodes that have zero mutations (i.e., BCs associated with perfects). Note that many of these barcodes are likely associated with the same protein sequence and do not represent the total number of perfects recovered from the dataset.
```{r class.output="goodCode"}
# Count the number of rows containing zero (0) mutations for Library 15
BCinfo15.count.zeros <- sum(BCinfo15$mutations == 0)
format(BCinfo15.count.zeros, big.mark = ",")

# Count the number of rows containing zero (0) mutations for Library 16
BCinfo16.count.zeros <- sum(BCinfo16$mutations == 0)
format(BCinfo16.count.zeros, big.mark = ",")
```

**Mutant BCs:** Count the number of unique unique barcodes that have at least 1 mutation (i.e., BCs associated with mutants). Note that many of these barcodes are likely associated with the same protein sequence and do not represent the total number of mutants recovered from the dataset.
```{r class.output="goodCode"}
# Count the number of rows containing >=1 mutation for Library 15
BCinfo15.count.nonzeros <- sum(BCinfo15$mutations != 0)
format(BCinfo15.count.nonzeros, big.mark = ",")

# Count the number of rows containing >=1 mutation for Library 16
BCinfo16.count.nonzeros <- sum(BCinfo16$mutations != 0)
format(BCinfo16.count.nonzeros, big.mark = ",")
```

## Mutant Info
**Load in the mutant information for each codon-version library.** This data represents each **mutant** sequence [`mutID`] from the dataset, the **designed homolog** it mutated from [`IDalign`], the **number of barcodes** associated with each mutant [`numBCs`], the **number of mutations** in the sequence relative to the designed homolog [`mutations`], the **full sequence** of the mutant [`seq`], the **percent identity of the mutant** to the designed homolog [`pct_ident`], a list of **all barcodes** associated with the mutant [`BCs`], and the **barcode code** [`BCcode`]:
```{r}
# Library 15 (Codon 1)
mutIDinfo15 = read.csv("for_Karl/15_HiFi_mutID_info_all.csv", head=TRUE)  # read csv file

# Library 16 (Codon 2)
mutIDinfo16 = read.csv("for_Karl/16_HiFi_mutID_info_all.csv", head=TRUE)  # read csv file
```

### Filter Mutations

Filter each dataset to ensure each mutant has >=0 mutations
```{r class.output="goodCode"}
## Make sure each mutant has >=0 mutations by removing rows with negative values
mutIDinfo15 <- mutIDinfo15 %>%
  filter(mutations >= 0)

# Check mutate count for Lib15 (should be "0"):
min(mutIDinfo15$mutations)

## Make sure each mutant has >=0 mutations by removing rows with negative values
mutIDinfo16 <- mutIDinfo16 %>%
  filter(mutations >= 0)

# Check mutate count for Lib16 (should be "0"):
min(mutIDinfo16$mutations)
```

<font color="green">**Preview of mutIDinfo**</font>
```{r echo=FALSE}
# Library 15
head(mutIDinfo15)

# Library 16
head(mutIDinfo16)
```

### Unique Sequence Counts

**Total Sequences:** Count the number of unique protein sequences in each library
```{r class.output="goodCode"}
# Count the number of unique protein sequences for Library 15
mutIDinfo15.count <- length(unique(mutIDinfo15$seq))
format(mutIDinfo15.count, big.mark = ",")

# Count the number of unique protein sequences for Library 16
mutIDinfo16.count <- length(unique(mutIDinfo16$seq))
format(mutIDinfo16.count, big.mark = ",")
```

**Perfect Sequences:** Count the number of unique protein sequences that have zero mutations (i.e., sequences associated with perfects). These values designate the number of true homologs ("perfects") that match the designed homologs without mutations.
```{r class.output="goodCode"}
# Count the number of rows containing zero (0) mutations for Library 15
mutIDinfo15.count.zeros <- sum(mutIDinfo15$mutations == 0)
format(mutIDinfo15.count.zeros, big.mark = ",")

# Count the number of rows containing zero (0) mutations for Library 16
mutIDinfo16.count.zeros <- sum(mutIDinfo16$mutations == 0)
format(mutIDinfo16.count.zeros, big.mark = ",")
```

**Mutant Sequences:** Count the number of unique protein sequences that have at least 1 mutation (i.e., sequences associated with mutants). These values designate the number of mutants derived from the designed homologs.
```{r class.output="goodCode"}
# Count the number of rows containing >=1 mutation for Library 15
mutIDinfo15.count.nonzeros <- sum(mutIDinfo15$mutations != 0)
format(mutIDinfo15.count.nonzeros, big.mark = ",")

# Count the number of rows containing >=1 mutation for Library 16
mutIDinfo16.count.nonzeros <- sum(mutIDinfo16$mutations != 0)
format(mutIDinfo16.count.nonzeros, big.mark = ",")
```

Count the number of shared perfect protein sequences between libraries (mutations == 0).
```{r class.output="goodCode"}
# Merge the mutIDinfo datasets but keep only the mutIDs shared between libraries
mutIDinfo.15.16.zeros.shared <- merge(mutIDinfo15, mutIDinfo16, by = "mutID", all = FALSE)

# Count the number of perfects (mutations == 0) shared between both libraries
mutIDinfo.15.16.zeros.shared.count <- sum(mutIDinfo.15.16.zeros.shared$mutations.x == 0)
format(mutIDinfo.15.16.zeros.shared.count, big.mark = ",")
```

Also count the number of perfect sequences unique to one or the other library (mutations == 0).
```{r class.output="goodCode"}
# Merge the mutIDinfo datasets but retain only the mutIDs unique to one library or the other
mutIDinfo.15.16.zeros.unique <- bind_rows(
  anti_join(mutIDinfo15, mutIDinfo16, by = "mutID"),
  anti_join(mutIDinfo16, mutIDinfo15, by = "mutID"))

# Count the number of perfects (mutations == 0) unique to one library or the other
mutIDinfo.15.16.zeros.unique.count <- sum(mutIDinfo.15.16.zeros.unique$mutations == 0)
format(mutIDinfo.15.16.zeros.unique.count, big.mark = ",")
```

Count the total number of shared and unique perfects between libraries:
```{r class.output="goodCode"}
mutIDinfo.15.16.zeros.all.count <- sum(mutIDinfo.15.16.zeros.shared.count + mutIDinfo.15.16.zeros.unique.count)
format(mutIDinfo.15.16.zeros.all.count, big.mark = ",")
```

## Add Map Identifiers

Add the IDalign column to the "BCinfo" objects based on shared "mutID" values with the "mutIDinfo" objects:
```{r}
# Lib 15
BCinfo15$IDalign <- mutIDinfo15$IDalign[match(BCinfo15$mutID, mutIDinfo15$mutID)]

# Lib 16
BCinfo16$IDalign <- mutIDinfo16$IDalign[match(BCinfo16$mutID, mutIDinfo16$mutID)]
```

Add "Lib" column with value==1 for each BC present in the "BCinfo" object
```{r}
# Add a new column "NewColumn" with every row value set to 1

# Lib 15
BCinfo15 <- BCinfo15 %>% mutate(Lib15 = 1)

# Lib 16
BCinfo16 <- BCinfo16 %>% mutate(Lib16 = 1)
```

## Merge Mapping Files

Merge the "BCinfo" and "mutIDinfo" mapping files by shared "mutID" values for each library
```{r}
# Lib15

# Merge mapping files by "mutID"
BCs_mutID_15 <- inner_join(BCinfo15,mutIDinfo15,by="mutID")

# Select columns of interest to remove duplicates
BCs_mutID_15 <- BCs_mutID_15 %>%
  select(BC, mutID, IDalign.x, mutations.x, cigar, numBCs, seq, pct_ident, BCs, BCcode)

# Rename columns
names(BCs_mutID_15) <- c("BC","mutID","IDalign","mutations","cigar","numBCs","seq","pct_ident","BCs","BCcode")

# Lib16

# Merge mapping files by "mutID"
BCs_mutID_16 <- inner_join(BCinfo16,mutIDinfo16,by="mutID")

# Select columns of interest to remove duplicates
BCs_mutID_16 <- BCs_mutID_16 %>%
  select(BC, mutID, IDalign.x, mutations.x, cigar, numBCs, seq, pct_ident, BCs, BCcode)

# Rename columns
names(BCs_mutID_16) <- c("BC","mutID","IDalign","mutations","cigar","numBCs","seq","pct_ident","BCs","BCcode")
```

## Count Data
**Import the count data (sequences) for each sampling condition in Library 15 (D01, D03, D05:D11, E07:F01, F9:G3, G11:H5) and Library 16 (D02, D04, D12:E6, F2:F8, G4:G10, H6:H12).** Each .csv file contains two columns: **(1)** [`BC`] represents the **unique barcode** recovered from the sampling condition, and **(2)** [`D0X`] represents the **sequence counts** matching each barcode within the sampling condition.

Import all Library 15 count files:
```{r}
### Library 15

## Library 15 - T0

# D01 - Lib15 - Overnight Growth on LB - T0
D01 = read.csv("counts/D01_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D01) <- c("BC","D01")

# D03 - Lib15 - Growth on M9 - Full Supplement - T0
D03 = read.csv("counts/D03_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D03) <- c("BC","D03")

## Library 15 - T1

# D05 - Lib15 - Growth on M9 - 0 ug/mL TMP - T1
D05 = read.csv("counts/D05_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D05) <- c("BC","D05")

# D06 - Lib15 - Growth on M9 - 0.058 ug/ml TMP - T1
D06 = read.csv("counts/D06_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D06) <- c("BC","D06")

# D07 - Lib15 - Growth on M9 - 0.5 ug/ml TMP - T1
D07 = read.csv("counts/D07_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D07) <- c("BC","D07")

# D08 - Lib15 - Growth on M9 - 1.0 ug/ml TMP - T1
D08 = read.csv("counts/D08_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D08) <- c("BC","D08")

# D09 - Lib15 - Growth on M9 - 10.0 ug/ml TMP - T1
D09 = read.csv("counts/D09_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D09) <- c("BC","D09")

# D10 - Lib15 - Growth on M9 - 50.0 ug/ml TMP - T1
D10 = read.csv("counts/D10_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D10) <- c("BC","D10")

# D11 - Lib15 - Growth on M9 - 200.0 ug/ml TMP - T1
D11 = read.csv("counts/D11_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D11) <- c("BC","D11")

## Library 15 - T2

# E07 - Lib15 - Growth on M9 - 0 ug/mL TMP - T2
E07 = read.csv("counts/E07_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E07) <- c("BC","E07")

# E08 - Lib15 - Growth on M9 - 0.058 ug/ml TMP - T2
E08 = read.csv("counts/E08_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E08) <- c("BC","E08")

# E09 - Lib15 - Growth on M9 - 0.5 ug/ml TMP - T2
E09 = read.csv("counts/E09_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E09) <- c("BC","E09")

# E10 - Lib15 - Growth on M9 - 1.0 ug/ml TMP - T2
E10 = read.csv("counts/E10_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E10) <- c("BC","E10")

# E11 - Lib15 - Growth on M9 - 10.0 ug/ml TMP - T2
E11 = read.csv("counts/E11_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E11) <- c("BC","E11")

# E12 - Lib15 - Growth on M9 - 50.0 ug/ml TMP - T2
E12 = read.csv("counts/E12_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E12) <- c("BC","E12")

# F01 - Lib15 - Growth on M9 - 200.0 ug/ml TMP - T2
F01 = read.csv("counts/F01_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F01) <- c("BC","F01")

## Library 15 - T3

# F09 - Lib15 - Growth on M9 - 0 ug/mL TMP - T3
F09 = read.csv("counts/F09_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F09) <- c("BC","F09")

# F10 - Lib15 - Growth on M9 - 0.058 ug/ml TMP - T3
F10 = read.csv("counts/F10_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F10) <- c("BC","F10")

# F11 - Lib15 - Growth on M9 - 0.5 ug/ml TMP - T3
F11 = read.csv("counts/F11_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F11) <- c("BC","F11")

# F12 - Lib15 - Growth on M9 - 1.0 ug/ml TMP - T3
F12 = read.csv("counts/F12_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F12) <- c("BC","F12")

# G01 - Lib15 - Growth on M9 - 10.0 ug/ml TMP - T3
G01 = read.csv("counts/G01_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G01) <- c("BC","G01")

# G02 - Lib15 - Growth on M9 - 50.0 ug/ml TMP - T3
G02 = read.csv("counts/G02_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G02) <- c("BC","G02")

# G03 - Lib15 - Growth on M9 - 200.0 ug/ml TMP - T3
G03 = read.csv("counts/G03_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G03) <- c("BC","G03")

## Library 15 - T4

# G11 - Lib15 - Growth on M9 - 0 ug/mL TMP - T4
G11 = read.csv("counts/G11_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G11) <- c("BC","G11")

# G12 - Lib15 - Growth on M9 - 0.058 ug/ml TMP - T4
G12 = read.csv("counts/G12_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G12) <- c("BC","G12")

# H01 - Lib15 - Growth on M9 - 0.5 ug/ml TMP - T4
H01 = read.csv("counts/H01_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H01) <- c("BC","H01")

# H02 - Lib15 - Growth on M9 - 1.0 ug/ml TMP - T4
H02 = read.csv("counts/H02_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H02) <- c("BC","H02")

# H03 - Lib15 - Growth on M9 - 10.0 ug/ml TMP - T4
H03 = read.csv("counts/H03_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H03) <- c("BC","H03")

# H04 - Lib15 - Growth on M9 - 50.0 ug/ml TMP - T4
H04 = read.csv("counts/H04_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H04) <- c("BC","H04")

# H05 - Lib15 - Growth on M9 - 200.0 ug/ml TMP - T4
H05 = read.csv("counts/H05_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H05) <- c("BC","H05")
```

Import all Library 16 count files:
```{r}
### Library 16

## Library 16 - T0

# D02 - Lib16 - Overnight Growth on LB - T0
D02 = read.csv("counts/D02_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D02) <- c("BC","D02")

# D04 - Lib16 - Growth on M9 - Full Supplement - T0
D04 = read.csv("counts/D04_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D04) <- c("BC","D04")

## Library 16 - T1

# D12 - Lib16 - Growth on M9 - 0 ug/mL TMP - T1
D12 = read.csv("counts/D12_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(D12) <- c("BC","D12")

# E01 - Lib16 - Growth on M9 - 0.058 ug/ml TMP - T1
E01 = read.csv("counts/E01_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E01) <- c("BC","E01")

# E02 - Lib16 - Growth on M9 - 0.5 ug/ml TMP - T1
E02 = read.csv("counts/E02_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E02) <- c("BC","E02")

# E03 - Lib16 - Growth on M9 - 1.0 ug/ml TMP - T1
E03 = read.csv("counts/E03_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E03) <- c("BC","E03")

# E04 - Lib16 - Growth on M9 - 10.0 ug/ml TMP - T1
E04 = read.csv("counts/E04_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E04) <- c("BC","E04")

# E05 - Lib16 - Growth on M9 - 50.0 ug/ml TMP - T1
E05 = read.csv("counts/E05_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E05) <- c("BC","E05")

# E06 - Lib16 - Growth on M9 - 200.0 ug/ml TMP - T1
E06 = read.csv("counts/E06_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(E06) <- c("BC","E06")

## Library 16 - T2

# F02 - Lib16 - Growth on M9 - 0 ug/mL TMP - T2
F02 = read.csv("counts/F02_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F02) <- c("BC","F02")

# F03 - Lib16 - Growth on M9 - 0.058 ug/ml TMP - T2
F03 = read.csv("counts/F03_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F03) <- c("BC","F03")

# F04 - Lib16 - Growth on M9 - 0.5 ug/ml TMP - T2
F04 = read.csv("counts/F04_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F04) <- c("BC","F04")

# F05 - Lib16 - Growth on M9 - 1.0 ug/ml TMP - T2
F05 = read.csv("counts/F05_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F05) <- c("BC","F05")

# F06 - Lib16 - Growth on M9 - 10.0 ug/ml TMP - T2
F06 = read.csv("counts/F06_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F06) <- c("BC","F06")

# F07 - Lib16 - Growth on M9 - 50.0 ug/ml TMP - T2
F07 = read.csv("counts/F07_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F07) <- c("BC","F07")

# F08 - Lib16 - Growth on M9 - 200.0 ug/ml TMP - T2
F08 = read.csv("counts/F08_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(F08) <- c("BC","F08")

## Library 16 - T3

# G04 - Lib16 - Growth on M9 - 0 ug/mL TMP - T3
G04 = read.csv("counts/G04_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G04) <- c("BC","G04")

# G05 - Lib16 - Growth on M9 - 0.058 ug/ml TMP - T3
G05 = read.csv("counts/G05_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G05) <- c("BC","G05")

# G06 - Lib16 - Growth on M9 - 0.5 ug/ml TMP - T3
G06 = read.csv("counts/G06_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G06) <- c("BC","G06")

# G07 - Lib16 - Growth on M9 - 1.0 ug/ml TMP - T3
G07 = read.csv("counts/G07_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G07) <- c("BC","G07")

# G08 - Lib16 - Growth on M9 - 10.0 ug/ml TMP - T3
G08 = read.csv("counts/G08_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G08) <- c("BC","G08")

# G09 - Lib16 - Growth on M9 - 50.0 ug/ml TMP - T3
G09 = read.csv("counts/G09_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G09) <- c("BC","G09")

# G10 - Lib16 - Growth on M9 - 200.0 ug/ml TMP - T3
G10 = read.csv("counts/G10_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(G10) <- c("BC","G10")

## Library 16 - T4

# H06 - Lib16 - Growth on M9 - 0 ug/mL TMP - T4
H06 = read.csv("counts/H06_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H06) <- c("BC","H06")

# H07 - Lib16 - Growth on M9 - 0.058 ug/ml TMP - T4
H07 = read.csv("counts/H07_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H07) <- c("BC","H07")

# H08 - Lib16 - Growth on M9 - 0.5 ug/ml TMP - T4
H08 = read.csv("counts/H08_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H08) <- c("BC","H08")

# H09 - Lib16 - Growth on M9 - 1.0 ug/ml TMP - T4
H09 = read.csv("counts/H09_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H09) <- c("BC","H09")

# H10 - Lib16 - Growth on M9 - 10.0 ug/ml TMP - T4
H10 = read.csv("counts/H10_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H10) <- c("BC","H10")

# H11 - Lib16 - Growth on M9 - 50.0 ug/ml TMP - T4
H11 = read.csv("counts/H11_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H11) <- c("BC","H11")

# H12 - Lib16 - Growth on M9 - 200.0 ug/ml TMP - T4
H12 = read.csv("counts/H12_collapse_d1.tsv", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(H12) <- c("BC","H12")
```

# Count Data

## Raw Read Counts

**Summarize the imported count data by sampling condition for each codon-version library.** Begin by combining the count data from each sampling condition into a single dataframe for each library. Next, sum the full count values for each sampling condition (total number of sequences recovered for each sampling condition). Then, sum the number of unique barcodes recovered from each sampling condition. Define the sampling condition associated with each sample code. Finally, write the data summary to a .csv file and save in the working directory.

**Summarize Library 15**
```{r}
## Library 15

# Merge data objects together into single dataframe
norm_vals_15 <- data.frame(sample=c("D01","D03","D05","D06","D07","D08","D09","D10","D11","E07","E08","E09","E10","E11","E12","F01","F09","F10","F11","F12","G01","G02","G03","G11","G12","H01","H02","H03","H04","H05"),
                        counts=c(sum(D01$D01),sum(D03$D03),sum(D05$D05),sum(D06$D06),sum(D07$D07),sum(D08$D08),
                                 sum(D09$D09),sum(D10$D10),sum(D11$D11),sum(E07$E07),sum(E08$E08),sum(E09$E09),
                                 sum(E10$E10),sum(E11$E11),sum(E12$E12),sum(F01$F01),sum(F09$F09),sum(F10$F10),
                                 sum(F11$F11),sum(F12$F12),sum(G01$G01),sum(G02$G02),sum(G03$G03),sum(G11$G11),
                                 sum(G12$G12),sum(H01$H01),sum(H02$H02),sum(H03$H03),sum(H04$H04),sum(H05$H05)),
                        numBCs=c(length(D01$D01),length(D03$D03),length(D05$D05),length(D06$D06),length(D07$D07),
                                 length(D08$D08),length(D09$D09),length(D10$D10),length(D11$D11),length(E07$E07),
                                 length(E08$E08),length(E09$E09),length(E10$E10),length(E11$E11),length(E12$E12),
                                 length(F01$F01),length(F09$F09),length(F10$F10),length(F11$F11),length(F12$F12),
                                 length(G01$G01),length(G02$G02),length(G03$G03),length(G11$G11),length(G12$G12),
                                 length(H01$H01),length(H02$H02),length(H03$H03),length(H04$H04),length(H05$H05)),
                        sampledesc=c("D01 - Lib15 - T0 - Overnight Growth on LB",
                                     "D03 - Lib15 - T0 - Growth on M9 - Full Supplement",
                                     "D05 - Lib15 - T1 - Growth on M9 - 0.0 ug/ml TMP",
                                     "D06 - Lib15 - T1 - Growth on M9 - 0.058 ug/ml TMP",
                                     "D07 - Lib15 - T1 - Growth on M9 - 0.5 ug/ml TMP",
                                     "D08 - Lib15 - T1 - Growth on M9 - 1.0 ug/ml TMP",
                                     "D09 - Lib15 - T1 - Growth on M9 - 10.0 ug/ml TMP",
                                     "D10 - Lib15 - T1 - Growth on M9 - 50.0 ug/ml TMP",
                                     "D11 - Lib15 - T1 - Growth on M9 - 200.0 ug/ml TMP",
                                     "E07 - Lib15 - T2 - Growth on M9 - 0.0 ug/ml TMP",
                                     "E08 - Lib15 - T2 - Growth on M9 - 0.058 ug/ml TMP",
                                     "E09 - Lib15 - T2 - Growth on M9 - 0.5 ug/ml TMP",
                                     "E10 - Lib15 - T2 - Growth on M9 - 1.0 ug/ml TMP",
                                     "E11 - Lib15 - T2 - Growth on M9 - 10.0 ug/ml TMP",
                                     "E12 - Lib15 - T2 - Growth on M9 - 50.0 ug/ml TMP",
                                     "F01 - Lib15 - T2 - Growth on M9 - 200.0 ug/ml TMP",
                                     "F09 - Lib15 - T3 - Growth on M9 - 0.0 ug/ml TMP",
                                     "F10 - Lib15 - T3 - Growth on M9 - 0.058 ug/ml TMP",
                                     "F11 - Lib15 - T3 - Growth on M9 - 0.5 ug/ml TMP",
                                     "F12 - Lib15 - T3 - Growth on M9 - 1.0 ug/ml TMP",
                                     "G01 - Lib15 - T3 - Growth on M9 - 10.0 ug/ml TMP",
                                     "G02 - Lib15 - T3 - Growth on M9 - 50.0 ug/ml TMP",
                                     "G03 - Lib15 - T3 - Growth on M9 - 200.0 ug/ml TMP",
                                     "G11 - Lib15 - T4 - Growth on M9 - 0.0 ug/ml TMP",
                                     "G12 - Lib15 - T4 - Growth on M9 - 0.058 ug/ml TMP",
                                     "H01 - Lib15 - T4 - Growth on M9 - 0.5 ug/ml TMP",
                                     "H02 - Lib15 - T4 - Growth on M9 - 1.0 ug/ml TMP",
                                     "H03 - Lib15 - T4 - Growth on M9 - 10.0 ug/ml TMP",
                                     "H04 - Lib15 - T4 - Growth on M9 - 50.0 ug/ml TMP",
                                     "H05 - Lib15 - T4 - Growth on M9 - 200.0 ug/ml TMP"),
                        TMP=c("Overnight LB", "Full Supplement", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp"))
```

```{r echo=FALSE, eval=FALSE}
# Write dataframe to .csv table
write.csv(norm_vals_15, 'OUTPUT/novaseq_stats/novaseq_basic_stats_Lib15.csv', row.names = FALSE, quote=FALSE)
```

### Lib15 Summary

<font color="green">**Library 15 Summarized Count Data for Sequences and Barcodes (BC)**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_15_col1 <- norm_vals_15[,c(4,1,2,3)]

knitr::kable(norm_vals_15_col1,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts'),
  align = "lccl",
  format.args = list(big.mark = ","))
```

**Summarize Library 16**
```{r}
## Library 16

# Merge data objects together into single dataframe
norm_vals_16 <- data.frame(sample=c("D02","D04",
                                    "D12","E01","E02","E03","E04","E05","E06",
                                    "F02","F03","F04","F05","F06","F07","F08",
                                    "G04","G05","G06","G07","G08","G09","G10",
                                    "H06","H07","H08","H09","H10","H11","H12"),
                        counts=c(sum(D02$D02),sum(D04$D04),sum(D12$D12),
                                 sum(E01$E01),sum(E02$E02),sum(E03$E03),sum(E04$E04),sum(E05$E05),sum(E06$E06),
                                 sum(F02$F02),sum(F03$F03),sum(F04$F04),sum(F05$F05),sum(F06$F06),sum(F07$F07),
                                 sum(F08$F08),sum(G04$G04),sum(G05$G05),sum(G06$G06),sum(G07$G07),sum(G08$G08),
                                 sum(G09$G09),sum(G10$G10),sum(H06$H06),sum(H07$H07),sum(H08$H08),sum(H09$H09),
                                 sum(H10$H10),sum(H11$H11),sum(H12$H12)),
                        numBCs=c(length(D02$D02),length(D04$D04),length(D12$D12),length(E01$E01),length(E02$E02),
                                 length(E03$E03),length(E04$E04),length(E05$E05),length(E06$E06),length(F02$F02),
                                 length(F03$F03),length(F04$F04),length(F05$F05),length(F06$F06),length(F07$F07),
                                 length(F08$F08),length(G04$G04),length(G05$G05),length(G06$G06),length(G07$G07),
                                 length(G08$G08),length(G09$G09),length(G10$G10),length(H06$H06),length(H07$H07),
                                 length(H08$H08),length(H09$H09),length(H10$H10),length(H11$H11),length(H12$H12)),
                        sampledesc=c("D02 - Lib16 - T0 - Overnight Growth on LB",
                                     "D04 - Lib16 - T0 - Growth on M9 - Full Supplement",
                                     "D12 - Lib16 - T1 - Growth on M9 - 0.0 ug/ml TMP",
                                     "E01 - Lib16 - T1 - Growth on M9 - 0.058 ug/ml TMP",
                                     "E02 - Lib16 - T1 - Growth on M9 - 0.5 ug/ml TMP",
                                     "E03 - Lib16 - T1 - Growth on M9 - 1.0 ug/ml TMP",
                                     "E04 - Lib16 - T1 - Growth on M9 - 10.0 ug/ml TMP",
                                     "E05 - Lib16 - T1 - Growth on M9 - 50.0 ug/ml TMP",
                                     "E06 - Lib16 - T1 - Growth on M9 - 200.0 ug/ml TMP",
                                     "F02 - Lib16 - T2 - Growth on M9 - 0.0 ug/ml TMP",
                                     "F03 - Lib16 - T2 - Growth on M9 - 0.058 ug/ml TMP",
                                     "F04 - Lib16 - T2 - Growth on M9 - 0.5 ug/ml TMP",
                                     "F05 - Lib16 - T2 - Growth on M9 - 1.0 ug/ml TMP",
                                     "F06 - Lib16 - T2 - Growth on M9 - 10.0 ug/ml TMP",
                                     "F07 - Lib16 - T2 - Growth on M9 - 50.0 ug/ml TMP",
                                     "F08 - Lib16 - T2 - Growth on M9 - 200.0 ug/ml TMP",
                                     "G04 - Lib16 - T3 - Growth on M9 - 0.0 ug/ml TMP",
                                     "G05 - Lib16 - T3 - Growth on M9 - 0.058 ug/ml TMP",
                                     "G06 - Lib16 - T3 - Growth on M9 - 0.5 ug/ml TMP",
                                     "G07 - Lib16 - T3 - Growth on M9 - 1.0 ug/ml TMP",
                                     "G08 - Lib16 - T3 - Growth on M9 - 10.0 ug/ml TMP",
                                     "G09 - Lib16 - T3 - Growth on M9 - 50.0 ug/ml TMP",
                                     "G10 - Lib16 - T3 - Growth on M9 - 200.0 ug/ml TMP",
                                     "H06 - Lib16 - T4 - Growth on M9 - 0.0 ug/ml TMP",
                                     "H07 - Lib16 - T4 - Growth on M9 - 0.058 ug/ml TMP",
                                     "H08 - Lib16 - T4 - Growth on M9 - 0.5 ug/ml TMP",
                                     "H09 - Lib16 - T4 - Growth on M9 - 1.0 ug/ml TMP",
                                     "H10 - Lib16 - T4 - Growth on M9 - 10.0 ug/ml TMP",
                                     "H11 - Lib16 - T4 - Growth on M9 - 50.0 ug/ml TMP",
                                     "H12 - Lib16 - T4 - Growth on M9 - 200.0 ug/ml TMP"),
                        TMP=c("Overnight LB", "Full Supplement", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp"))
```

```{r echo=FALSE, eval=FALSE}
# Write dataframe to .csv table
write.csv(norm_vals_16, 'OUTPUT/novaseq_stats/novaseq_basic_stats_Lib16.csv', row.names = FALSE, quote=FALSE)
```

### Lib16 Summary

<font color="green">**Table of Summarized Count Data for Sequences and Barcodes (BC)**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_16_col1 <- norm_vals_16[,c(4,1,2,3)]

knitr::kable(norm_vals_16_col1,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts'),
  align = "lccl",
  format.args = list(big.mark = ","))
```

## Raw BC Counts

**Merge and prune BCs from the imported count data by sampling condition for each codon-version library.** Begin by combining the count data BCs from each sampling condition into a single dataframe for each library. Next, prune BCs to retain only those BCs with exactly 20 bp. Then, map the remaining BCs to the BC mapping file to determine how many BCs we were able to map relative to all BCs recovered. Finally, write the data summary to a .csv file and save in the working directory.

### Merged BCs
Merge the count data from each library for each sampling condition by barcode for downstream analysis.
```{r}
# Library 15
BCs15 <- D01 %>%
  full_join(D03,by="BC") %>%
  full_join(D05,by="BC") %>%
  full_join(D06,by="BC") %>%
  full_join(D07,by="BC") %>%
  full_join(D08,by="BC") %>%
  full_join(D09,by="BC") %>%
  full_join(D10,by="BC") %>%
  full_join(D11,by="BC") %>%
  full_join(E07,by="BC") %>%
  full_join(E08,by="BC") %>%
  full_join(E09,by="BC") %>%
  full_join(E10,by="BC") %>%
  full_join(E11,by="BC") %>%
  full_join(E12,by="BC") %>%
  full_join(F01,by="BC") %>%
  full_join(F09,by="BC") %>%
  full_join(F10,by="BC") %>%
  full_join(F11,by="BC") %>%
  full_join(F12,by="BC") %>%
  full_join(G01,by="BC") %>%
  full_join(G02,by="BC") %>%
  full_join(G03,by="BC") %>%
  full_join(G11,by="BC") %>%
  full_join(G12,by="BC") %>%
  full_join(H01,by="BC") %>%
  full_join(H02,by="BC") %>%
  full_join(H03,by="BC") %>%
  full_join(H04,by="BC") %>%
  full_join(H05,by="BC")

# Library 16
BCs16 <- D02 %>%
  full_join(D04,by="BC") %>%
  full_join(D12,by="BC") %>%
  full_join(E01,by="BC") %>%
  full_join(E02,by="BC") %>%
  full_join(E03,by="BC") %>%
  full_join(E04,by="BC") %>%
  full_join(E05,by="BC") %>%
  full_join(E06,by="BC") %>%
  full_join(F02,by="BC") %>%
  full_join(F03,by="BC") %>%
  full_join(F04,by="BC") %>%
  full_join(F05,by="BC") %>%
  full_join(F06,by="BC") %>%
  full_join(F07,by="BC") %>%
  full_join(F08,by="BC") %>%
  full_join(G04,by="BC") %>%
  full_join(G05,by="BC") %>%
  full_join(G06,by="BC") %>%
  full_join(G07,by="BC") %>%
  full_join(G08,by="BC") %>%
  full_join(G09,by="BC") %>%
  full_join(G10,by="BC") %>%
  full_join(H06,by="BC") %>%
  full_join(H07,by="BC") %>%
  full_join(H08,by="BC") %>%
  full_join(H09,by="BC") %>%
  full_join(H10,by="BC") %>%
  full_join(H11,by="BC") %>%
  full_join(H12,by="BC")
```

<font color="green">**Preview of BCs count data with N/A for blank values**</font>
```{r echo=FALSE}
head(BCs15)
head(BCs16)
```

**Total BCs:** Count the number of unique barcode for each library
```{r class.output="goodCode"}
# Count the number of unique barcodes for Library 15
BCs15.count <- length(unique(BCs15$BC))
format(BCs15.count, big.mark = ",")

# Count the number of unique barcodes for Library 16
BCs16.count <- length(unique(BCs16$BC))
format(BCs16.count, big.mark = ",")
```

### BC Pruning

Remove unique BCs less than 20 nucleotides in length as these do not represent true BCs from designed pool.
```{r class.output="goodCode"}
# Lib15: Sum the count of unique BC lengths in the BCs objects
BCs15.unique.table <- table(str_length(BCs15$BC))
BCs15.unique.table

# Lib16: Sum the count of unique BC lengths in the BCs objects
BCs16.unique.table <- table(str_length(BCs16$BC))
BCs16.unique.table
```

```{r}
# Filter rows where the length of BC is greater than or equal to 20

# Lib15
BCs15.prune <- BCs15 %>%
  filter(str_length(BC) >= 20)

# Lib16
BCs16.prune <- BCs16 %>%
  filter(str_length(BC) >= 20)
```

```{r class.output="goodCode"}
# Lib15: Sum the count of unique BC lengths in the BCprune objects
BCs15.prune.unique.table <- table(str_length(BCs15.prune$BC))
BCs15.prune.unique.table

# Lib16: Sum the count of unique BC lengths in the BCprune objects
BCs16.prune.unique.table <- table(str_length(BCs16.prune$BC))
BCs16.prune.unique.table
```

**Total BCs:** Count the number of unique barcode for each library after pruning by BC length
```{r class.output="goodCode"}
# Count the number of unique barcodes for Library 15
BCs15.prune.count <- length(unique(BCs15.prune$BC))
format(BCs15.prune.count, big.mark = ",")

# Count the number of unique barcodes for Library 16
BCs16.prune.count <- length(unique(BCs16.prune$BC))
format(BCs16.prune.count, big.mark = ",")
```

### BC Mapping

Map each pruned BC to it's corresponding BC in the `BCs_mutID` mapping file. This links each BC (normalized and pruned) recovered in each count file with its identifying sequence information from the mapping file.
```{r class.output="goodCode"}
# Library 15
BCs15_map <- inner_join(BCs_mutID_15,BCs15.prune,by="BC")

# Library 16
BCs16_map <- inner_join(BCs_mutID_16,BCs16.prune,by="BC")
```

Make a copy of the `BCs_map` datasets and convert "NA" values to "0" values to calculate the fraction of reads and BCs mapped:
```{r}
# Lib15
BCs15_map_frac <- BCs15_map

# Convert "NA" values to "0"
BCs15_map_frac[, 11:40][is.na(BCs15_map[, 11:40])] <- 0

# Lib16
BCs16_map_frac <- BCs16_map

# Convert "NA" values to "0"
BCs16_map_frac[, 11:40][is.na(BCs16_map[, 11:40])] <- 0
```

### Mapped Reads & BCs

Calculate the total number of reads and unique barcodes recovered from each sampling condition.
```{r}
# Lib15

# Sum the total reads recovered from each sampling condition:
norm_vals_15$mappedcounts <- c(sum(BCs15_map_frac$D01),sum(BCs15_map_frac$D03),
                            sum(BCs15_map_frac$D05),sum(BCs15_map_frac$D06),
                            sum(BCs15_map_frac$D07),sum(BCs15_map_frac$D08),
                            sum(BCs15_map_frac$D09),sum(BCs15_map_frac$D10),
                            sum(BCs15_map_frac$D11),sum(BCs15_map_frac$E07),
                            sum(BCs15_map_frac$E08),sum(BCs15_map_frac$E09),
                            sum(BCs15_map_frac$E10),sum(BCs15_map_frac$E11),
                            sum(BCs15_map_frac$E12),sum(BCs15_map_frac$F01),
                            sum(BCs15_map_frac$F09),sum(BCs15_map_frac$F10),
                            sum(BCs15_map_frac$F11),sum(BCs15_map_frac$F12),
                            sum(BCs15_map_frac$G01),sum(BCs15_map_frac$G02),
                            sum(BCs15_map_frac$G03),sum(BCs15_map_frac$G11),
                            sum(BCs15_map_frac$G12),sum(BCs15_map_frac$H01),
                            sum(BCs15_map_frac$H02),sum(BCs15_map_frac$H03),
                            sum(BCs15_map_frac$H04),sum(BCs15_map_frac$H05))

# Determine the number of unique barcodes recovered from each sampling condition:
norm_vals_15$mappedBCs <- c(length(BCs15_map_frac$D01[BCs15_map_frac$D01 != 0]),
                         length(BCs15_map_frac$D03[BCs15_map_frac$D03 != 0]),
                         length(BCs15_map_frac$D05[BCs15_map_frac$D05 != 0]),
                         length(BCs15_map_frac$D06[BCs15_map_frac$D06 != 0]),
                         length(BCs15_map_frac$D07[BCs15_map_frac$D07 != 0]),
                         length(BCs15_map_frac$D08[BCs15_map_frac$D08 != 0]),
                         length(BCs15_map_frac$D09[BCs15_map_frac$D09 != 0]),
                         length(BCs15_map_frac$D10[BCs15_map_frac$D10 != 0]),
                         length(BCs15_map_frac$D11[BCs15_map_frac$D11 != 0]),
                         length(BCs15_map_frac$E07[BCs15_map_frac$E07 != 0]),
                         length(BCs15_map_frac$E08[BCs15_map_frac$E08 != 0]),
                         length(BCs15_map_frac$E09[BCs15_map_frac$E09 != 0]),
                         length(BCs15_map_frac$E10[BCs15_map_frac$E10 != 0]),
                         length(BCs15_map_frac$E11[BCs15_map_frac$E11 != 0]),
                         length(BCs15_map_frac$E12[BCs15_map_frac$E12 != 0]),
                         length(BCs15_map_frac$F01[BCs15_map_frac$F01 != 0]),
                         length(BCs15_map_frac$F09[BCs15_map_frac$F09 != 0]),
                         length(BCs15_map_frac$F10[BCs15_map_frac$F10 != 0]),
                         length(BCs15_map_frac$F11[BCs15_map_frac$F11 != 0]),
                         length(BCs15_map_frac$F12[BCs15_map_frac$F12 != 0]),
                         length(BCs15_map_frac$G01[BCs15_map_frac$G01 != 0]),
                         length(BCs15_map_frac$G02[BCs15_map_frac$G02 != 0]),
                         length(BCs15_map_frac$G03[BCs15_map_frac$G03 != 0]),
                         length(BCs15_map_frac$G11[BCs15_map_frac$G11 != 0]),
                         length(BCs15_map_frac$G12[BCs15_map_frac$G12 != 0]),
                         length(BCs15_map_frac$H01[BCs15_map_frac$H01 != 0]),
                         length(BCs15_map_frac$H02[BCs15_map_frac$H02 != 0]),
                         length(BCs15_map_frac$H03[BCs15_map_frac$H03 != 0]),
                         length(BCs15_map_frac$H04[BCs15_map_frac$H04 != 0]),
                         length(BCs15_map_frac$H05[BCs15_map_frac$H05 != 0]))
```

<font color="green">**Table of Summarized Count Data including Mapped Counts and Mapped BCs for each Sample Condition**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_15_col3 <- norm_vals_15[,c(4,1,2,3,6,7)]

knitr::kable(norm_vals_15_col3,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs'),
  align = "llccccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

```{r}
# Library 16

# Sum the total reads recovered from each sampling condition:
norm_vals_16$mappedcounts <- c(sum(BCs16_map_frac$D02),sum(BCs16_map_frac$D04),
                            sum(BCs16_map_frac$D12),sum(BCs16_map_frac$E01),
                            sum(BCs16_map_frac$E02),sum(BCs16_map_frac$E03),
                            sum(BCs16_map_frac$E04),sum(BCs16_map_frac$E05),
                            sum(BCs16_map_frac$E06),sum(BCs16_map_frac$F02),
                            sum(BCs16_map_frac$F03),sum(BCs16_map_frac$F04),
                            sum(BCs16_map_frac$F05),sum(BCs16_map_frac$F06),
                            sum(BCs16_map_frac$F07),sum(BCs16_map_frac$F08),
                            sum(BCs16_map_frac$G04),sum(BCs16_map_frac$G05),
                            sum(BCs16_map_frac$G06),sum(BCs16_map_frac$G07),
                            sum(BCs16_map_frac$G08),sum(BCs16_map_frac$G09),
                            sum(BCs16_map_frac$G10),sum(BCs16_map_frac$H06),
                            sum(BCs16_map_frac$H07),sum(BCs16_map_frac$H08),
                            sum(BCs16_map_frac$H09),sum(BCs16_map_frac$H10),
                            sum(BCs16_map_frac$H11),sum(BCs16_map_frac$H12))

# Determine the number of unique barcodes recovered from each sampling condition:
norm_vals_16$mappedBCs <- c(length(BCs16_map_frac$D02[BCs16_map_frac$D02 != 0]),
                         length(BCs16_map_frac$D04[BCs16_map_frac$D04 != 0]),
                         length(BCs16_map_frac$D12[BCs16_map_frac$D12 != 0]),
                         length(BCs16_map_frac$E01[BCs16_map_frac$E01 != 0]),
                         length(BCs16_map_frac$E02[BCs16_map_frac$E02 != 0]),
                         length(BCs16_map_frac$E03[BCs16_map_frac$E03 != 0]),
                         length(BCs16_map_frac$E04[BCs16_map_frac$E04 != 0]),
                         length(BCs16_map_frac$E05[BCs16_map_frac$E05 != 0]),
                         length(BCs16_map_frac$E06[BCs16_map_frac$E06 != 0]),
                         length(BCs16_map_frac$F02[BCs16_map_frac$F02 != 0]),
                         length(BCs16_map_frac$F03[BCs16_map_frac$F03 != 0]),
                         length(BCs16_map_frac$F04[BCs16_map_frac$F04 != 0]),
                         length(BCs16_map_frac$F05[BCs16_map_frac$F05 != 0]),
                         length(BCs16_map_frac$F06[BCs16_map_frac$F06 != 0]),
                         length(BCs16_map_frac$F07[BCs16_map_frac$F07 != 0]),
                         length(BCs16_map_frac$F08[BCs16_map_frac$F08 != 0]),
                         length(BCs16_map_frac$G04[BCs16_map_frac$G04 != 0]),
                         length(BCs16_map_frac$G05[BCs16_map_frac$G05 != 0]),
                         length(BCs16_map_frac$G06[BCs16_map_frac$G06 != 0]),
                         length(BCs16_map_frac$G07[BCs16_map_frac$G07 != 0]),
                         length(BCs16_map_frac$G08[BCs16_map_frac$G08 != 0]),
                         length(BCs16_map_frac$G09[BCs16_map_frac$G09 != 0]),
                         length(BCs16_map_frac$G10[BCs16_map_frac$G10 != 0]),
                         length(BCs16_map_frac$H06[BCs16_map_frac$H06 != 0]),
                         length(BCs16_map_frac$H07[BCs16_map_frac$H07 != 0]),
                         length(BCs16_map_frac$H08[BCs16_map_frac$H08 != 0]),
                         length(BCs16_map_frac$H09[BCs16_map_frac$H09 != 0]),
                         length(BCs16_map_frac$H10[BCs16_map_frac$H10 != 0]),
                         length(BCs16_map_frac$H11[BCs16_map_frac$H11 != 0]),
                         length(BCs16_map_frac$H12[BCs16_map_frac$H12 != 0]))
```

```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_16_col3 <- norm_vals_16[,c(4,1,2,3,6,7)]

knitr::kable(norm_vals_16_col3,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs'),
  align = "llccccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

### Frac Reads & BCs Mapped

Calculate the fraction of mapped counts and BCs relative to total counts and BCs, respectively
```{r}
# Library 15

# Calculate the fraction of mapped counts or barcodes relative to total counts or barcodes, respectively
norm_vals_15 <- norm_vals_15 %>%
  mutate(frac_mapped_counts=mappedcounts/counts,
         frac_mapped_BC=mappedBCs/numBCs)
```

<font color="green">**Table of Summarized Count Data including Mapped Counts and Mapped BCs for each Sample Condition**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_15_col4 <- norm_vals_15[,c(4,1,2,3,6,7,8,9)]

knitr::kable(norm_vals_15_col4,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs', 'Frac Mapped Counts', 'Frac Mapped BCs'),
  align = "llccccccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

```{r}
# Library 16

# Calculate the fraction of mapped counts or barcodes relative to total counts or barcodes, respectively
norm_vals_16 <- norm_vals_16 %>%
  mutate(frac_mapped_counts=mappedcounts/counts,
         frac_mapped_BC=mappedBCs/numBCs)
```

<font color="green">**Table of Summarized Count Data including Mapped Counts and Mapped BCs for each Sample Condition**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_16_col4 <- norm_vals_16[,c(4,1,2,3,6,7,8,9)]

knitr::kable(norm_vals_16_col4,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs', 'Frac Mapped Counts', 'Frac Mapped BCs'),
  align = "llccccccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

### Plot Mapped Reads & BCs

Plot the mapped reads <font color="red">(match with a barcode)</font> as a fraction of the total reads.

```{r}
# Merge the two datasets and add the "Lib" column
merged_norm_vals <- bind_rows(
  norm_vals_15 %>% mutate(Lib = "Lib15"),
  norm_vals_16 %>% mutate(Lib = "Lib16"))

merged_norm_vals_sub <- merged_norm_vals %>%
  select(5:10)

# Create a new data frame for plotting
merged_norm_vals_sub <- merged_norm_vals_sub %>%
  filter(!grepl("Full Supplement|Overnight LB", TMP))

# Multiply the "mean_frac_mapped_counts" and "mean_frac_mapped_BC" columns by 100
merged_norm_vals_sub$frac_mapped_counts <- merged_norm_vals_sub$frac_mapped_counts * 100
merged_norm_vals_sub$frac_mapped_BC <- merged_norm_vals_sub$frac_mapped_BC * 100
```

```{r}
# Place variables in order for plotting
frac_order <- c("0-tmp", "0.058-tmp", "0.5-tmp", "1.0-tmp", "10-tmp", "50-tmp", "200-tmp")

# Create custom labels for the x-axis
frac_labels <- c("0", "0.058", "0.5", "1.0", "10", "50", "200")

# Create the boxplot
merged_norm_frac_read_plot <- ggplot(merged_norm_vals_sub, aes(x = TMP, y = frac_mapped_counts, fill = Lib)) +
  geom_boxplot(position = position_dodge(width = 0.85), alpha = 0.8) +
  xlab("Trimethoprim (g/mL)") +
  ylab("Fraction of Total Reads Mapped (%)") +
#  ggtitle("Fraction of Total Reads Mapped") +
  theme_minimal() + 
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        plot.title = element_text(size = 14, hjust = 0.5), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(), 
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 16), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(59, 77)) +
  guides(linetype = "none") +
  scale_x_discrete(labels = unique(frac_labels)) +
  scale_fill_manual(values = c("#0072B2", "#E69F00"))
  #scale_fill_manual(values = c("aquamarine4", "lightsteelblue2"))

merged_norm_frac_read_plot
```

```{r}
# Create the boxplot
merged_norm_frac_BC_plot <- ggplot(merged_norm_vals_sub, aes(x = TMP, y = frac_mapped_BC, fill = Lib)) +
  geom_boxplot(position = position_dodge(width = 0.85), alpha = 0.75) +
  xlab("Trimethoprim (g/mL)") +
  ylab("Fraction of Total BCs Mapped (%)") +
#  ggtitle("Fraction of Total BCs Mapped") +
  theme_minimal() + 
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        plot.title = element_text(size = 14, hjust = 0.5), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(), 
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 16),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(8, 62)) +
  guides(linetype = "none") +
  scale_x_discrete(labels = unique(frac_labels)) +
  scale_fill_manual(values = c("#0072B2", "#E69F00"))

merged_norm_frac_BC_plot
```

```{r}
# Create the boxplot
merged_norm_reads_plot <- ggplot(merged_norm_vals_sub, aes(x = TMP, y = mappedcounts, fill = Lib)) +
  geom_boxplot(position = position_dodge(width = 0.85), alpha = 0.75) +
  xlab("Trimethoprim (g/mL)") +
  ylab("Total Reads Mapped") +
#  ggtitle("Total Reads Mapped by Library") +
  theme_minimal() + 
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        plot.title = element_text(size = 14, hjust = 0.5), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(), 
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 16),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(5000000, 52000000), labels = label_comma()) +
  guides(linetype = "none") +
  scale_x_discrete(labels = unique(frac_labels)) +
  scale_fill_manual(values = c("#0072B2", "#E69F00"))

merged_norm_reads_plot
```

```{r}
# Create the boxplot
merged_norm_BC_plot <- ggplot(merged_norm_vals_sub, aes(x = TMP, y = mappedBCs, fill = Lib)) +
  geom_boxplot(position = position_dodge(width = 0.85), alpha = 0.75) +
  xlab("Trimethoprim (g/mL)") +
  ylab("Total BCs Mapped") +
#  ggtitle("Total BCs Mapped by Library") +
  theme_minimal() + 
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        plot.title = element_text(size = 14, hjust = 0.5), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(), 
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 16),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 155000), labels = label_comma()) +
  guides(linetype = "none") +
  scale_x_discrete(labels = unique(frac_labels)) +
  scale_fill_manual(values = c("#0072B2", "#E69F00"))

merged_norm_BC_plot
```

```{r echo=FALSE}
patch1 <- (merged_norm_reads_plot | merged_norm_frac_read_plot)/(merged_norm_BC_plot | merged_norm_frac_BC_plot)
patch1
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.mean.reads.bcs.mapped.png", plot=patch1,
       dpi=600, width = 16, height = 12, units = "in")
```

## Basic Checks

With the count data from both libraries imported and merged, we can perform some basic checks to determine everything has been incorporated properly.

### Mapping Barcodes

**BCs matching mapping file:** How many of our barcodes (from count files) are in the mapping files for each library?
```{r class.output="goodCode"}
# Lib15 - Count number of barcodes (rows)
format(nrow(BCs15_map), big.mark = ",")

# Lib16 - Count number of barcodes (rows)
format(nrow(BCs16_map), big.mark = ",")
```

**Perfect BCs matching mapping file:** How many of our barcodes are associated with perfects (perfect sequence match with a designed homolog) for each unique library after filtering to the BC mapping file?
```{r class.output="goodCode"}
# Library 15
BCs15_perf <- BCs15_map %>%
  filter(mutations==0)

# Count number of perfects (rows)
format(nrow(BCs15_perf), big.mark = ",")

# Library 16
BCs16_perf <- BCs16_map %>%
  filter(mutations==0)

# Count number of perfects (rows)
format(nrow(BCs16_perf), big.mark = ",")
```

**Mutant BCs matching mapping file:** How many of our barcodes are associated with mutants (sequence contains at least 1 mutation from a designed homolog) for each unique library after filtering to the BC mapping file?
```{r class.output="goodCode"}
# Library 15
BCs15_mutant <- BCs15_map %>%
  filter(mutations!=0)

# Count number of perfects (rows)
format(nrow(BCs15_mutant), big.mark = ",")

# Library 16
BCs16_mutant <- BCs16_map %>%
  filter(mutations!=0)

# Count number of perfects (rows)
format(nrow(BCs16_mutant), big.mark = ",")
```

### Mapping Perfects

**Unique Perfects:** How many unique perfects did we recover from all sampling conditions for each library?
```{r class.output="goodCode"}
# Library 15
perf_uniq_15 <- BCs15_map %>%
  filter(mutations==0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(perf_uniq_15, big.mark = ",")

# Library 16
perf_uniq_16 <- BCs16_map %>%
  filter(mutations==0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(perf_uniq_16, big.mark = ",")
```

### Mapping Mutants

**Unique Mutants:** How many unique mutants did we recover from all sampling conditions for unique libraries?
```{r class.output="goodCode"}
# Library 15
mutant_15 <- BCs15_map %>%
  filter(mutations!=0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(mutant_15, big.mark = ",")

# Library 16
mutant_16 <- BCs16_map %>%
  filter(mutations!=0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(mutant_16, big.mark = ",")
```

### Merged Libraries

The following section merges Lib15 and Lib16 based on shared "mutID" and sums the number of unique perfects shared between libraries. It also merges Lib15 and Lib16 based on "mutIDs" unique to each library and sums the number of perfects unique to one library or the other. Finally, it sums the total number of unique perfects recovered that are either shared between libraries or unique to one library or the other.

<font color="red">**NOTE:** This section is suppressed by default to save processing time and resources. Re-evaluate as needed.</font>

#### Shared Perfects

Count the number of shared perfects (mutations == 0) recovered between libraries.
```{r class.output="goodCode", eval=FALSE}
# Merge the mutIDinfo datasets but keep only the mutIDs shared between libraries
BCs_mutID_perfects.shared <- merge(BCs15_map, BCs16_map, by = "mutID", all = FALSE)

# Retain only the rows with a specific value in the "specific_column" column
raw_data.shared <- BCs_mutID_perfects.shared %>%
  filter(mutations.x == 0)

# Count the number of perfects (mutations == 0) shared between both libraries
BCs_mutID_perfects.shared.count <- length(unique(raw_data.shared$mutID))
format(BCs_mutID_perfects.shared.count, big.mark = ",")
```

#### Unique Perfects

Also count the number of perfect sequences unique to one or the other library (mutations == 0).
```{r class.output="goodCode", eval=FALSE}
# Merge the mutIDinfo datasets but retain only the mutIDs unique to one library or the other
BCs_mutID_perfects.unique <- bind_rows(
  anti_join(BCs15_map, BCs16_map, by = "mutID"),
  anti_join(BCs16_map, BCs15_map, by = "mutID"))

# Retain only the rows with a specific value in the "specific_column" column
raw_data.unique <-BCs_mutID_perfects.unique %>%
  filter(mutations == 0)

# Count the number of perfects (mutations == 0) unique to one library or the other
BCs_mutID_perfects.unique.count <- length(unique(raw_data.unique$mutID))
format(BCs_mutID_perfects.unique.count, big.mark = ",")
```

#### Total Perfects

Count the number of shared and unique perfects recovered for both codon version libraries.
```{r class.output="goodCode", eval=FALSE}
# Sum the number of shared and unique perfects recovered for both codon version libraries
BCs_mutID_perfects.15.16.all.count <- sum(BCs_mutID_perfects.shared.count + BCs_mutID_perfects.unique.count)
format(BCs_mutID_perfects.15.16.all.count, big.mark = ",")
```

## BC Filtering

Up to this point, raw BCs have been pruned by BC length and all remaining BC counts have been normalized against sequence reads at **"T0 - M9 - Full Supplement"**. Here, we'll start by adding the raw count values, normalized count values, and log2-FC values for each BC to the `BCmut` object that represent the pre-filtered BC counts. Then, we'll filter BCs from our library datasets based on a minimum sequence count threshold across sampling conditions for use in all downstream analyses. **We use a minimum cutoff of 10 sequence reads per barcode.**

### Pre-Filtered BCs

Count the number of unique BCs prior to filtering by minimum sequence count:
```{r class.output="goodCode"}
# Pre-Filtered BC Counts by Library

# Count the number of BCs prior to filtering by minimum sequence count
BCmut_15.pre.count <- BCs15_map %>% nrow()
format(BCmut_15.pre.count, big.mark = ",")

# Count the number of BCs prior to filtering by minimum sequence count
BCmut_16.pre.count <- BCs16_map %>% nrow()
format(BCmut_16.pre.count, big.mark = ",")
```

### Filtered BCs

Determine the number of unique barcodes based on a minimum sequence count threshold across sampling conditions. Filter the barcodes by a minimum threshold of sequence reads per unique barcode. In this case, we use a minimum cutoff of 10 sequence reads per barcode:

**Lib15 BC Count***
```{r class.output="goodCode"}
# Filter unique barcodes by minimum sequence count. This code uses "or" such that if any of the sampling conditions contain at least 10 sequences counts/barcode, then the barcode is retained for the full dataset.

# Lib15
BCs15_map <- BCs15_map %>%
  filter(D01>9 | D03>9 | D05>9 | D06>9 | D07>9 | D08>9 | D09>9 | D10>9 | D11>9 | 
           E07>9 | E08>9 | E09>9 | E10>9 | E11>9 | E12>9 | F01>9 | 
           F09>9 | F10>9 | F11>9 | F12>9 | G01>9 | G02>9 | G03>9 | 
           G11>9 | G12>9 | H01>9 | H02>9 | H03>9 | H04>9 | H05>9)

# Count the number of BCs remaining after filtering by minimum sequence count
BCs15_map.count <- BCs15_map %>% nrow()
format(BCs15_map.count, big.mark = ",")

# Lib16
BCs16_map <- BCs16_map %>%
  filter(D02>9 | D04>9 | D12>9 | E01>9 | E02>9 | E03>9 | E04>9 | E05>9 | E06>9 | 
          F02>9 | F03>9 | F04>9 | F05>9 | F06>9 | F07>9 | F08>9 | 
           G04>9 | G05>9 | G06>9 | G07>9 | G08>9 | G09>9 | G10>9 | 
           H06>9 | H07>9 | H08>9 | H09>9 | H10>9 | H11>9 | H12>9)

# Count the number of BCs remaining after filtering by minimum sequence count
BCs16_map.count <- BCs16_map %>% nrow()
format(BCs16_map.count, big.mark = ",")
```

Confirm that all unique BCs match the 20-bp length requirement after filtering by minimum sequence count
```{r class.output="goodCode"}
# Lib15: Sum the count of unique BCs that match the 20-bp length requirement in the BCs15_map object
BC_filter15.unique.table <- table(str_length(BCs15_map$BC))
format(BC_filter15.unique.table, big.mark = ",")

# Lib16: Sum the count of unique BCs that match the 20-bp length requirement in the BCs16_map object
BC_filter16.unique.table <- table(str_length(BCs16_map$BC))
format(BC_filter16.unique.table, big.mark = ",")
```

**Unique mutID:** Count the number of unique mutIDs prior to filtering:
```{r}
# Count the number of unique mutants prior to filtering:

# Lib15
format(length(unique(BCs15_map$mutID)), big.mark = ",")

# Lib16
format(length(unique(BCs16_map$mutID)), big.mark = ",")
```

**Unique IDalign:** Count the number of unique IDaligns (designed homologs) remaining after filtering by minimum sequence count
```{r}
# Lib15
format(length(unique(BCs15_map$IDalign)), big.mark = ",")

# Lib16
format(length(unique(BCs16_map$IDalign)), big.mark = ",")
```

**Unique Perfects:** How many unique perfects (designed homologs with 0 mutations) did we recover from all sampling conditions for each library after filtering by minimum sequence count?
```{r class.output="goodCode"}
# Lib15
perf_filtered_uniq_15 <- BCs15_map %>%
  filter(mutations==0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(perf_filtered_uniq_15, big.mark = ",")

# Lib16
perf_filtered_uniq_16 <- BCs16_map %>%
  filter(mutations==0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(perf_filtered_uniq_16, big.mark = ",")
```

**Unique Perfects by TMP Treatment:** How many unique perfects did we recover from each TMP sampling treatment for each library after filtering by minimum sequence count?
```{r class.output="goodCode"}
## Library 15

# Columns to count distinct values for
columns_to_count15 <- c("D05", "D06", "D07", "D08", "D09", "D10", "D11",
                        "E07", "E08", "E09", "E10", "E11", "E12", "F01",
                        "F09", "F10", "F11", "F12", "G01", "G02", "G03",
                        "G11", "G12", "H01", "H02", "H03", "H04", "H05")

# Count unique values in "mutID" associated with each column
counts_table15 <- BCs15_map %>%
  filter(mutations == 0) %>%
  summarise(across(all_of(columns_to_count15), ~ n_distinct(mutID[. > 0])))

# Display the counts table
print(counts_table15)
```

```{r class.output="goodCode"}
## Library 16

# Columns to count distinct values for
columns_to_count16 <- c("D12", "E01", "E02", "E03", "E04", "E05", "E06",
                        "F02", "F03", "F04", "F05", "F06", "F07", "F08",
                        "G04", "G05", "G06", "G07", "G08", "G09", "G10",
                        "H06", "H07", "H08", "H09", "H10", "H11", "H12")

# Count unique values in "mutID" associated with each column
counts_table16 <- BCs16_map %>%
  filter(mutations == 0) %>%
  summarise(across(all_of(columns_to_count16), ~ n_distinct(mutID[. > 0])))

# Display the counts table
print(counts_table16)
```

**Unique Mutants:** How many unique mutants did we recover from all sampling conditions for unique libraries after filtering by minimum sequence count?
```{r class.output="goodCode"}
# Library 15
mutant_filtered_15 <- BCs15_map %>%
  filter(mutations!=0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(mutant_filtered_15, big.mark = ",")

# Library 16
mutant_filtered_16 <- BCs16_map %>%
  filter(mutations!=0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(mutant_filtered_16, big.mark = ",")
```

The following section merges the filtered versions of Lib15 and Lib16 based on shared "mutID" and sums the number of unique perfects shared between libraries. It also merges Lib15 and Lib16 based on "mutIDs" unique to each library and sums the number of perfects unique to one library or the other. Finally, it sums the total number of unique perfects recovered that are either shared between libraries or unique to one library or the other.

<font color="red">**NOTE:** This section is suppressed by default to save processing time and resources. Re-evaluate as needed.</font>

Count the number of shared perfects (mutations == 0) recovered between libraries after filtering by minimum sequence count.
```{r class.output="goodCode", eval=FALSE}
# Merge the mutIDinfo datasets but keep only the mutIDs shared between libraries
BCs_mutID_filtered_perfects.shared <- merge(BCs15_map, BCs16_map, by = "mutID", all = FALSE)

# Retain only the rows with a specific value in the "specific_column" column
filtered_data.shared <- BCs_mutID_filtered_perfects.shared %>%
  filter(mutations.x == 0)

# Count the number of perfects (mutations == 0) shared between both libraries
BCs_mutID_filtered_perfects.shared.count <- length(unique(filtered_data.shared$mutID))
format(BCs_mutID_filtered_perfects.shared.count, big.mark = ",")
```

Also count the number of perfect sequences unique to one or the other library (mutations == 0) after filtering by minimum sequence count.
```{r class.output="goodCode", eval=FALSE}
# Merge the mutIDinfo datasets but retain only the mutIDs unique to one library or the other
BCs_mutID_filtered_perfects.unique <- bind_rows(
  anti_join(BCs15_map, BCs16_map, by = "mutID"),
  anti_join(BCs16_map, BCs15_map, by = "mutID"))

# Retain only the rows with a specific value in the "specific_column" column
filtered_data.unique <-BCs_mutID_filtered_perfects.unique %>%
  filter(mutations == 0)

# Count the number of perfects (mutations == 0) unique to one library or the other
BCs_mutID_filtered_perfects.unique.count <- length(unique(filtered_data.unique$mutID))
format(BCs_mutID_filtered_perfects.unique.count, big.mark = ",")
```

Sum the shared and unique counts for total perfect sequences recovered after filtering by minimum sequence count.
```{r class.output="goodCode", eval=FALSE}
# Sum the number of shared and unique perfects recovered for both codon version libraries
BCs_mutID_filtered_perfects.15.16.all.count <- sum(BCs_mutID_filtered_perfects.shared.count + BCs_mutID_filtered_perfects.unique.count)
format(BCs_mutID_filtered_perfects.15.16.all.count, big.mark = ",")
```

## Normalization

Count data needs to be normalized across sampling conditions prior to making any downstream comparisons. Here, we scale the sequence counts against the "T0-Overnight Growth on LB" sampling condition. This represents "D01" for Lib15 and "D02" for Lib16.

### Scaling Counts by Condition

**Lib15 Scaling:** Create a scaling value to normalize all sequence count data by the total number of sequences at "T0 - Growth on M9 - Full Supplement" sample condition (Lib15: D03; Lib16: D04).
```{r}
# Calculating the scaling factor for each sampling condition based on D03 (T0-M9-Full Supplement) as the standard
norm_scaling_15 <- rep.int(norm_vals_15$counts[2],nrow(norm_vals_15))/norm_vals_15$counts

# Add the scaling values as a column to the "norm_vals_15" dataframe
norm_vals_15$scaling <- norm_scaling_15
```

<font color="green">**Table of Summarized Count Data including the Scaling Value for each Sample Condition**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_15_col2 <- norm_vals_15[,c(4,1,2,3,6,7,10)]

knitr::kable(norm_vals_15_col2,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs', 'Scaling'),
  align = "llccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

**Lib16 Scaling**
```{r}
# Calculate scaling factor for each sampling condition based on D04 (T0 - M9 - Full Supplement) as the standard
norm_scaling_16 <- rep.int(norm_vals_16$counts[2],nrow(norm_vals_16))/norm_vals_16$counts

# Add the scaling values as a column to the "norm_vals_16" dataframe
norm_vals_16$scaling <- norm_scaling_16
```

<font color="green">**Table of Summarized Count Data including the Scaling Value for each Sample Condition**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_16_col2 <- norm_vals_16[,c(4,1,2,3,6,7,10)]

knitr::kable(norm_vals_16_col2,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs', 'Scaling'),
  align = "llccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

### Scaling Counts by Barcode

**Lib15 BC Scaling**

<font color="green">**The following table displays a preview of the original count values by unique barcode:**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
BCs15_head <- head(BCs15_map[, c(1, 11:40)])

knitr::kable(BCs15_head,
  col.names = c('BC','D01', 'D03', 
                'D05', 'D06', 'D07', 'D08', 'D09', 'D10', 'D11', 
                'E07', 'E08', 'E09', 'E10', 'E11', 'E12', 'F01', 
                'F09', 'F10', 'F11', 'F12', 'G01', 'G02', 'G03', 
                'G11', 'G12', 'H01', 'H02', 'H03', 'H04', 'H05'),
  align = "lccccccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

For each sample, make a normalized counts value based on sequencing depth using the scaling values derived for each sampling condition in the table above. 
```{r}
# Make new columns for the normalized counts in the BCs object:
oldnames15 <- colnames(BCs15_map)
newnamesfrac15 = c('D01n', 'D03n', 
                   'D05n', 'D06n', 'D07n', 'D08n', 'D09n', 'D10n', 'D11n', 
                   'E07n', 'E08n', 'E09n', 'E10n', 'E11n', 'E12n', 'F01n', 
                   'F09n', 'F10n', 'F11n', 'F12n', 'G01n', 'G02n', 'G03n', 
                   'G11n', 'G12n', 'H01n', 'H02n', 'H03n', 'H04n', 'H05n')

# Add the new columns to the BCs object based on the number of original columns for sampling conditions:
numcol_15 <- ncol(BCs15_map)
D01index = which( colnames(BCs15_map)=="D01" )

# For each sample, re-scale the number of reads by relative sequencing depth of the sample using the scaling values in the norm_vals object:
for (i in 1:30){
  BCs15_map[,numcol_15+i] <- BCs15_map[,D01index+i-1]*as.numeric(norm_vals_15$scaling[i])
}

# Add the new column names to the BCs object:
colnames(BCs15_map) <- c(oldnames15,newnamesfrac15)
```

<font color="green">**The following table displays a preview of the normalized count values by unique barcode:**</font>
```{r echo=FALSE}
BCs_norm_15 <- BCs15_map[,c(1,41:70)]

# Display dataframe with kable formatting
BCs_norm_head_15 <- head(BCs_norm_15)

knitr::kable(BCs_norm_head_15,
  col.names = c('BC', 'D01n', 'D03n', 'D05n', 'D06n', 'D07n', 'D08n', 'D09n', 'D10n', 'D11n', 
                'E07n', 'E08n', 'E09n', 'E10n', 'E11n', 'E12n', 'F01n', 
                'F09n', 'F10n', 'F11n', 'F12n', 'G01n', 'G02n', 'G03n', 
                'G11n', 'G12n', 'H01n', 'H02n', 'H03n', 'H04n', 'H05n'),
  align = "lccccccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

**Lib16 BC Scaling**

<font color="green">**The following table displays a preview of the original count values by unique barcode:**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
BCs16_head <- head(BCs16_map[, c(1, 11:40)])

knitr::kable(BCs16_head,
  col.names = c('BC', 'D02', 'D04', 'D12', 'E01', 'E02', 'E03', 'E04', 'E05', 'E06', 
                'F02', 'F03', 'F04', 'F05', 'F06', 'F07', 'F08', 
                'G04', 'G05', 'G06', 'G07', 'G08', 'G09', 'G10', 
                'H06', 'H07', 'H08', 'H09', 'H10', 'H11', 'H12'),
  align = "lccccccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

For each sample, make a normalized counts value based on sequencing depth using the scaling values derived for each sampling condition in the table above. 
```{r}
# Make new columns for the normalized counts in the BCs object:
oldnames16 <- colnames(BCs16_map)
newnamesfrac16 = c('D02n', 'D04n', 
                   'D12n', 'E01n', 'E02n', 'E03n', 'E04n', 'E05n', 'E06n', 
                   'F02n', 'F03n', 'F04n', 'F05n', 'F06n', 'F07n', 'F08n', 
                   'G04n', 'G05n', 'G06n', 'G07n', 'G08n', 'G09n', 'G10n', 
                   'H06n', 'H07n', 'H08n', 'H09n', 'H10n', 'H11n', 'H12n')

# Add the new columns to the BCs object based on the number of original columns for sampling conditions:
numcol_16 <- ncol(BCs16_map)
D02index = which( colnames(BCs16_map)=="D02" )

# For each dilution, re-scale the number of reads by relative sequencing depth of the sample using the scaling values in the norm_vals object:
for (i in 1:30){
  BCs16_map[,numcol_16+i] <- BCs16_map[,D02index+i-1]*as.numeric(norm_vals_16$scaling[i])
}

# Add the new column names to the BCs object:
colnames(BCs16_map) <- c(oldnames16,newnamesfrac16)
```

<font color="green">**The following table displays a preview of the normalized count values by unique barcode:**</font>
```{r echo=FALSE}
BCs_norm_16 <- BCs16_map[,c(1,41:70)]

# Display dataframe with kable formatting
BCs_norm_head_16 <- head(BCs_norm_16)

knitr::kable(BCs_norm_head_16,
  col.names = c('BC', 'D02n', 'D04n',
                'D12n', 'E01n', 'E02n', 'E03n', 'E04n', 'E05n', 'E06n', 
                'F02n', 'F03n', 'F04n', 'F05n', 'F06n', 'F07n', 'F08n', 
                'G04n', 'G05n', 'G06n', 'G07n', 'G08n', 'G09n', 'G10n', 
                'H06n', 'H07n', 'H08n', 'H09n', 'H10n', 'H11n', 'H12n'),
  align = "lccccccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

## Log2-Fold Change

**Library 15:** Determine the log2-fold changes for each barcode relative to the M9-Supplementation condition (Lib15=D03 | Lib16=D04).
```{r}
pseudocount = 1

#Library 15
BCs15_map <- BCs15_map %>%
  mutate(D03D01fc=log2(D03n+pseudocount)-log2(D01n+pseudocount),
         D05D03fc=log2(D05n+pseudocount)-log2(D03n+pseudocount),
         D06D03fc=log2(D06n+pseudocount)-log2(D03n+pseudocount),
         D07D03fc=log2(D07n+pseudocount)-log2(D03n+pseudocount),
         D08D03fc=log2(D08n+pseudocount)-log2(D03n+pseudocount),
         D09D03fc=log2(D09n+pseudocount)-log2(D03n+pseudocount),
         D10D03fc=log2(D10n+pseudocount)-log2(D03n+pseudocount),
         D11D03fc=log2(D11n+pseudocount)-log2(D03n+pseudocount),
         E07D03fc=log2(E07n+pseudocount)-log2(D03n+pseudocount),
         E08D03fc=log2(E08n+pseudocount)-log2(D03n+pseudocount),
         E09D03fc=log2(E09n+pseudocount)-log2(D03n+pseudocount),
         E10D03fc=log2(E10n+pseudocount)-log2(D03n+pseudocount),
         E11D03fc=log2(E11n+pseudocount)-log2(D03n+pseudocount),
         E12D03fc=log2(E12n+pseudocount)-log2(D03n+pseudocount),
         F01D03fc=log2(F01n+pseudocount)-log2(D03n+pseudocount),
         F09D03fc=log2(F09n+pseudocount)-log2(D03n+pseudocount),
         F10D03fc=log2(F10n+pseudocount)-log2(D03n+pseudocount),
         F11D03fc=log2(F11n+pseudocount)-log2(D03n+pseudocount),
         F12D03fc=log2(F12n+pseudocount)-log2(D03n+pseudocount),
         G01D03fc=log2(G01n+pseudocount)-log2(D03n+pseudocount),
         G02D03fc=log2(G02n+pseudocount)-log2(D03n+pseudocount),
         G03D03fc=log2(G03n+pseudocount)-log2(D03n+pseudocount),
         G11D03fc=log2(G11n+pseudocount)-log2(D03n+pseudocount),
         G12D03fc=log2(G12n+pseudocount)-log2(D03n+pseudocount),
         H01D03fc=log2(H01n+pseudocount)-log2(D03n+pseudocount),
         H02D03fc=log2(H02n+pseudocount)-log2(D03n+pseudocount),
         H03D03fc=log2(H03n+pseudocount)-log2(D03n+pseudocount),
         H04D03fc=log2(H04n+pseudocount)-log2(D03n+pseudocount),
         H05D03fc=log2(H05n+pseudocount)-log2(D03n+pseudocount))
```

**Library 16:** 
```{r}
#Library 16
BCs16_map <- BCs16_map %>%
  mutate(D04D02fc=log2(D04n+pseudocount)-log2(D02n+pseudocount),
         D12D04fc=log2(D12n+pseudocount)-log2(D04n+pseudocount),
         E01D04fc=log2(E01n+pseudocount)-log2(D04n+pseudocount),
         E02D04fc=log2(E02n+pseudocount)-log2(D04n+pseudocount),
         E03D04fc=log2(E03n+pseudocount)-log2(D04n+pseudocount),
         E04D04fc=log2(E04n+pseudocount)-log2(D04n+pseudocount),
         E05D04fc=log2(E05n+pseudocount)-log2(D04n+pseudocount),
         E06D04fc=log2(E06n+pseudocount)-log2(D04n+pseudocount),
         F02D04fc=log2(F02n+pseudocount)-log2(D04n+pseudocount),
         F03D04fc=log2(F03n+pseudocount)-log2(D04n+pseudocount),
         F04D04fc=log2(F04n+pseudocount)-log2(D04n+pseudocount),
         F05D04fc=log2(F05n+pseudocount)-log2(D04n+pseudocount),
         F06D04fc=log2(F06n+pseudocount)-log2(D04n+pseudocount),
         F07D04fc=log2(F07n+pseudocount)-log2(D04n+pseudocount),
         F08D04fc=log2(F08n+pseudocount)-log2(D04n+pseudocount),
         G04D04fc=log2(G04n+pseudocount)-log2(D04n+pseudocount),
         G05D04fc=log2(G05n+pseudocount)-log2(D04n+pseudocount),
         G06D04fc=log2(G06n+pseudocount)-log2(D04n+pseudocount),
         G07D04fc=log2(G07n+pseudocount)-log2(D04n+pseudocount),
         G08D04fc=log2(G08n+pseudocount)-log2(D04n+pseudocount),
         G09D04fc=log2(G09n+pseudocount)-log2(D04n+pseudocount),
         G10D04fc=log2(G10n+pseudocount)-log2(D04n+pseudocount),
         H06D04fc=log2(H06n+pseudocount)-log2(D04n+pseudocount),
         H07D04fc=log2(H07n+pseudocount)-log2(D04n+pseudocount),
         H08D04fc=log2(H08n+pseudocount)-log2(D04n+pseudocount),
         H09D04fc=log2(H09n+pseudocount)-log2(D04n+pseudocount),
         H10D04fc=log2(H10n+pseudocount)-log2(D04n+pseudocount),
         H11D04fc=log2(H11n+pseudocount)-log2(D04n+pseudocount),
         H12D04fc=log2(H12n+pseudocount)-log2(D04n+pseudocount))
```

**Lib15 Log2-FC**
<font color="green">**The following table displays a preview of the log2-fold change values between sampling treatments:**</font>
```{r echo=FALSE}
BCs_norm_log_15 <- BCs15_map[,c(1,71:99)]

# Display dataframe with kable formatting
BCs_norm_log_head_15 <- head(BCs_norm_log_15)

knitr::kable(BCs_norm_log_head_15,
  col.names = c('BC', 'D03-D01fc', 
                'D05-D03fc', 'D06-D03fc', 'D07-D03fc', 'D08-D03fc', 'D09-D03fc', 'D10-D03fc', 'D11-D03fc', 
                'E07-D03fc', 'E08-D03fc', 'E09-D03fc', 'E10-D03fc', 'E11-D03fc', 'E12-D03fc', 'F01-D03fc', 
                'F09-D03fc', 'F10-D03fc', 'F11-D03fc', 'F12-D03fc', 'G01-D03fc', 'G02-D03fc', 'G03-D03fc', 
                'G11-D03fc', 'G12-D03fc', 'H01-D03fc', 'H02-D03fc', 'H03-D03fc', 'H04-D03fc', 'H05-D03fc'),
  align = "lcccccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

**Lib16 Log2-FC**
<font color="green">**The following table displays a preview of the log2-fold change values between sampling treatments:**</font>
```{r echo=FALSE}
BCs_norm_log_16 <- BCs16_map[,c(1,71:99)]

# Display dataframe with kable formatting
BCs_norm_log_head_16 <- head(BCs_norm_log_16)

knitr::kable(BCs_norm_log_head_16,
  col.names = c('BC', 'D04-D02fc', 
                'D12-D04fc', 'E01-D04fc', 'E02-D04fc', 'E03-D04fc', 'E04-D04fc', 'E05-D04fc', 'E06-D04fc', 
                'F02-D04fc', 'F03-D04fc', 'F04-D04fc', 'F05-D04fc', 'F06-D04fc', 'F07-D04fc', 'F08-D04fc', 
                'G04-D04fc', 'G05-D04fc', 'G06-D04fc', 'G07-D04fc', 'G08-D04fc', 'G09-D04fc', 'G10-D04fc', 
                'H06-D04fc', 'H07-D04fc', 'H08-D04fc', 'H09-D04fc', 'H10-D04fc', 'H11-D04fc', 'H12-D04fc'),
  align = "lcccccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

## Min BC Pruning

First, update the `mutIDinfo` object to group BCs by mutID while also adding a new column called "numprunedBCs" that counts the number of unique BCs associated with each unique mutID that passed the filtering threshold in the `BCs_map` object.
```{r}
# Lib15
mutIDinfo15 <- BCs15_map %>%
  group_by(mutID) %>%
  summarise(numprunedBCs = n()) %>%
  right_join(mutIDinfo15, by="mutID")

# Lib16
mutIDinfo16 <- BCs16_map %>%
  group_by(mutID) %>%
  summarise(numprunedBCs = n()) %>%
  right_join(mutIDinfo16, by="mutID")
```

Replace all NAs with 0 in the "numprunedBCs" column
```{r}
#replace NAs with 0

# Lib15
mutIDinfo15$numprunedBCs[is.na(mutIDinfo15$numprunedBCs)] <- 0

# Lib16
mutIDinfo16$numprunedBCs[is.na(mutIDinfo16$numprunedBCs)] <- 0
```

Count the number of unique mutIDs prior to filtering by minimum numprunedBCs (>0 BC):
```{r class.output="goodCode"}
# Count the number of unique mutants prior to filtering:

# Lib15
format(length(unique(mutIDinfo15$mutID)), big.mark = ",")

# Lib16
format(length(unique(mutIDinfo16$mutID)), big.mark = ",")
```

Filter the `mutIDinfo` objects by minimum number of numprunedBCs (>0 BC):
```{r}
#variants must have at least 1 BC after pruning:

# Lib15
mutIDinfo15 <- mutIDinfo15 %>%
  filter(numprunedBCs>0)

# Lib16
mutIDinfo16 <- mutIDinfo16 %>%
  filter(numprunedBCs>0)
```

Count the number of unique variants remaining after filtering:
```{r class.output="goodCode"}
# Count the number of unique variants remaining after filtering:

# Lib15
format(length(unique(mutIDinfo15$mutID)), big.mark = ",")

# Lib16
format(length(unique(mutIDinfo16$mutID)), big.mark = ",")
```

## Median Fitness

Now, generate a median fitness value for each unique "mutID" based on its' associated BCs. **IMPORTANT: We have to remove "NA" values from each BC associated with each "mutID" when calculating median fitness values. If not, the code will discard the "mutID" if any of its associated BCs have an "NA" value.**
```{r}
# For each ID at each TMP treatment, calculate median fitness based on BCs associated with each ID:

# Lib15
mutIDinfo15 <- BCs15_map %>%
  group_by(mutID) %>%
  summarise(fitD03D01=median(D03D01fc,na.rm=T), fitD05D03=median(D05D03fc,na.rm=T), 
            fitD06D03=median(D06D03fc,na.rm=T), fitD07D03=median(D07D03fc,na.rm=T), 
            fitD08D03=median(D08D03fc,na.rm=T), fitD09D03=median(D09D03fc,na.rm=T), 
            fitD10D03=median(D10D03fc,na.rm=T), fitD11D03=median(D11D03fc,na.rm=T),
            fitE07D03=median(E07D03fc,na.rm=T), fitE08D03=median(E08D03fc,na.rm=T), 
            fitE09D03=median(E09D03fc,na.rm=T), fitE10D03=median(E10D03fc,na.rm=T), 
            fitE11D03=median(E11D03fc,na.rm=T), fitE12D03=median(E12D03fc,na.rm=T),
            fitF01D03=median(F01D03fc,na.rm=T), fitF09D03=median(F09D03fc,na.rm=T), 
            fitF10D03=median(F10D03fc,na.rm=T), fitF11D03=median(F11D03fc,na.rm=T), 
            fitF12D03=median(F12D03fc,na.rm=T), fitG01D03=median(G01D03fc,na.rm=T),
            fitG02D03=median(G02D03fc,na.rm=T), fitG03D03=median(G03D03fc,na.rm=T), 
            fitG11D03=median(G11D03fc,na.rm=T), fitG12D03=median(G12D03fc,na.rm=T), 
            fitH01D03=median(H01D03fc,na.rm=T), fitH02D03=median(H02D03fc,na.rm=T),
            fitH03D03=median(H03D03fc,na.rm=T), fitH04D03=median(H04D03fc,na.rm=T), 
            fitH05D03=median(H05D03fc,na.rm=T),
            ) %>%
  right_join(mutIDinfo15, by="mutID")

# Lib16
mutIDinfo16 <- BCs16_map %>%
  group_by(mutID) %>%
  summarise(fitD04D02=median(D04D02fc,na.rm=T), fitD12D04=median(D12D04fc,na.rm=T),
            fitE01D04=median(E01D04fc,na.rm=T), fitE02D04=median(E02D04fc,na.rm=T), 
            fitE03D04=median(E03D04fc,na.rm=T), fitE04D04=median(E04D04fc,na.rm=T), 
            fitE05D04=median(E05D04fc,na.rm=T), fitE06D04=median(E06D04fc,na.rm=T),
            fitF02D04=median(F02D04fc,na.rm=T), fitF03D04=median(F03D04fc,na.rm=T), 
            fitF04D04=median(F04D04fc,na.rm=T), fitF05D04=median(F05D04fc,na.rm=T), 
            fitF06D04=median(F06D04fc,na.rm=T), fitF07D04=median(F07D04fc,na.rm=T),
            fitF08D04=median(F08D04fc,na.rm=T), fitG04D04=median(G04D04fc,na.rm=T), 
            fitG05D04=median(G05D04fc,na.rm=T), fitG06D04=median(G06D04fc,na.rm=T), 
            fitG07D04=median(G07D04fc,na.rm=T), fitG08D04=median(G08D04fc,na.rm=T),
            fitG09D04=median(G09D04fc,na.rm=T), fitG10D04=median(G10D04fc,na.rm=T), 
            fitH06D04=median(H06D04fc,na.rm=T), fitH07D04=median(H07D04fc,na.rm=T), 
            fitH08D04=median(H08D04fc,na.rm=T), fitH09D04=median(H09D04fc,na.rm=T),
            fitH10D04=median(H10D04fc,na.rm=T), fitH11D04=median(H11D04fc,na.rm=T), 
            fitH12D04=median(H12D04fc,na.rm=T),
            ) %>%
  right_join(mutIDinfo16, by="mutID")
```

## Merged Libraries

Subset library `mutIDinfo` objects to retain only the fitness scores for all TMP treatments at Time Point 1.  Then, merge libraries based on shared "mutID".

### Subset Libraries

Create a new dataframe that subsets all BCs and their fitness scores for all TMP treatments at Time Point 1:
```{r}
# Select descriptive data columns and fitness scores at time point 1 from mutIDinfo

# Lib15
BCmutfitness_15 <- mutIDinfo15[, c(1,3:9,31:36)]

# Lib16
BCmutfitness_16 <- mutIDinfo16[, c(1,3:9,31:36)]
```

### Merged by mutID

**All Shared:** Merge the fitness scores derived from each library into a single dataframe based on shared mutID between the two dataset:
```{r class.output="goodCode"}
# Merge by shared "mutID"
BCmut_15.16.mutID.fitness.shared <- merge(BCmutfitness_15, BCmutfitness_16, by = "mutID", all = FALSE)

# Count the number of mutID's shared between both libraries
BCmut_15.16.mutID.fitness.shared.count <- length(unique(BCmut_15.16.mutID.fitness.shared$mutID))
format(BCmut_15.16.mutID.fitness.shared.count, big.mark = ",")
```

**All Unique:** Subset the fitness scores for all unique mutIDs derived from one library or the other into a single dataframe:
```{r class.output="goodCode"}
# Create a new dataset retaining unique mutIDs from both datasets
BCmut_15.16.mutID.fitness.unique <- bind_rows(
  anti_join(BCmutfitness_15, BCmutfitness_16, by = "mutID"),
  anti_join(BCmutfitness_16, BCmutfitness_15, by = "mutID"))

# Count the number of mutIDs unique to one library or the other
BCmut_15.16.mutID.fitness.unique.count <- length(unique(BCmut_15.16.mutID.fitness.unique$mutID))
format(BCmut_15.16.mutID.fitness.unique.count, big.mark = ",")
```

### Filtered Shared mutID

**All Shared Filtered:** Now, filter the all shared dataset to only retain mutIDs with up to 5 mutations:
```{r class.output="goodCode"}
BCmut_15.16.mutID.fitness.shared.filtered.5AA <- BCmut_15.16.mutID.fitness.shared[BCmut_15.16.mutID.fitness.shared$mutations.x < 6 & BCmut_15.16.mutID.fitness.shared$mutations.y < 6, ]

# Count the number of mutID's shared between both libraries after filtering to 5 mutations
BCmut_15.16.mutID.fitness.shared.filtered.5AA.count <- length(unique(BCmut_15.16.mutID.fitness.shared.filtered.5AA$mutID))
format(BCmut_15.16.mutID.fitness.shared.filtered.5AA.count, big.mark = ",")
```

**All Unique Filtered:** Now, filter the all unique dataset to only retain mutIDs with up to 5 mutations:
```{r class.output="goodCode"}
BCmut_15.16.mutID.fitness.unique.filtered.5AA <- BCmut_15.16.mutID.fitness.unique[BCmut_15.16.mutID.fitness.unique$mutations < 6,]

# Count the number of mutID's shared between both libraries after filtering to 5 mutations
BCmut_15.16.mutID.fitness.unique.filtered.5AA.count <- length(unique(BCmut_15.16.mutID.fitness.unique.filtered.5AA$mutID))
format(BCmut_15.16.mutID.fitness.unique.filtered.5AA.count, big.mark = ",")
```

### Merged Perfects

**Perfects Shared:** Subset the fitness scores for perfects shared between both libraries into a single dataframe:
```{r class.output="goodCode"}
# Retain only the rows with a specific value in the "specific_column" column
BCmut_15.16.mutID.fitness.shared.filtered.5AA.perfects <- BCmut_15.16.mutID.fitness.shared.filtered.5AA %>%
  filter(mutations.x == 0)

# Count the number of perfects (mutations == 0) shared between both libraries
BCmut_15.16.mutID.fitness.shared.filtered.5AA.perfects.count <- length(unique(BCmut_15.16.mutID.fitness.shared.filtered.5AA.perfects$mutID))

format(BCmut_15.16.mutID.fitness.shared.filtered.5AA.perfects.count, big.mark = ",")
```

**Perfects Unique:** Subset the fitness scores for perfects unique to one library or the other into a single dataframe:
```{r class.output="goodCode"}
# Retain only the rows with a specific value in the "specific_column" column
BCmut_15.16.mutID.fitness.unique.filtered.5AA.perfects <- BCmut_15.16.mutID.fitness.unique.filtered.5AA %>%
  filter(mutations == 0)

# Count the number of perfects (mutations == 0) unique to one library or the other
BCmut_15.16.mutID.fitness.unique.filtered.5AA.perfects.count <- length(unique(BCmut_15.16.mutID.fitness.unique.filtered.5AA.perfects$mutID))

format(BCmut_15.16.mutID.fitness.unique.filtered.5AA.perfects.count, big.mark = ",")
```

**Summarize the number of perfects shared or unique between both libraries.**
```{r class.output="goodCode"}
BCmut_15.16.perfect.mutID.fitness.all.count <- sum(BCmut_15.16.mutID.fitness.shared.filtered.5AA.perfects.count +
                                                     BCmut_15.16.mutID.fitness.unique.filtered.5AA.perfects.count)
format(BCmut_15.16.perfect.mutID.fitness.all.count, big.mark = ",")
```

### Merged Mutants

**Mutants Shared:** Subset the fitness scores for mutants shared between both libraries into a single dataframe:
```{r class.output="goodCode"}
# Retain only the rows with a specific value in the "specific_column" column
BCmut_15.16.mutID.fitness.shared.filtered.5AA.mutants <- BCmut_15.16.mutID.fitness.shared.filtered.5AA %>%
  filter(mutations.x != 0)

# Count the number of perfects (mutations != 0) shared between both libraries
BCmut_15.16.mutID.fitness.shared.filtered.5AA.mutants.count <- length(unique(BCmut_15.16.mutID.fitness.shared.filtered.5AA.mutants$mutID))

format(BCmut_15.16.mutID.fitness.shared.filtered.5AA.mutants.count, big.mark = ",")
```

**Mutants Unique:** Subset the fitness scores for mutants unique to one library or the other into a single dataframe:
```{r class.output="goodCode"}
# Retain only the rows with a specific value in the "specific_column" column
BCmut_15.16.mutID.fitness.unique.filtered.5AA.mutant <- BCmut_15.16.mutID.fitness.unique.filtered.5AA %>%
  filter(mutations != 0)

# Count the number of mutant (mutations != 0) unique to one library or the other
BCmut_15.16.mutID.fitness.unique.filtered.5AA.mutant.count <- length(unique(BCmut_15.16.mutID.fitness.unique.filtered.5AA.mutant$mutID))

format(BCmut_15.16.mutID.fitness.unique.filtered.5AA.mutant.count, big.mark = ",")
```

**Summarize the number of mutants shared or unique between both libraries.**
```{r class.output="goodCode"}
BCmut_15.16.mutant.mutID.fitness.all.count <- sum(BCmut_15.16.mutID.fitness.shared.filtered.5AA.mutants.count +
                                                    BCmut_15.16.mutID.fitness.unique.filtered.5AA.mutant.count)
format(BCmut_15.16.mutant.mutID.fitness.all.count, big.mark = ",")
```

## Wildtype E coli

The mutID for wildtype E. coli is: NP_414590

Start by pulling out the wildtype E. coli mutID from the full dataset:
```{r}
# Lib15
BCmut15_NP_414590 <- BCs15_map %>%
  filter(mutID=="NP_414590") %>%
  select(-cigar)

# Lib16
BCmut16_NP_414590 <- BCs16_map %>%
  filter(mutID=="NP_414590") %>%
  select(-cigar)
```

Subset the logFC data columns for Time Point 1 and define the treatment levels for each comparison:
```{r}
# Lib15
BCmut15_NP_414590_logfc <- BCmut15_NP_414590 %>%
  select(BC, D05D03fc, D06D03fc, D07D03fc, D08D03fc, D09D03fc, D10D03fc, D11D03fc) %>%
  pivot_longer(!BC, names_to = "fc", values_to = "val") %>%
  mutate(Lib = "Lib15",
         TMP = case_when(
           fc == "D05D03fc" ~ "0-TMP",
           fc == "D06D03fc" ~ "0.058-TMP",
           fc == "D07D03fc" ~ "0.5-TMP",
           fc == "D08D03fc" ~ "1.0-TMP",
           fc == "D09D03fc" ~ "10-TMP",
           fc == "D10D03fc" ~ "50-TMP",
           fc == "D11D03fc" ~ "200-TMP",
           TRUE ~ NA_character_))

# Lib16
BCmut16_NP_414590_logfc <- BCmut16_NP_414590 %>%
  select(BC, D12D04fc, E01D04fc, E02D04fc, E03D04fc, E04D04fc, E05D04fc, E06D04fc) %>%
  pivot_longer(!BC, names_to = "fc", values_to = "val") %>%
  mutate(Lib = "Lib16",
         TMP = case_when(
           fc == "D12D04fc" ~ "0-TMP",
           fc == "E01D04fc" ~ "0.058-TMP",
           fc == "E02D04fc" ~ "0.5-TMP",
           fc == "E03D04fc" ~ "1.0-TMP",
           fc == "E04D04fc" ~ "10-TMP",
           fc == "E05D04fc" ~ "50-TMP",
           fc == "E06D04fc" ~ "200-TMP",
           TRUE ~ NA_character_))
```

Remove "NA" values
```{r}
# Lib15
BCmut15_NP_414590_logfc <- na.omit(BCmut15_NP_414590_logfc)

# Lib16
BCmut16_NP_414590_logfc <- na.omit(BCmut16_NP_414590_logfc)
```

Combine the Library dataframes and remove BC column
```{r}
# Combine the data frames
BCmut_15_16_NP_414590_logfc <- rbind(BCmut15_NP_414590_logfc %>% select(-BC),
                                     BCmut16_NP_414590_logfc %>% select(-BC))
```

Generate the boxplot with both libraries
```{r}
# Define the plotting order
BCmut_15_16_NP_414590_logfc_order <- c("0-TMP", "0.058-TMP", "0.5-TMP", "1.0-TMP", "10-TMP", "50-TMP", "200-TMP")

# Generate the boxplot
BCmut_15_16_NP_414590_logfc_plot <- ggplot(BCmut_15_16_NP_414590_logfc, aes(x = TMP, y = val, fill = Lib)) +
  geom_boxplot(position = "dodge") +
  scale_x_discrete(limits = BCmut_15_16_NP_414590_logfc_order, drop = FALSE) +
  xlab("") +
  ylab(expression(atop("Wild Type "~italic("E. coli")~" Fitness", "Log2-Fold Change"))) +
  #ggtitle("Wild-Type (WT) E. coli Homolog Fitness") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        #plot.title = element_text(size = 16, hjust = 0, face = "bold"), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(),
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 12), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        legend.text = element_text(size = 12),
        legend.position = c(1, 1),
        legend.justification = c(1, 1),
        legend.box.background = element_rect(colour = "black")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00")) +
  scale_y_continuous(expand = c(0, 0), limits = c(-6, 3))

BCmut_15_16_NP_414590_logfc_plot
```

```{r echo=FALSE}
ggsave(file="plots/WT/Lib15.16.WT.e.coli.fitness.boxplot.png", plot=BCmut_15_16_NP_414590_logfc_plot,
       dpi=600, width = 6, height = 5, units = "in")
```

## Controls
The following section summarizes the log2-fold change in **CONTROL** barcodes between A05 vs. A06 sampling conditions.

### Control Barcodes
Load in the controls and their associated barcodes:
```{r}
#load controls
controls = read.csv("counts/control_BCs.csv", head=FALSE)
colnames(controls) <- c("ctrlname","colnum","BClong","BC","BClen")
```

The following code corrects an error in the control BCs before mapping to the Count files:
```{r}
controls <- controls %>%
  mutate(BCstub=str_sub(BClong,1,-4)) %>%
  dplyr::rename(BCold=BC) %>%
  dplyr::rename(BC=BCstub)
```

Summarize the number of control barcodes from the full pruned `BCs` dataset:
```{r, class.output="goodCode"}
# Library 15

# Map the Control BCs to the BCs.prune dataset for all samples:
BCcontrols_15 <- inner_join(BCs15.prune,controls,by="BC")

# Re-arrange the resulting dataframe to place the descriptive columns at the beginning:
BCcontrols_15 <- BCcontrols_15[, c(1, 32, 36, 2:31)]

# Count the number of unique control barcodes mapped to the full pruned BCs dataset:
BCcontrols_15.count <- inner_join(BCs15.prune,controls,by="BC") %>%
  nrow()

BCcontrols_15.count
```

```{r}
# Library 16

# Map the Control BCs to the BCs.prune dataset for all samples:
BCcontrols_16 <- inner_join(BCs16.prune,controls,by="BC")

# Re-arrange the resulting dataframe to place the descriptive columns at the beginning:
BCcontrols_16 <- BCcontrols_16[, c(1, 32, 36, 2:31)]

# Count the number of unique control barcodes mapped to the full pruned BCs dataset:
BCcontrols_16.count <- inner_join(BCs16.prune,controls,by="BC") %>%
  nrow()

BCcontrols_16.count
```

### Control BC Scaling

**Lib15:** Scale the control BC counts for each sampling condition (D05n, D06n, etc) based on the scaling values provided:
```{r}
# Lib15

# Make new columns for the normalized counts in the BCs object:
control.oldnames15 <- colnames(BCcontrols_15)
control.newnamesfrac15 = c('D01n', 'D03n', 
                   'D05n', 'D06n', 'D07n', 'D08n', 'D09n', 'D10n', 'D11n', 
                   'E07n', 'E08n', 'E09n', 'E10n', 'E11n', 'E12n', 'F01n', 
                   'F09n', 'F10n', 'F11n', 'F12n', 'G01n', 'G02n', 'G03n', 
                   'G11n', 'G12n', 'H01n', 'H02n', 'H03n', 'H04n', 'H05n')

# Add the new columns to the BCs object based on the number of original columns for sampling conditions:
control.numcol_15 <- ncol(BCcontrols_15)
control.D01index = which(colnames(BCcontrols_15)=="D01")

# For each sample, re-scale the number of reads by relative sequencing depth of the sample using the scaling values in the norm_vals object:
for (i in 1:30){
  BCcontrols_15[,control.numcol_15+i] <- BCcontrols_15[,control.D01index+i-1]*as.numeric(norm_vals_15$scaling[i])
}

# Add the new column names to the BCs object:
colnames(BCcontrols_15) <- c(control.oldnames15,control.newnamesfrac15)
```

**Lib16:** Scale the control BC counts for each sampling condition (D012n, E01n, etc) based on the scaling values provided:
```{r}
# Lib16

# Make new columns for the normalized counts in the BCs object:
control.oldnames16 <- colnames(BCcontrols_16)
control.newnamesfrac16 = c('D02n', 'D04n', 
                   'D12n', 'E01n', 'E02n', 'E03n', 'E04n', 'E05n', 'E06n', 
                   'F02n', 'F03n', 'F04n', 'F05n', 'F06n', 'F07n', 'F08n', 
                   'G04n', 'G05n', 'G06n', 'G07n', 'G08n', 'G09n', 'G10n', 
                   'H06n', 'H07n', 'H08n', 'H09n', 'H10n', 'H11n', 'H12n')

# Add the new columns to the BCs object based on the number of original columns for sampling conditions:
control.numcol_16 <- ncol(BCcontrols_16)
control.D02index = which(colnames(BCcontrols_16)=="D02")

# For each sample, re-scale the number of reads by relative sequencing depth of the sample using the scaling values in the norm_vals object:
for (i in 1:30){
  BCcontrols_16[,control.numcol_16+i] <- BCcontrols_16[,control.D02index+i-1]*as.numeric(norm_vals_16$scaling[i])
}

# Add the new column names to the BCs object:
colnames(BCcontrols_16) <- c(control.oldnames16,control.newnamesfrac16)
```

### Control LogFC

**Standard Approach** Determine the log2-fold changes for each control BC relative to the M9-Supplementation condition:
```{r}
# Lib 15

BCcontrols_15 <- BCcontrols_15 %>%
  mutate(D03D01fc=log2(D03n+pseudocount)-log2(D01n+pseudocount),
         D05D03fc=log2(D05n+pseudocount)-log2(D03n+pseudocount),
         D06D03fc=log2(D06n+pseudocount)-log2(D03n+pseudocount),
         D07D03fc=log2(D07n+pseudocount)-log2(D03n+pseudocount),
         D08D03fc=log2(D08n+pseudocount)-log2(D03n+pseudocount),
         D09D03fc=log2(D09n+pseudocount)-log2(D03n+pseudocount),
         D10D03fc=log2(D10n+pseudocount)-log2(D03n+pseudocount),
         D11D03fc=log2(D11n+pseudocount)-log2(D03n+pseudocount),
         E07D03fc=log2(E07n+pseudocount)-log2(D03n+pseudocount),
         E08D03fc=log2(E08n+pseudocount)-log2(D03n+pseudocount),
         E09D03fc=log2(E09n+pseudocount)-log2(D03n+pseudocount),
         E10D03fc=log2(E10n+pseudocount)-log2(D03n+pseudocount),
         E11D03fc=log2(E11n+pseudocount)-log2(D03n+pseudocount),
         E12D03fc=log2(E12n+pseudocount)-log2(D03n+pseudocount),
         F01D03fc=log2(F01n+pseudocount)-log2(D03n+pseudocount),
         F09D03fc=log2(F09n+pseudocount)-log2(D03n+pseudocount),
         F10D03fc=log2(F10n+pseudocount)-log2(D03n+pseudocount),
         F11D03fc=log2(F11n+pseudocount)-log2(D03n+pseudocount),
         F12D03fc=log2(F12n+pseudocount)-log2(D03n+pseudocount),
         G01D03fc=log2(G01n+pseudocount)-log2(D03n+pseudocount),
         G02D03fc=log2(G02n+pseudocount)-log2(D03n+pseudocount),
         G03D03fc=log2(G03n+pseudocount)-log2(D03n+pseudocount),
         G11D03fc=log2(G11n+pseudocount)-log2(D03n+pseudocount),
         G12D03fc=log2(G12n+pseudocount)-log2(D03n+pseudocount),
         H01D03fc=log2(H01n+pseudocount)-log2(D03n+pseudocount),
         H02D03fc=log2(H02n+pseudocount)-log2(D03n+pseudocount),
         H03D03fc=log2(H03n+pseudocount)-log2(D03n+pseudocount),
         H04D03fc=log2(H04n+pseudocount)-log2(D03n+pseudocount),
         H05D03fc=log2(H05n+pseudocount)-log2(D03n+pseudocount))

# Lib 16

BCcontrols_16 <- BCcontrols_16 %>%
  mutate(D04D02fc=log2(D04n+pseudocount)-log2(D02n+pseudocount),
         D12D04fc=log2(D12n+pseudocount)-log2(D04n+pseudocount),
         E01D04fc=log2(E01n+pseudocount)-log2(D04n+pseudocount),
         E02D04fc=log2(E02n+pseudocount)-log2(D04n+pseudocount),
         E03D04fc=log2(E03n+pseudocount)-log2(D04n+pseudocount),
         E04D04fc=log2(E04n+pseudocount)-log2(D04n+pseudocount),
         E05D04fc=log2(E05n+pseudocount)-log2(D04n+pseudocount),
         E06D04fc=log2(E06n+pseudocount)-log2(D04n+pseudocount),
         F02D04fc=log2(F02n+pseudocount)-log2(D04n+pseudocount),
         F03D04fc=log2(F03n+pseudocount)-log2(D04n+pseudocount),
         F04D04fc=log2(F04n+pseudocount)-log2(D04n+pseudocount),
         F05D04fc=log2(F05n+pseudocount)-log2(D04n+pseudocount),
         F06D04fc=log2(F06n+pseudocount)-log2(D04n+pseudocount),
         F07D04fc=log2(F07n+pseudocount)-log2(D04n+pseudocount),
         F08D04fc=log2(F08n+pseudocount)-log2(D04n+pseudocount),
         G04D04fc=log2(G04n+pseudocount)-log2(D04n+pseudocount),
         G05D04fc=log2(G05n+pseudocount)-log2(D04n+pseudocount),
         G06D04fc=log2(G06n+pseudocount)-log2(D04n+pseudocount),
         G07D04fc=log2(G07n+pseudocount)-log2(D04n+pseudocount),
         G08D04fc=log2(G08n+pseudocount)-log2(D04n+pseudocount),
         G09D04fc=log2(G09n+pseudocount)-log2(D04n+pseudocount),
         G10D04fc=log2(G10n+pseudocount)-log2(D04n+pseudocount),
         H06D04fc=log2(H06n+pseudocount)-log2(D04n+pseudocount),
         H07D04fc=log2(H07n+pseudocount)-log2(D04n+pseudocount),
         H08D04fc=log2(H08n+pseudocount)-log2(D04n+pseudocount),
         H09D04fc=log2(H09n+pseudocount)-log2(D04n+pseudocount),
         H10D04fc=log2(H10n+pseudocount)-log2(D04n+pseudocount),
         H11D04fc=log2(H11n+pseudocount)-log2(D04n+pseudocount),
         H12D04fc=log2(H12n+pseudocount)-log2(D04n+pseudocount))
```

### Plotting Controls

#### Plot by Control

**Lib15 Controls**
Plot the control barcodes as the log2-fold change comparison between D05 vs. D03:
```{r}
# Plot the Fraction of Total Barcodes Mapped
ctrl_comp_plot_L15 <- ggplot(data = BCcontrols_15, aes(x = ctrlname, y = D05D03fc, fill = ctrlname)) +
  geom_boxplot(alpha = 0.8) +
  geom_point() +
  xlab("") +
  ylab("Control Fitness at Complementation \n(Log2-Fold Change)") +
  ggtitle("Library 15 Control Fitness") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(), 
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 12), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_fill_manual(values = c("D27N" = "#00800080", "mCherry" = "#FF000080", "WT" = "#0000FF80")) +
  guides(linetype = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-3, 0))

ctrl_comp_plot_L15
```

**Lib16 Controls**
Plot the control barcodes as the log2-fold change comparison between D12 vs. D04:
```{r}
# Plot the Fraction of Total Barcodes Mapped
ctrl_comp_plot_L16 <- ggplot(data = BCcontrols_16, aes(x = ctrlname, y = D12D04fc, fill = ctrlname)) +
  geom_boxplot(alpha = 0.8) +
  geom_point() +
  xlab("") +
  ylab("") +
  ggtitle("Library 16 Control Fitness") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(), 
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 12), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        legend.position = "none") +
  scale_fill_manual(values = c("D27N" = "#00800080", "mCherry" = "#FF000080", "WT" = "#0000FF80")) +
  guides(linetype = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-3, 0))

ctrl_comp_plot_L16
```

```{r echo=FALSE}
# Library 15
ggsave(file="plots/controls/controls_Lib15_D05D03fc.png", plot=ctrl_comp_plot_L15,
       dpi=600, width = 6, height = 4, units = "in")

# Library 16
ggsave(file="plots/controls/controls_Lib16_D12D04fc.png", plot=ctrl_comp_plot_L16,
       dpi=600, width = 6, height = 4, units = "in")
```

```{r echo=FALSE}
patch3 <- (ctrl_comp_plot_L15 | ctrl_comp_plot_L16)
patch3
```

```{r echo=FALSE}
ggsave(file="plots/controls/Lib15.16.ctrls.complementation.time1.png", plot=patch3,
       dpi=600, width = 10, height = 4, units = "in")
```

```{r echo=FALSE, results='hide'}
# Library 15
write.csv(BCcontrols_15,"OUTPUT/BC_15_controls.csv", row.names = FALSE)

# Library 16
write.csv(BCcontrols_16,"OUTPUT/BC_16_controls.csv", row.names = FALSE)
```

#### Plot by TMP

Subset the logFC data columns
```{r}
# Lib15
BCcontrols_15_logfc <- BCcontrols_15 %>%
  select(BC, ctrlname, D05D03fc, D06D03fc, D07D03fc, D08D03fc, D09D03fc, D10D03fc, D11D03fc) %>%
  pivot_longer(cols = -c(BC, ctrlname),
               names_to = "fc",
               names_pattern = "^(.+)$",
               values_to = "val") %>%
  select(BC, Ctrl = ctrlname, fc, val)
```

```{r}
# Lib16
BCcontrols_16_logfc <- BCcontrols_16 %>%
  select(BC, ctrlname, D12D04fc, E01D04fc, E02D04fc, E03D04fc, E04D04fc, E05D04fc, E06D04fc) %>%
  pivot_longer(cols = -c(BC, ctrlname),
               names_to = "fc",
               names_pattern = "^(.+)$",
               values_to = "val") %>%
  select(BC, Ctrl = ctrlname, fc, val)
```

Remove "NA" values
```{r}
# Lib15
BCcontrols_15_logfc <- na.omit(BCcontrols_15_logfc)

# Lib16
BCcontrols_16_logfc <- na.omit(BCcontrols_16_logfc)
```

Place sample IDs in desired order for plotting
```{r}
# Lib15
Lib15_CTRL_level_order <- c("D05D03fc", "D06D03fc", "D07D03fc", "D08D03fc", "D09D03fc", "D10D03fc", "D11D03fc")

# Lib16
Lib16_CTRL_level_order <- c("D12D04fc", "E01D04fc", "E02D04fc", "E03D04fc", "E04D04fc", "E05D04fc", "E06D04fc")
```

**Lib15**
```{r}
Lib15_TMP_level_order <- c("D05D03fc", "D06D03fc", "D07D03fc", "D08D03fc", "D09D03fc", "D10D03fc", "D11D03fc")

ctrl_tmp_plot_L15 <- ggplot(BCcontrols_15_logfc, aes(x = factor(fc, levels = Lib15_TMP_level_order), y = val, fill = Ctrl)) +
  geom_boxplot(color = "black", width = 0.5, alpha = 0.8) +
  geom_point() +
  ggtitle("Control Fitness by Trimethoprim Treatment") +
  ylab("Library 15 Control Fitness\n(Log2-Fold Change)") +
  xlab("") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        plot.title = element_text(size = 16, hjust = 0.5, face = "bold"), 
        axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(), 
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 14), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        legend.position = "none") +
  guides(linetype = "none") +
  scale_x_discrete(labels = c("0-tmp", "0.058-tmp", "0.5-tmp", "1.0-tmp", "10-tmp", "50-tmp", "200-tmp")) +
  scale_fill_manual(values = c("D27N" = "#00800080", "mCherry" = "#FF000080", "WT" = "#0000FF80"))

ctrl_tmp_plot_L15
```

**Lib16**
```{r}
Lib16_TMP_level_order <- c("D12D04fc", "E01D04fc", "E02D04fc", "E03D04fc", "E04D04fc", "E05D04fc", "E06D04fc")

ctrl_tmp_plot_L16 <- ggplot(BCcontrols_16_logfc, aes(x = factor(fc, levels = Lib16_TMP_level_order), y = val, fill = Ctrl)) +
  geom_boxplot(color = "black", width = 0.5, alpha = 0.8) +
  geom_point() +
  #ggtitle("Library 16 Control Fitness") +
  ylab("Library 16 Control Fitness\n(Log2-Fold Change)") +
  xlab("") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5), 
        plot.title = element_text(size = 16, hjust = 0.5, face = "bold"), 
        axis.text.x = element_text(size = 12, angle = 45, hjust = 1), 
        axis.text.y = element_text(size = 12), 
        panel.background = element_blank(), 
        axis.title.x = element_text(size = 12), 
        axis.title.y = element_text(size = 14), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        legend.position = "bottom") +
  guides(linetype = "none") +
  scale_x_discrete(labels = c("0-tmp", "0.058-tmp", "0.5-tmp", "1.0-tmp", "10-tmp", "50-tmp", "200-tmp")) +
  scale_fill_manual(values = c("D27N" = "#00800080", "mCherry" = "#FF000080", "WT" = "#0000FF80"))

ctrl_tmp_plot_L16
```

```{r echo=FALSE}
# Library 15
ggsave(file="plots/controls/Lib15.controls.tmp.gradient.png", plot=ctrl_tmp_plot_L15,
       dpi=600, width = 6, height = 4, units = "in")

# Library 16
ggsave(file="plots/controls/Lib16.controls.tmp.gradient.png", plot=ctrl_tmp_plot_L16,
       dpi=600, width = 6, height = 4, units = "in")
```

```{r echo=FALSE}
patch4 <- (ctrl_tmp_plot_L15 / ctrl_tmp_plot_L16)
patch4
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.ctrls.trimethoprim.time1.png", plot=patch4,
       dpi=600, width = 8, height = 10, units = "in")
```

# Lib15 Replication

**The following steps must be completed for Lib15.v1 prior to generating correlations with the Lib15.v2 dataset:**

  - Import the Lib15.v1 dataset
  - Prune short BCs (remove BCs < 20 bp)
  - Normalize read counts (M9-Supplement conditions)
  - Calculate Log2-FC fitness values (by treatment)
  - Calculate median fitness values (by shared BCs)
  - Filter by minimum BCs (numprunedBCs > 0)
  - Merge Lib15.v1 with Lib15.v2 (based on shared mutIDs)

## Import Lib15.v1

**Import the count data (sequences) for each sampling condition in Lib15.v1.** Each .csv file contains two columns: **(1)** "BC" represents the unique barcode recovered from the sampling condition, and **(2)** "A0X" represents the sequence counts matching each barcode within the sampling condition.
```{r}
### Library 15.v1 (Carmen Resnick - Thesis Dataset)

# A05 - Lib15.v1 - Overnight Growth on M9-Full Supplement
A05 = read.csv("CR_Lib15/counts/A05_clustered_LD1.txt", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(A05) <- c("BC","A05")

# A06 - Lib15.v1 - Overnight Growth on M9-No Supplement - 0 TMP
A06 = read.csv("CR_Lib15/counts/A06_clustered_LD1.txt", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(A06) <- c("BC","A06")

# A07 - Lib15.v1 - 0.058 TMP
A07 = read.csv("CR_Lib15/counts/A07_clustered_LD1.txt", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(A07) <- c("BC","A07")

# A08 - Lib15.v1 - 0.5 TMP
A08 = read.csv("CR_Lib15/counts/A08_clustered_LD1.txt", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(A08) <- c("BC","A08")

# A09 - Lib15.v1 - 1.0 TMP
A09 = read.csv("CR_Lib15/counts/A09_clustered_LD1.txt", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(A09) <- c("BC","A09")

# A10 - Lib15.v1 - 10 TMP
A10 = read.csv("CR_Lib15/counts/A10_clustered_LD1.txt", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(A10) <- c("BC","A10")

# A11 - Lib15.v1 - 50 TMP
A11 = read.csv("CR_Lib15/counts/A11_clustered_LD1.txt", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(A11) <- c("BC","A11")

# A12 - Lib15.v1 - 200 TMP
A12 = read.csv("CR_Lib15/counts/A12_clustered_LD1.txt", head=FALSE, sep="\t") %>%
  select(-V3)
colnames(A12) <- c("BC","A12")
```

## Raw Read Counts

**Summarize the imported count data by sampling condition for each codon-version library.** Begin by combining the count data from each sampling condition into a single dataframe for each library. Next, sum the full count values for each sampling condition (total number of sequences recovered for each sampling condition). Then, sum the number of unique barcodes recovered from each sampling condition. Define the sampling condition associated with each sample code.
```{r}
## Library 15.v1

# Merge data objects together into single dataframe
norm_vals_15.v1 <- data.frame(sample=c("A05","A06","A07","A08","A09","A10","A11","A12"),
                        counts=c(sum(A05$A05),sum(A06$A06),sum(A07$A07),
                                 sum(A08$A08),sum(A09$A09),sum(A10$A10),
                                 sum(A11$A11),sum(A12$A12)),
                        numBCs=c(length(A05$A05),length(A06$A06),length(A07$A07),
                                 length(A08$A08),length(A09$A09),length(A10$A10),
                                 length(A11$A11),length(A12$A12)),
                        sampledesc=c("A05 - Lib15.v1 - Growth on M9 - Full Supplement",
                                     "A06 - Lib15.v1 - Growth on M9 - 0.0 ug/ml TMP",
                                     "A07 - Lib15.v1 - Growth on M9 - 0.058 ug/ml TMP",
                                     "A08 - Lib15.v1 - Growth on M9 - 0.5 ug/ml TMP",
                                     "A09 - Lib15.v1 - Growth on M9 - 1.0 ug/ml TMP",
                                     "A10 - Lib15.v1 - Growth on M9 - 10.0 ug/ml TMP",
                                     "A11 - Lib15.v1 - Growth on M9 - 50.0 ug/ml TMP",
                                     "A12 - Lib15.v1 - Growth on M9 - 200.0 ug/ml TMP"),
                        TMP=c("Full Supplement", "0-tmp", "0.058-tmp", "0.5-tmp",
                              "1.0-tmp", "10-tmp", "50-tmp", "200-tmp"))
```

<font color="green">**Library 15.v1 Summarized Count Data for Sequences and Barcodes (BC)**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_15.v1_col1 <- norm_vals_15.v1[,c(4,1,2,3)]

knitr::kable(norm_vals_15.v1_col1,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts'),
  align = "lccl",
  format.args = list(big.mark = ","))
```

## Raw BC Counts

**Merge and prune BCs from the imported count data by sampling condition for each codon-version library.** Begin by combining the count data BCs from each sampling condition into a single dataframe for each library. Next, prune BCs to retain only those BCs with exactly 20 bp. Then, map the remaining BCs to the BC mapping file to determine how many BCs we were able to map relative to all BCs recovered.
```{r}
# Library 15.v1
BCs15.v1 <- A05 %>%
  full_join(A06,by="BC") %>%
  full_join(A07,by="BC") %>%
  full_join(A08,by="BC") %>%
  full_join(A09,by="BC") %>%
  full_join(A10,by="BC") %>%
  full_join(A11,by="BC") %>%
  full_join(A12,by="BC")
```

<font color="green">**Preview of BCs count data with N/A for blank values**</font>
```{r echo=FALSE}
head(BCs15.v1)
```

**Total BCs:** Count the number of unique barcode for Library 15.v1
```{r class.output="goodCode"}
# Count the number of unique barcodes for Library 15
BCs15.v1.count <- length(unique(BCs15.v1$BC))
format(BCs15.v1.count, big.mark = ",")
```

## BC Pruning

Remove unique BCs less than 20 nucleotides in length as these do not represent true BCs from designed pool.
```{r class.output="goodCode"}
# Lib15: Sum the count of unique BC lengths in the BCs objects
BCs15.v1.unique.table <- table(str_length(BCs15.v1$BC))
BCs15.v1.unique.table
```

Filter rows where the length of BC is greater than or equal to 20
```{r}
BCs15.v1.prune <- BCs15.v1 %>%
  filter(str_length(BC) >= 20)
```

Sum the count of unique BC lengths in the BCprune objects
```{r class.output="goodCode"}
BCs15.v1.prune.unique.table <- table(str_length(BCs15.v1.prune$BC))
BCs15.v1.prune.unique.table
```

**Total BCs:** Count the number of unique barcode for each library after pruning by BC length
```{r class.output="goodCode"}
BCs15.v1.prune.count <- length(unique(BCs15.v1.prune$BC))
format(BCs15.v1.prune.count, big.mark = ",")
```

## BC Mapping

Map each pruned BC to it's corresponding BC in the `BCs_mutID` mapping file. This links each BC (normalized and pruned) recovered in each count file with its identifying sequence information from the mapping file.
```{r class.output="goodCode"}
# Library 15
BCs15.v1_map <- inner_join(BCs_mutID_15,BCs15.v1.prune,by="BC")
```

Make a copy of the `BCs_map` datasets and convert "NA" values to "0" values to calculate the fraction of reads and BCs mapped:
```{r}
# Lib15
BCs15.v1_map_frac <- BCs15.v1_map

# Convert "NA" values to "0"
BCs15.v1_map_frac[, 11:18][is.na(BCs15.v1_map[, 11:18])] <- 0
```

### Mapped Reads & BCs

Calculate the total number of reads and unique barcodes recovered from each sampling condition.
```{r}
# Lib15

# Sum the total reads recovered from each sampling condition:
norm_vals_15.v1$mappedcounts <- c(sum(BCs15.v1_map_frac$A05),
                                  sum(BCs15.v1_map_frac$A06),
                                  sum(BCs15.v1_map_frac$A07),
                                  sum(BCs15.v1_map_frac$A08),
                                  sum(BCs15.v1_map_frac$A09),
                                  sum(BCs15.v1_map_frac$A10),
                                  sum(BCs15.v1_map_frac$A11),
                                  sum(BCs15.v1_map_frac$A12))

# Determine the number of unique barcodes recovered from each sampling condition:
norm_vals_15.v1$mappedBCs <- c(length(BCs15.v1_map_frac$A05[BCs15.v1_map_frac$A05 != 0]),
                               length(BCs15.v1_map_frac$A06[BCs15.v1_map_frac$A06 != 0]),
                               length(BCs15.v1_map_frac$A07[BCs15.v1_map_frac$A07 != 0]),
                               length(BCs15.v1_map_frac$A08[BCs15.v1_map_frac$A08 != 0]),
                               length(BCs15.v1_map_frac$A09[BCs15.v1_map_frac$A09 != 0]),
                               length(BCs15.v1_map_frac$A10[BCs15.v1_map_frac$A10 != 0]),
                               length(BCs15.v1_map_frac$A11[BCs15.v1_map_frac$A11 != 0]),
                               length(BCs15.v1_map_frac$A12[BCs15.v1_map_frac$A12 != 0]))
```

<font color="green">**Table of Summarized Count Data including Mapped Counts and Mapped BCs for each Sample Condition**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_15.v1_col3 <- norm_vals_15.v1[,c(4,1,2,3,6,7)]

knitr::kable(norm_vals_15.v1_col3,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs'),
  align = "llccccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

### Frac Reads & BCs Mapped

Calculate the fraction of mapped counts and BCs relative to total counts and BCs, respectively
```{r}
# Calculate the fraction of mapped counts or barcodes relative to total counts or barcodes, respectively
norm_vals_15.v1 <- norm_vals_15.v1 %>%
  mutate(frac_mapped_counts=mappedcounts/counts,
         frac_mapped_BC=mappedBCs/numBCs)
```

<font color="green">**Table of Summarized Count Data including Mapped Counts and Mapped BCs for each Sample Condition**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_15.v1_col4 <- norm_vals_15.v1[,c(4,1,2,3,6,7,8,9)]

knitr::kable(norm_vals_15.v1_col4,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs', 'Frac Mapped Counts', 'Frac Mapped BCs'),
  align = "llccccccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

## BC Filtering

Up to this point, raw BCs have been pruned by BC length and all remaining BC counts have been normalized against sequence reads at **"T0 - M9 - Full Supplement"**. Here, we'll start by adding the raw count values, normalized count values, and log2-FC values for each BC to the `BCmut` object that represent the pre-filtered BC counts. Then, we'll filter BCs from our library datasets based on a minimum sequence count threshold across sampling conditions for use in all downstream analyses. **We use a minimum cutoff of 10 sequence reads per barcode.**

Count the number of unique BCs prior to filtering by minimum sequence count:
```{r class.output="goodCode"}
# Count the number of BCs prior to filtering by minimum sequence count
BCmut_15.v1.pre.count <- BCs15.v1_map %>% nrow()
format(BCmut_15.v1.pre.count, big.mark = ",")
```

### Filtered BCs

Determine the number of unique barcodes based on a minimum sequence count threshold across sampling conditions. Filter the barcodes by a minimum threshold of sequence reads per unique barcode. In this case, we use a minimum cutoff of 10 sequence reads per barcode:
```{r class.output="goodCode"}
# Filter unique barcodes by minimum sequence count. This code uses "or" such that if any of the sampling conditions contain at least 10 sequences counts/barcode, then the barcode is retained for the full dataset.

# Lib15
BCs15.v1_map <- BCs15.v1_map %>%
  filter(A05>9 | A06>9 | A07>9 | A08>9 | A09>9 | A10>9 | A11>9 | A12>9)

# Count the number of BCs remaining after filtering by minimum sequence count
BCs15.v1_map.count <- BCs15.v1_map %>% nrow()
format(BCs15.v1_map.count, big.mark = ",")
```

Confirm that all unique BCs match the 20-bp length requirement after filtering by minimum sequence count
```{r class.output="goodCode"}
# Lib15: Sum the count of unique BCs that match the 20-bp length requirement in the BCs15_map object
BC_filter15.v1.unique.table <- table(str_length(BCs15.v1_map$BC))
format(BC_filter15.v1.unique.table, big.mark = ",")
```

**Unique mutID:** Count the number of unique mutIDs after filtering by minimum sequence count:
```{r class.output="goodCode"}
format(length(unique(BCs15.v1_map$mutID)), big.mark = ",")
```

**Unique IDalign:** Count the number of unique IDaligns (designed homologs) remaining after filtering by minimum sequence count
```{r class.output="goodCode"}
format(length(unique(BCs15.v1_map$IDalign)), big.mark = ",")
```

**Unique Perfects:** How many unique perfects (designed homologs with 0 mutations) did we recover from all sampling conditions after filtering by minimum sequence count?
```{r class.output="goodCode"}
perf_filtered_uniq_15.v1 <- BCs15.v1_map %>%
  filter(mutations==0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(perf_filtered_uniq_15.v1, big.mark = ",")
```

**Unique Perfects by TMP Treatment:** How many unique perfects did we recover from each TMP sampling treatment after filtering by minimum sequence count?
```{r class.output="goodCode"}
# Columns to count distinct values for
columns_to_count15.v1 <- c("A05", "A06", "A07", "A08", "A09", "A10", "A11", "A12")

# Count unique values in "mutID" associated with each column
counts_table15.v1 <- BCs15.v1_map %>%
  filter(mutations == 0) %>%
  summarise(across(all_of(columns_to_count15.v1), ~ n_distinct(mutID[. > 0])))

# Display the counts table
print(counts_table15.v1)
```

**Unique Mutants:** How many unique mutants did we recover from all sampling conditions after filtering by minimum sequence count?
```{r class.output="goodCode"}
mutant_filtered_15.v1 <- BCs15.v1_map %>%
  filter(mutations!=0) %>%
  select(mutID) %>%
  distinct() %>%
  nrow()
format(mutant_filtered_15.v1, big.mark = ",")
```

## Normalization

Count data needs to be normalized across sampling conditions prior to making any downstream comparisons. Here, we scale the sequence counts against the "Overnight Growth on M9-Full Supplement" sampling condition.

**Lib15.v1 Scaling:** Create a scaling value to normalize all sequence count data by the total number of sequences at "Growth on M9 - Full Supplement" sample condition (Lib15.v1: A05).
```{r}
# Calculating the scaling factor for each sampling condition based on D03 (T0-M9-Full Supplement) as the standard
norm_scaling_15.v1 <- rep.int(norm_vals_15.v1$counts[1],nrow(norm_vals_15.v1))/norm_vals_15.v1$counts

# Add the scaling values as a column to the "norm_vals_15" dataframe
norm_vals_15.v1$scaling <- norm_scaling_15.v1
```

<font color="green">**Table of Summarized Count Data including the Scaling Value for each Sample Condition**</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
norm_vals_15.v1_col2 <- norm_vals_15.v1[,c(4,1,2,3,6,7,10)]

knitr::kable(norm_vals_15.v1_col2,
  col.names = c('Sample Conditions', 'Sample ID', 'Seq Counts', 'BC Counts', 'Mapped Counts', 'Mapped BCs', 'Scaling'),
  align = "llccc",
  format.args = list(big.mark = ","),
  digits = 2)
```

**Scaling Counts by Barcode:** <font color="green">The following table displays a preview of the original count values by unique barcode:</font>
```{r echo=FALSE}
# Display dataframe with kable formatting
BCs15.v1_head <- head(BCs15.v1_map[, c(1, 11:18)])

knitr::kable(BCs15.v1_head,
  col.names = c('BC','A05', 'A06', 'A07', 'A08', 'A09', 'A10', 'A11','A12'),
  align = "lcccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

For each sample, make a normalized counts value based on sequencing depth using the scaling values derived for each sampling condition in the table above. 
```{r}
# Make new columns for the normalized counts in the BCs object:
oldnames15.v1 <- colnames(BCs15.v1_map)
newnamesfrac15.v1 = c('A05n', 'A06n', 'A07n', 'A08n', 'A09n', 'A10n', 'A11n','A12n')

# Add the new columns to the BCs object based on the number of original columns for sampling conditions:
numcol_15.v1 <- ncol(BCs15.v1_map)
A05index = which(colnames(BCs15.v1_map)=="A05")

# For each sample, re-scale the number of reads by relative sequencing depth of the sample using the scaling values in the norm_vals object:
for (i in 1:8){
  BCs15.v1_map[,numcol_15.v1+i] <- BCs15.v1_map[,A05index+i-1]*as.numeric(norm_vals_15.v1$scaling[i])}

# Add the new column names to the BCs object:
colnames(BCs15.v1_map) <- c(oldnames15.v1,newnamesfrac15.v1)
```

<font color="green">**The following table displays a preview of the normalized count values by unique barcode:**</font>
```{r echo=FALSE}
BCs_norm_15.v1 <- BCs15.v1_map[,c(1,19:26)]

# Display dataframe with kable formatting
BCs_norm_head_15.v1 <- head(BCs_norm_15.v1)

knitr::kable(BCs_norm_head_15.v1,
  col.names = c('BC', 'A05n', 'A06n', 'A07n', 'A08n', 'A09n', 'A10n', 'A11n', 'A12n'),
  align = "lcccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

## Log2-Fold Change

Determine the log2-fold changes for each barcode relative to the M9-Supplementation condition (Lib15.v1=A05).
```{r}
#Library 15
BCs15.v1_map <- BCs15.v1_map %>%
  mutate(A06A05fc=log2(A06n+pseudocount)-log2(A05n+pseudocount),
         A07A05fc=log2(A07n+pseudocount)-log2(A05n+pseudocount),
         A08A05fc=log2(A08n+pseudocount)-log2(A05n+pseudocount),
         A09A05fc=log2(A09n+pseudocount)-log2(A05n+pseudocount),
         A10A05fc=log2(A10n+pseudocount)-log2(A05n+pseudocount),
         A11A05fc=log2(A11n+pseudocount)-log2(A05n+pseudocount),
         A12A05fc=log2(A12n+pseudocount)-log2(A05n+pseudocount))
```

**Lib15.v1 Log2-FC:** <font color="green">The following table displays a preview of the log2-fold change values between sampling treatments</font>
```{r echo=FALSE}
BCs_norm_log_15.v1 <- BCs15.v1_map[,c(1,27:33)]

# Display dataframe with kable formatting
BCs_norm_log_head_15.v1 <- head(BCs_norm_log_15.v1)

knitr::kable(BCs_norm_log_head_15.v1,
  col.names = c('BC', 'A06-A05fc', 'A07-A05fc', 'A08-A05fc', 'A09-A05fc', 'A10-A05fc', 'A11-A05fc', 'A12-A05fc'),
  align = "lcccccccc",
  format.args = list(big.mark = ","),
  digits = 0)
```

## Min BC Pruning

First, update the `mutIDinfo` object to group BCs by mutID while also adding a new column called "numprunedBCs" that counts the number of unique BCs associated with each unique mutID that passed the filtering threshold in the `BCs_map` object.
```{r}
# Make a copy of the "mutIDinfo15" dataframe
mutIDinfo15.v1 <- BCs_mutID_15

# Filter copy to retain only one value for each unique "mutID"
mutIDinfo15.v1 <- mutIDinfo15.v1[!duplicated(mutIDinfo15.v1$mutID), ]

mutIDinfo15.v1 <- BCs15.v1_map %>%
  group_by(mutID) %>%
  summarise(numprunedBCs = n()) %>%
  right_join(mutIDinfo15.v1, by="mutID")
```

Replace all NAs with 0 in the "numprunedBCs" column
```{r}
#replace NAs with 0
mutIDinfo15.v1$numprunedBCs[is.na(mutIDinfo15.v1$numprunedBCs)] <- 0
```

Count the number of unique mutIDs prior to filtering by minimum numprunedBCs (>0 BC):
```{r class.output="goodCode"}
format(length(unique(mutIDinfo15.v1$mutID)), big.mark = ",")
```

Filter the `mutIDinfo` objects by minimum number of numprunedBCs (>0 BC):
```{r}
#variants must have at least 1 BC after pruning:
mutIDinfo15.v1 <- mutIDinfo15.v1 %>%
  filter(numprunedBCs>0)
```

Count the number of unique variants remaining after filtering:
```{r class.output="goodCode"}
format(length(unique(mutIDinfo15.v1$mutID)), big.mark = ",")
```

## Median Fitness

Now, generate a median fitness value for each unique "mutID" based on its' associated BCs. **IMPORTANT: We have to remove "NA" values from each BC associated with each "mutID" when calculating median fitness values. If not, the code will discard the "mutID" if any of its associated BCs have an "NA" value.**
```{r}
# For each ID at each TMP treatment, calculate median fitness based on BCs associated with each ID:

# Lib15.v1
mutIDinfo15.v1 <- BCs15.v1_map %>%
  group_by(mutID) %>%
  summarise(fitA06A05=median(A06A05fc,na.rm=T), fitA07A05=median(A07A05fc,na.rm=T),
            fitA08A05=median(A08A05fc,na.rm=T), fitA09A05=median(A09A05fc,na.rm=T),
            fitA10A05=median(A10A05fc,na.rm=T), fitA11A05=median(A11A05fc,na.rm=T),
            fitA12A05=median(A12A05fc,na.rm=T)) %>%
  right_join(mutIDinfo15.v1, by="mutID")
```

## Merged Libraries

Subset library `mutIDinfo` objects to retain only the fitness scores for all TMP treatments at Time Point 1.  Then, merge libraries based on shared "mutID".

**Subset Libraries:** Create a new dataframe that subsets all BCs and their fitness scores for all TMP treatments:
```{r}
# Select descriptive data columns and fitness scores at time point 1 from mutIDinfo

# Lib15.v1
BCmutfitness_15.v1 <- mutIDinfo15.v1[, c(1,2:8,9,11,14,12,15,16)]

# Lib15.v2
BCmutfitness_15.v2 <- mutIDinfo15[, c(1,3:9,31:36)]
```

### All Merged by mutID

**All Shared:** Merge the fitness scores derived from each library into a single dataframe based on shared mutID between the two dataset:
```{r class.output="goodCode"}
# Merge by shared "mutID"
BCmut_15.v1.v2.mutID.fitness.shared <- merge(BCmutfitness_15.v1, BCmutfitness_15.v2, by = "mutID", all = FALSE)

# Count the number of mutID's shared between both libraries
BCmut_15.v1.v2.mutID.fitness.shared.count <- length(unique(BCmut_15.v1.v2.mutID.fitness.shared$mutID))
format(BCmut_15.v1.v2.mutID.fitness.shared.count, big.mark = ",")
```

**All Unique:** Subset the fitness scores for all unique mutIDs derived from one library or the other into a single dataframe:
```{r class.output="goodCode"}
# Create a new dataset retaining unique mutIDs from both datasets
BCmut_15.v1.v2.mutID.fitness.unique <- bind_rows(
  anti_join(BCmutfitness_15.v1, BCmutfitness_15.v2, by = "mutID"),
  anti_join(BCmutfitness_15.v2, BCmutfitness_15.v1, by = "mutID"))

# Count the number of mutIDs unique to one library or the other
BCmut_15.v1.v2.mutID.fitness.unique.count <- length(unique(BCmut_15.v1.v2.mutID.fitness.unique$mutID))
format(BCmut_15.v1.v2.mutID.fitness.unique.count, big.mark = ",")
```

### Merged Perfects

**Perfects Shared:** Subset the fitness scores for perfects shared between both libraries into a single dataframe:
```{r class.output="goodCode"}
# Retain only the rows with a specific value in the "specific_column" column
BCmut_15.v1.v2.mutID.fitness.shared.perfects <- BCmut_15.v1.v2.mutID.fitness.shared %>%
  filter(mutations.x == 0)

# Count the number of perfects (mutations == 0) shared between both libraries
BCmut_15.v1.v2.mutID.fitness.shared.perfects.count <- length(unique(BCmut_15.v1.v2.mutID.fitness.shared.perfects$mutID))

format(BCmut_15.v1.v2.mutID.fitness.shared.perfects.count, big.mark = ",")
```

**Perfects Unique:** Subset the fitness scores for perfects unique to one library or the other into a single dataframe:
```{r class.output="goodCode"}
# Retain only the rows with a specific value in the "specific_column" column
BCmut_15.v1.v2.mutID.fitness.unique.perfects <- BCmut_15.v1.v2.mutID.fitness.unique %>%
  filter(mutations == 0)

# Count the number of perfects (mutations == 0) unique to one library or the other
BCmut_15.v1.v2.mutID.fitness.unique.perfects.count <- length(unique(BCmut_15.v1.v2.mutID.fitness.unique.perfects$mutID))

format(BCmut_15.v1.v2.mutID.fitness.unique.perfects.count, big.mark = ",")
```

**Summarize the number of perfects shared or unique between both libraries.**
```{r class.output="goodCode"}
BCmut_15.v1.v2.perfect.mutID.fitness.all.count <- sum(BCmut_15.v1.v2.mutID.fitness.shared.perfects.count +
                                                     BCmut_15.v1.v2.mutID.fitness.unique.perfects.count)
format(BCmut_15.v1.v2.perfect.mutID.fitness.all.count, big.mark = ",")
```

### Merged Mutants

**Mutants Shared:** Subset the fitness scores for mutants shared between both libraries into a single dataframe:
```{r class.output="goodCode"}
# Retain only the rows with a specific value in the "specific_column" column
BCmut_15.v1.v2.mutID.fitness.shared.mutants <- BCmut_15.v1.v2.mutID.fitness.shared %>%
  filter(mutations.x != 0)

# Count the number of perfects (mutations != 0) shared between both libraries
BCmut_15.v1.v2.mutID.fitness.shared.mutants.count <- length(unique(BCmut_15.v1.v2.mutID.fitness.shared.mutants$mutID))

format(BCmut_15.v1.v2.mutID.fitness.shared.mutants.count, big.mark = ",")
```

**Mutants Unique:** Subset the fitness scores for mutants unique to one library or the other into a single dataframe:
```{r class.output="goodCode"}
# Retain only the rows with a specific value in the "specific_column" column
BCmut_15.v1.v2.mutID.fitness.unique.mutants <- BCmut_15.v1.v2.mutID.fitness.unique %>%
  filter(mutations != 0)

# Count the number of mutant (mutations != 0) unique to one library or the other
BCmut_15.v1.v2.mutID.fitness.unique.mutants.count <- length(unique(BCmut_15.v1.v2.mutID.fitness.unique.mutants$mutID))

format(BCmut_15.v1.v2.mutID.fitness.unique.mutants.count, big.mark = ",")
```

**Summarize the number of mutants shared or unique between both libraries.**
```{r class.output="goodCode"}
BCmut_15.v1.v2.mutant.mutID.fitness.all.count <- sum(BCmut_15.v1.v2.mutID.fitness.shared.mutants.count +
                                                    BCmut_15.v1.v2.mutID.fitness.unique.mutants.count)
format(BCmut_15.v1.v2.mutant.mutID.fitness.all.count, big.mark = ",")
```

# Perfects Only
<font color="blue">**This section is based on the R file: "R_perfects_only.R".**</font> It describes how to select only for perfects (perfect match to designed homolog sequence).

## Select Perfects

Begin by selecting perfects BCs from "BCs_map" object where mutations = 0:
```{r}
# Lib15
BCperfect15 <- BCs15_map %>%
  filter(mutations==0) %>%
  dplyr::rename(ID=IDalign)

# Lib16
BCperfect16 <- BCs16_map %>%
  filter(mutations==0) %>%
  dplyr::rename(ID=IDalign)
```

Perform a quick check to verify no IDs are missing:
```{r class.output="goodCode"}
# Lib15
#check how many are missing ID
nrow(BCperfect15 %>% filter(ID == ""))

# Lib16
#check how many are missing ID
nrow(BCperfect16 %>% filter(ID == ""))
```

## Perfects Stats

### Synonymous Counts

Create a function to check if each unique perfect sequence represents a **"true perfect"** based on the designed homolog sequence or a **"synonymous mutation"** that is functionally redundant.
```{r}
#check if this is a synonymous mutant
cigar_syn_mutant_check <- function(cigarin){
  flag_out <- "Perfect"
  if (length(grep("X",cigarin)) != 0) {
    flag_out <- "SynMutant"
  }
  return(flag_out)
}
```

Apply the "perfect check function" to the "BCperfect" dataset and add a column to indicate each BCs status.
```{r}
# Lib15
#check if this BC is a synonymous mutant
BCperfect15 <- BCperfect15 %>%
  rowwise() %>%
  mutate(synflag=cigar_syn_mutant_check(cigar))

# Lib16
#check if this BC is a synonymous mutant
BCperfect16 <- BCperfect16 %>%
  rowwise() %>%
  mutate(synflag=cigar_syn_mutant_check(cigar))
```

Count the number of "Perfects" from the dataset:
```{r class.output="goodCode"}
# Lib15
# Number of perfects
perfects.count15 <- length(which(BCperfect15$synflag=="Perfect"))

format(perfects.count15, big.mark = ",")

# Lib16
# Number of perfects
perfects.count16 <- length(which(BCperfect16$synflag=="Perfect"))

format(perfects.count16, big.mark = ",")
```

Count the number of "SynMutants" from the dataset:
```{r class.output="goodCode"}
# Lib15
# Number of synonymous mutants
synmut.count15 <- length(which(BCperfect15$synflag=="SynMutant"))

format(synmut.count15, big.mark = ",")

# Lib16
# Number of synonymous mutants
synmut.count16 <- length(which(BCperfect16$synflag=="SynMutant"))

format(synmut.count16, big.mark = ",")
```

### Perfects mutID

Create a `perfects` object that further filters the `mutIDinfo` object to retain mutIDs only if they have 0 mutations:
```{r}
# Lib15
perfects15 <- mutIDinfo15 %>%
  filter(mutations==0) %>%
  dplyr::rename(ID = IDalign)

# Lib16
perfects16 <- mutIDinfo16 %>%
  filter(mutations==0) %>%
  dplyr::rename(ID = IDalign)
```

### Perfects Filtered by BCs

Select only those perfects with a minimum number of barcode:
```{r}
# Lib15

# Select only those with a minimum of 2 BCs
perfects15_2BCs <- perfects15 %>%
  filter(numprunedBCs > 1)

# Select only those with a minimum of 5 BCs
perfects15_5BCs <- perfects15 %>%
  filter(numprunedBCs > 4)

# Select only those with a minimum of 10 BCs
perfects15_10BCs <- perfects15 %>%
  filter(numprunedBCs > 9)

# Select only those with a minimum of 100 BCs
perfects15_100BCs <- perfects15 %>%
  filter(numprunedBCs > 99)

# Select only those with a minimum of 200 BCs
perfects15_200BCs <- perfects15 %>%
  filter(numprunedBCs > 199)

# Lib16

# Select only those with a minimum of 2 BCs
perfects16_2BCs <- perfects16 %>%
  filter(numprunedBCs > 1)

### Select only those with a minimum of 5 BCs
perfects16_5BCs <- perfects16 %>%
  filter(numprunedBCs > 4)

### Select only those with a minimum of 10 BCs
perfects16_10BCs <- perfects16 %>%
  filter(numprunedBCs > 9)

# Select only those with a minimum of 100 BCs
perfects16_100BCs <- perfects16 %>%
  filter(numprunedBCs > 99)

# Select only those with a minimum of 200 BCs
perfects16_200BCs <- perfects16 %>%
  filter(numprunedBCs > 199)
```

### Perfects Counts by BCs

**Count the number of perfects before and after filtering by minimum BC counts (2BCs and 5BCs):**
```{r class.output="goodCode"}
# Lib15

# Count the number of unique perfects prior to filtering by BCs in Lib15
perfects15.count <- length(unique(perfects15$ID))
format(perfects15.count, big.mark = ",")

# Count the number of unique perfects at 2BCs minimum retained in Lib15
perfects15_2BCs.count <- length(unique(perfects15_2BCs$ID))
format(perfects15_2BCs.count, big.mark = ",")

# Count the number of unique perfects at 5BCs minimum retained in Lib15
perfects15_5BCs.count <- length(unique(perfects15_5BCs$ID))
format(perfects15_5BCs.count, big.mark = ",")

# Count the number of unique perfects at 10BCs minimum retained in Lib15
perfects15_10BCs.count <- length(unique(perfects15_10BCs$ID))
format(perfects15_10BCs.count, big.mark = ",")

# Count the number of unique perfects at 100BCs minimum retained in Lib15
perfects15_100BCs.count <- length(unique(perfects15_100BCs$ID))
format(perfects15_100BCs.count, big.mark = ",")

# Count the number of unique perfects at 200BCs minimum retained in Lib15
perfects15_200BCs.count <- length(unique(perfects15_200BCs$ID))
format(perfects15_200BCs.count, big.mark = ",")
```

```{r class.output="goodCode"}
# Lib16

# Count the number of unique perfects prior to filtering by BCs in Lib16
perfects16.count <- length(unique(perfects16$ID))
format(perfects16.count, big.mark = ",")

# Count the number of unique perfects at 2BCs minimum retained in Lib16
perfects16_2BCs.count <- length(unique(perfects16_2BCs$ID))
format(perfects16_2BCs.count, big.mark = ",")

# Count the number of unique perfects at 5BCs minimum retained in Lib16
perfects16_5BCs.count <- length(unique(perfects16_5BCs$ID))
format(perfects16_5BCs.count, big.mark = ",")

# Count the number of unique perfects at 10BCs minimum retained in Lib16
perfects16_10BCs.count <- length(unique(perfects16_10BCs$ID))
format(perfects16_10BCs.count, big.mark = ",")

# Count the number of unique perfects at 100BCs minimum retained in Lib15
perfects16_100BCs.count <- length(unique(perfects16_100BCs$ID))
format(perfects16_100BCs.count, big.mark = ",")

# Count the number of unique perfects at 200BCs minimum retained in Lib15
perfects16_200BCs.count <- length(unique(perfects16_200BCs$ID))
format(perfects16_200BCs.count, big.mark = ",")
```

### Merged Perfects 

Merge perfects filtered at 1BC derived from each library into a single dataframe based on shared ID between the two dataset
```{r class.output="goodCode"}
# Merge by shared "mutID" (1BC)
perfects_15_16_shared <- merge(perfects15, perfects16, by = "mutID", all = FALSE)

# Merge by shared "mutID" (2BC)
perfects_15_16_shared_2BCs <- merge(perfects15_2BCs, perfects16_2BCs, by = "mutID", all = FALSE)

# Merge by shared "mutID" (5BC)
perfects_15_16_shared_5BCs <- merge(perfects15_5BCs, perfects16_5BCs, by = "mutID", all = FALSE)

# Merge by shared "mutID" (10BC)
perfects_15_16_shared_10BCs <- merge(perfects15_10BCs, perfects16_10BCs, by = "mutID", all = FALSE)

# Merge by shared "mutID" (100BC)
perfects_15_16_shared_100BCs <- merge(perfects15_100BCs, perfects16_100BCs, by = "mutID", all = FALSE)

# Merge by shared "mutID" (200BC)
perfects_15_16_shared_200BCs <- merge(perfects15_200BCs, perfects16_200BCs, by = "mutID", all = FALSE)

```

**Count the number of perfects shared between both libraries.**
```{r class.output="goodCode"}
# Count the number of unique perfects shared between libraries (1BC)
perfects_15_16_shared.count <- length(unique(perfects_15_16_shared$mutID))
format(perfects_15_16_shared.count, big.mark = ",")

# Count the number of unique perfects shared between libraries (2BC)
perfects_15_16_shared_2BCs.count <- length(unique(perfects_15_16_shared_2BCs$mutID))
format(perfects_15_16_shared_2BCs.count, big.mark = ",")

# Count the number of unique perfects shared between libraries (5BC)
perfects_15_16_shared_5BCs.count <- length(unique(perfects_15_16_shared_5BCs$mutID))
format(perfects_15_16_shared_5BCs.count, big.mark = ",")

# Count the number of unique perfects shared between libraries (10BC)
perfects_15_16_shared_10BCs.count <- length(unique(perfects_15_16_shared_10BCs$mutID))
format(perfects_15_16_shared_10BCs.count, big.mark = ",")

# Count the number of unique perfects shared between libraries (100BC)
perfects_15_16_shared_100BCs.count <- length(unique(perfects_15_16_shared_100BCs$mutID))
format(perfects_15_16_shared_100BCs.count, big.mark = ",")

# Count the number of unique perfects shared between libraries (200BC)
perfects_15_16_shared_200BCs.count <- length(unique(perfects_15_16_shared_200BCs$mutID))
format(perfects_15_16_shared_200BCs.count, big.mark = ",")
```

**Count the number of perfects unique to one library or the other.**
```{r class.output="goodCode"}
# Create a new dataset retaining unique values from both datasets (1BC)
perfects_15_16_unique <- bind_rows(
  anti_join(perfects15, perfects16, by = "mutID"),
  anti_join(perfects16, perfects15, by = "mutID"))

# Count the number of perfects unique to one library or the other
perfects_15_16_unique.count <- length(unique(perfects_15_16_unique$mutID))
format(perfects_15_16_unique.count, big.mark = ",")

# Create a new dataset retaining unique values from both datasets (2BC)
perfects_15_16_unique_2BCs <- bind_rows(
  anti_join(perfects15_2BCs, perfects16_2BCs, by = "mutID"),
  anti_join(perfects16_2BCs, perfects15_2BCs, by = "mutID"))

# Count the number of perfects unique to one library or the other
perfects_15_16_unique_2BCs.count <- length(unique(perfects_15_16_unique_2BCs$mutID))
format(perfects_15_16_unique_2BCs.count, big.mark = ",")

# Create a new dataset retaining unique values from both datasets (5BC)
perfects_15_16_unique_5BCs <- bind_rows(
  anti_join(perfects15_5BCs, perfects16_5BCs, by = "mutID"),
  anti_join(perfects16_5BCs, perfects15_5BCs, by = "mutID"))

# Count the number of perfects unique to one library or the other
perfects_15_16_unique_5BCs.count <- length(unique(perfects_15_16_unique_5BCs$mutID))
format(perfects_15_16_unique_5BCs.count, big.mark = ",")

# Create a new dataset retaining unique values from both datasets (10BC)
perfects_15_16_unique_10BCs <- bind_rows(
  anti_join(perfects15_10BCs, perfects16_10BCs, by = "mutID"),
  anti_join(perfects16_10BCs, perfects15_10BCs, by = "mutID"))

# Count the number of perfects unique to one library or the other
perfects_15_16_unique_10BCs.count <- length(unique(perfects_15_16_unique_10BCs$mutID))
format(perfects_15_16_unique_10BCs.count, big.mark = ",")

# Create a new dataset retaining unique values from both datasets (100BC)
perfects_15_16_unique_100BCs <- bind_rows(
  anti_join(perfects15_100BCs, perfects16_100BCs, by = "mutID"),
  anti_join(perfects16_100BCs, perfects15_100BCs, by = "mutID"))

# Count the number of perfects unique to one library or the other
perfects_15_16_unique_100BCs.count <- length(unique(perfects_15_16_unique_100BCs$mutID))
format(perfects_15_16_unique_100BCs.count, big.mark = ",")

# Create a new dataset retaining unique values from both datasets (200BC)
perfects_15_16_unique_200BCs <- bind_rows(
  anti_join(perfects15_200BCs, perfects16_200BCs, by = "mutID"),
  anti_join(perfects16_200BCs, perfects15_200BCs, by = "mutID"))

# Count the number of perfects unique to one library or the other
perfects_15_16_unique_200BCs.count <- length(unique(perfects_15_16_unique_200BCs$mutID))
format(perfects_15_16_unique_200BCs.count, big.mark = ",")
```

**Summarize the number of perfects shared or unique between both libraries based on minimum BC count.**
```{r class.output="goodCode"}
# Count number of shared and unique perfects (1BC)
perfects_15_16_all.count <- sum(perfects_15_16_shared.count + perfects_15_16_unique.count)
format(perfects_15_16_all.count, big.mark = ",")

# Count number of shared and unique perfects (2BC)
perfects_15_16_all_2BCs.count <- sum(perfects_15_16_shared_2BCs.count + perfects_15_16_unique_2BCs.count)
format(perfects_15_16_all_2BCs.count, big.mark = ",")

# Count number of shared and unique perfects (5BC)
perfects_15_16_all_5BCs.count <- sum(perfects_15_16_shared_5BCs.count + perfects_15_16_unique_5BCs.count)
format(perfects_15_16_all_5BCs.count, big.mark = ",")

# Count number of shared and unique perfects (10BC)
perfects_15_16_all_10BCs.count <- sum(perfects_15_16_shared_10BCs.count + perfects_15_16_unique_10BCs.count)
format(perfects_15_16_all_10BCs.count, big.mark = ",")

# Count number of shared and unique perfects (100BC)
perfects_15_16_all_100BCs.count <- sum(perfects_15_16_shared_100BCs.count + perfects_15_16_unique_100BCs.count)
format(perfects_15_16_all_100BCs.count, big.mark = ",")

# Count number of shared and unique perfects (200BC)
perfects_15_16_all_200BCs.count <- sum(perfects_15_16_shared_200BCs.count + perfects_15_16_unique_200BCs.count)
format(perfects_15_16_all_200BCs.count, big.mark = ",")
```

Save an output of the data for generating phylogenetic trees associated with median fitness data:
```{r}
# Lib15

# Perfects-1BC
write.table(perfects15$mutID, file = "OUTPUT/tree_build/Lib15.perfects.1BCs.final.ID.list.csv", 
            sep = ",", row.names = F,quote=F,col.names = F)

# Perfects-5BCs
write.table(perfects15_5BCs$mutID, file = "OUTPUT/tree_build/Lib15.perfects.5BCs.final.ID.list.csv", 
            sep = ",", row.names = F,quote=F,col.names = F)

# Lib16

# Perfects-1BC
write.table(perfects16$mutID, file = "OUTPUT/tree_build/Lib16.perfects.1BCs.final.ID.list.csv", 
            sep = ",", row.names = F,quote=F,col.names = F)

# Perfects-5BCs
write.table(perfects16_5BCs$mutID, file = "OUTPUT/tree_build/Lib16.perfects.5BCs.final.ID.list.csv", 
            sep = ",", row.names = F,quote=F,col.names = F)

# Shared mutIDs

# Perfects-Shared-1BC
write.table(perfects_15_16_shared$mutID, file = "OUTPUT/tree_build/Lib15.16.perfects.1BCs.final.ID.list.csv", 
            sep = ",", row.names = F,quote=F,col.names = F)

# Perfects-Shared-5BC
write.table(perfects_15_16_shared_5BCs$mutID, file = "OUTPUT/tree_build/Lib15.16.perfects.5BCs.final.ID.list.csv", 
            sep = ",", row.names = F,quote=F,col.names = F)
```

## Correlations

### Lib15.v1 vs. Lib15.v2

The first set of correlations are between mutIDs shared between Lib15.v1 (Carmen Resnick) and Lib15.v2 (this study) to show how consistent is the fitness response between designed homologs when experiments are repeated.

#### BC Correlations

Subset BCs from both Lib15 versions for merging
```{r}
# Lib15.v1
BCs15.v1_map.sub <- BCs15.v1_map[, c(1,4,6,27:33)]

# Lib15.v2
BCs15_map.sub <- BCs15_map[, c(1,4,6,72:78)]
```

Retain only perfects (mutations == 0)
```{r}
# Lib15.v1
BCs15.v1_map.sub.perfects <- BCs15.v1_map.sub %>%
  filter(mutations==0)

# Lib15.v2
BCs15_map.sub.perfects <- BCs15_map.sub %>%
  filter(mutations==0)
```

Merge BC datasets
```{r}
BCs15_map.perfects.shared <- merge(BCs15.v1_map.sub.perfects, BCs15_map.sub.perfects, by = "BC", all = FALSE)
```

Subset for plotting
```{r}
# Complementation - 0-TMP
L15.v1.v2.BC.Counts.0.TMP <- BCs15_map.perfects.shared[, c("BC", "numBCs.x", "numBCs.y", "A06A05fc", "D05D03fc")] %>%
  na.omit(L15.v1.v2.BC.Counts.0.TMP)

# 0.058-TMP
L15.v1.v2.BC.Counts.0.058.TMP <- BCs15_map.perfects.shared[, c("BC", "numBCs.x", "numBCs.y", "A07A05fc", "D06D03fc")] %>%
  na.omit(L15.v1.v2.BC.Counts.0.058.TMP)

# 0.5-TMP
L15.v1.v2.BC.Counts.0.5.TMP <- BCs15_map.perfects.shared[, c("BC", "numBCs.x", "numBCs.y", "A08A05fc", "D07D03fc")] %>%
  na.omit(L15.v1.v2.BC.Counts.0.5.TMP)

# 1.0-TMP
L15.v1.v2.BC.Counts.1.0.TMP <- BCs15_map.perfects.shared[, c("BC", "numBCs.x", "numBCs.y", "A09A05fc", "D08D03fc")] %>%
  na.omit(L15.v1.v2.BC.Counts.1.0.TMP)

# 10-TMP
L15.v1.v2.BC.Counts.10.TMP <- BCs15_map.perfects.shared[, c("BC", "numBCs.x", "numBCs.y", "A10A05fc", "D09D03fc")] %>%
  na.omit(L15.v1.v2.BC.Counts.10.TMP)

# 50-TMP
L15.v1.v2.BC.Counts.50.TMP <- BCs15_map.perfects.shared[, c("BC", "numBCs.x", "numBCs.y", "A11A05fc", "D10D03fc")] %>%
  na.omit(L15.v1.v2.BC.Counts.50.TMP)

# 200-TMP
L15.v1.v2.BC.Counts.200.TMP <- BCs15_map.perfects.shared[, c("BC", "numBCs.x", "numBCs.y", "A12A05fc", "D11D03fc")] %>%
  na.omit(L15.v1.v2.BC.Counts.200.TMP)
```

Pearson Correlations
```{r}
# Pearson's Correlation: 0-TMP (Complementation)
cor_test_BC_Counts_shared_0_tmp <- cor.test(L15.v1.v2.BC.Counts.0.TMP$A06A05fc,
                                            L15.v1.v2.BC.Counts.0.TMP$D05D03fc)

# Pearson's Correlation: 0.5-TMP (MIC)
cor_test_BC_Counts_shared_0.5_tmp <- cor.test(L15.v1.v2.BC.Counts.0.5.TMP$A08A05fc,
                                              L15.v1.v2.BC.Counts.0.5.TMP$D07D03fc)

# Pearson's Correlation: 50-TMP (High TMP)
cor_test_BC_Counts_shared_50_tmp <- cor.test(L15.v1.v2.BC.Counts.50.TMP$A11A05fc,
                                             L15.v1.v2.BC.Counts.50.TMP$D10D03fc)
```

Print the Correlation Statistics
```{r class.output="goodCode"}
print(cor_test_BC_Counts_shared_0_tmp)
print(cor_test_BC_Counts_shared_0.5_tmp)
print(cor_test_BC_Counts_shared_50_tmp)
```

Plot BC fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for Complementation:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_0_tmp.BC <- cor_test_BC_Counts_shared_0_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_0_tmp.BC <- format(cor_test_BC_Counts_shared_0_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.0.tmp.BC <- nrow(L15.v1.v2.BC.Counts.0.TMP)

# Plot based on shared mutID
Lib15_BC_v1_v2_0_TMP <- ggplot(L15.v1.v2.BC.Counts.0.TMP, 
                   aes(x=A06A05fc, y=D05D03fc, color=log(numBCs.x))) +
  labs(x = "Lib15.v1 BC Fitness (LogFC)", y ="Lib15.v2 BC Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects BC Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n0 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.BC.Counts.0.TMP$A06A05fc),
           y = min(L15.v1.v2.BC.Counts.0.TMP$D05D03fc), 
           label = paste("p-value =", p_value_scientific_shared_0_tmp.BC), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.BC.Counts.0.TMP$A06A05fc),
           y = min(L15.v1.v2.BC.Counts.0.TMP$D05D03fc),
            label = paste("Correlation =", round(cor_value_shared_0_tmp.BC, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.BC.Counts.0.TMP$A06A05fc),
           y = max(L15.v1.v2.BC.Counts.0.TMP$D05D03fc),
           label = paste("Shared Perfects =", num_rows.counts.0.tmp.BC), hjust = 0, vjust = 1.5)

Lib15_BC_v1_v2_0_TMP_p01 <- ggMarginal(Lib15_BC_v1_v2_0_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_BC_v1_v2_0_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.BC.v1.v2.correlation.perfects.fitness.0.tmp.png",
       plot=Lib15_BC_v1_v2_0_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot BC fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for 0.5-TMP (MIC):
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_0.5_tmp.BC <- cor_test_BC_Counts_shared_0.5_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_0.5_tmp.BC <- format(cor_test_BC_Counts_shared_0.5_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.0.5.tmp.BC <- nrow(L15.v1.v2.BC.Counts.0.5.TMP)

# Plot based on shared mutID
Lib15_BC_v1_v2_0.5_TMP <- ggplot(L15.v1.v2.BC.Counts.0.5.TMP, 
                   aes(x=A08A05fc, y=D07D03fc, color=log(numBCs.x))) +
  labs(x = "Lib15.v1 BC Fitness (LogFC)", y ="Lib15.v2 BC Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects BC Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n0.5 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.BC.Counts.0.5.TMP$A08A05fc),
           y = min(L15.v1.v2.BC.Counts.0.5.TMP$D07D03fc), 
           label = paste("p-value =", p_value_scientific_shared_0.5_tmp.BC), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.BC.Counts.0.5.TMP$A08A05fc),
           y = min(L15.v1.v2.BC.Counts.0.5.TMP$D07D03fc),
            label = paste("Correlation =", round(cor_value_shared_0.5_tmp.BC, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.BC.Counts.0.5.TMP$A08A05fc),
           y = max(L15.v1.v2.BC.Counts.0.5.TMP$D07D03fc),
           label = paste("Shared Perfects =", num_rows.counts.0.5.tmp.BC), hjust = 0, vjust = 1.5)

Lib15_BC_v1_v2_0.5_TMP_p01 <- ggMarginal(Lib15_BC_v1_v2_0.5_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_BC_v1_v2_0.5_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.BC.v1.v2.correlation.perfects.fitness.0.5.tmp.png",
       plot=Lib15_BC_v1_v2_0.5_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot BC fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for 50-TMP (High TMP):
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_50_tmp.BC <- cor_test_BC_Counts_shared_50_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_50_tmp.BC <- format(cor_test_BC_Counts_shared_0.5_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.50.tmp.BC <- nrow(L15.v1.v2.BC.Counts.50.TMP)

# Plot based on shared mutID
Lib15_BC_v1_v2_50_TMP <- ggplot(L15.v1.v2.BC.Counts.50.TMP, 
                   aes(x=A11A05fc, y=D10D03fc, color=log(numBCs.x))) +
  labs(x = "Lib15.v1 BC Fitness (LogFC)", y ="Lib15.v2 BC Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects BC Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n50 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.BC.Counts.50.TMP$A11A05fc),
           y = min(L15.v1.v2.BC.Counts.50.TMP$D10D03fc), 
           label = paste("p-value =", p_value_scientific_shared_50_tmp.BC), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.BC.Counts.50.TMP$A11A05fc),
           y = min(L15.v1.v2.BC.Counts.50.TMP$D10D03fc),
            label = paste("Correlation =", round(cor_value_shared_50_tmp.BC, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.BC.Counts.50.TMP$A11A05fc),
           y = max(L15.v1.v2.BC.Counts.50.TMP$D10D03fc),
           label = paste("Shared Perfects =", num_rows.counts.50.tmp.BC), hjust = 0, vjust = 1.5)

Lib15_BC_v1_v2_50_TMP_p01 <- ggMarginal(Lib15_BC_v1_v2_50_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_BC_v1_v2_50_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.BC.v1.v2.correlation.perfects.fitness.50.tmp.png",
       plot=Lib15_BC_v1_v2_50_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

#### Subset for Plotting

Because many of the shared mutIDs have "NA" values for one library or the other at certain treatment conditions, we need to subset the dataframe into smaller datasets relevant for each condition we want to plot and remove rows containing "NA" values. **All correlations are based on the "BCmut_15.v1.v2.mutID.fitness.shared.perfects" dataset.**

Subset relevant data columns and remove rows containing "NA" values:
```{r}
# Complementation - 0-TMP
L15.v1.v2.Counts.0.TMP <- BCmut_15.v1.v2.mutID.fitness.shared.perfects[, c("mutID", 
                                                                           "numprunedBCs.x", 
                                                                           "numprunedBCs.y", 
                                                                           "fitA06A05", "fitD05D03")] %>%
  na.omit(L15.v1.v2.Counts.0.TMP)

# Trimethoprim - 0.058-TMP
L15.v1.v2.Counts.0.058.TMP <- BCmut_15.v1.v2.mutID.fitness.shared.perfects[, c("mutID", 
                                                                               "numprunedBCs.x", 
                                                                               "numprunedBCs.y", 
                                                                               "fitA07A05", "fitD06D03")] %>%
  na.omit(L15.v1.v2.Counts.0.058.TMP)

# Trimethoprim - 0.5-TMP
L15.v1.v2.Counts.0.5.TMP <- BCmut_15.v1.v2.mutID.fitness.shared.perfects[, c("mutID", 
                                                                             "numprunedBCs.x", 
                                                                             "numprunedBCs.y", 
                                                                             "fitA08A05", "fitD07D03")] %>%
  na.omit(L15.v1.v2.Counts.0.5.TMP)

# Trimethoprim - 1.0-TMP
L15.v1.v2.Counts.1.0.TMP <- BCmut_15.v1.v2.mutID.fitness.shared.perfects[, c("mutID", 
                                                                             "numprunedBCs.x", 
                                                                             "numprunedBCs.y", 
                                                                             "fitA09A05", "fitD08D03")] %>%
  na.omit(L15.v1.v2.Counts.1.0.TMP)

# Trimethoprim - 10-TMP
L15.v1.v2.Counts.10.TMP <- BCmut_15.v1.v2.mutID.fitness.shared.perfects[, c("mutID", 
                                                                            "numprunedBCs.x", 
                                                                            "numprunedBCs.y", 
                                                                            "fitA10A05", "fitD09D03")] %>%
  na.omit(L15.v1.v2.Counts.10.TMP)

# Trimethoprim - 50-TMP
L15.v1.v2.Counts.50.TMP <- BCmut_15.v1.v2.mutID.fitness.shared.perfects[, c("mutID", 
                                                                            "numprunedBCs.x", 
                                                                            "numprunedBCs.y", 
                                                                            "fitA11A05", "fitD10D03")] %>%
  na.omit(L15.v1.v2.Counts.50.TMP)

# Trimethoprim - 200-TMP
L15.v1.v2.Counts.200.TMP <- BCmut_15.v1.v2.mutID.fitness.shared.perfects[, c("mutID", 
                                                                             "numprunedBCs.x", 
                                                                             "numprunedBCs.y", 
                                                                             "fitA12A05", "fitD11D03")] %>%
  na.omit(L15.v1.v2.Counts.200.TMP)
```

#### Pearson Correlations

The following section calculates Pearson's correlations based on the fitness scores of unique mutIDs shared between Lib15 and Lib16 for Time Point 1.

**Pearson's Correlation:** Determine correlations using fitness values from Libraries 15 and 16 at Time Point 1:
```{r class.output="goodCode"}
# Pearson's Correlation: 0-TMP (Complementation)
cor_test_Counts_shared_0_tmp.v1 <- cor.test(L15.v1.v2.Counts.0.TMP$fitA06A05,
                                         L15.v1.v2.Counts.0.TMP$fitD05D03)

# Pearson's Correlation: 0.058-TMP
cor_test_Counts_shared_0.058_tmp.v1 <- cor.test(L15.v1.v2.Counts.0.058.TMP$fitA07A05,
                                             L15.v1.v2.Counts.0.058.TMP$fitD06D03)

# Pearson's Correlation: 0.5-TMP
cor_test_Counts_shared_0.5_tmp.v1 <- cor.test(L15.v1.v2.Counts.0.5.TMP$fitA08A05,
                                           L15.v1.v2.Counts.0.5.TMP$fitD07D03)

# Pearson's Correlation: 1.0-TMP
cor_test_Counts_shared_1.0_tmp.v1 <- cor.test(L15.v1.v2.Counts.1.0.TMP$fitA09A05,
                                           L15.v1.v2.Counts.1.0.TMP$fitD08D03)

# Pearson's Correlation: 10-TMP
cor_test_Counts_shared_10_tmp.v1 <- cor.test(L15.v1.v2.Counts.10.TMP$fitA10A05,
                                          L15.v1.v2.Counts.10.TMP$fitD09D03)

# Pearson's Correlation: 50-TMP
cor_test_Counts_shared_50_tmp.v1 <- cor.test(L15.v1.v2.Counts.50.TMP$fitA11A05,
                                          L15.v1.v2.Counts.50.TMP$fitD10D03)

# Pearson's Correlation: 200-TMP
cor_test_Counts_shared_200_tmp.v1 <- cor.test(L15.v1.v2.Counts.200.TMP$fitA12A05,
                                           L15.v1.v2.Counts.200.TMP$fitD11D03)
```

```{r class.output="goodCode"}
# Print the full statistical output:
print(cor_test_Counts_shared_0_tmp.v1)
print(cor_test_Counts_shared_0.058_tmp.v1)
print(cor_test_Counts_shared_0.5_tmp.v1)
print(cor_test_Counts_shared_1.0_tmp.v1)
print(cor_test_Counts_shared_10_tmp.v1)
print(cor_test_Counts_shared_50_tmp.v1)
print(cor_test_Counts_shared_200_tmp.v1)
```

#### Correlation Plots

Plot median fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for Complementation:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_0_tmp.v1 <- cor_test_Counts_shared_0_tmp.v1$estimate

# Format p-value in scientific notation
p_value_scientific_shared_0_tmp.v1 <- format(cor_test_Counts_shared_0_tmp.v1$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.0.tmp.v1 <- nrow(L15.v1.v2.Counts.0.TMP)

# Plot based on shared mutID
Lib15_v1_v2_0_TMP <- ggplot(L15.v1.v2.Counts.0.TMP, 
                   aes(x=fitA06A05, y=fitD05D03, color=log(numprunedBCs.x))) +
  labs(x = "Lib15.v1 Median Fitness (LogFC)", y ="Lib15.v2 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n0 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.Counts.0.TMP$fitA06A05),
           y = min(L15.v1.v2.Counts.0.TMP$fitD05D03), 
           label = paste("p-value =", p_value_scientific_shared_0_tmp.v1), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.Counts.0.TMP$fitA06A05),
           y = min(L15.v1.v2.Counts.0.TMP$fitD05D03),
            label = paste("Correlation =", round(cor_value_shared_0_tmp.v1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.Counts.0.TMP$fitA06A05),
           y = max(L15.v1.v2.Counts.0.TMP$fitD05D03),
           label = paste("Shared Perfects =", num_rows.counts.0.tmp.v1), hjust = 0, vjust = 1.5)

Lib15_v1_v2_0_TMP_p01 <- ggMarginal(Lib15_v1_v2_0_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_v1_v2_0_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.v1.v2.correlation.perfects.median.1BC.fitness.complementation.0.tmp.png",
       plot=Lib15_v1_v2_0_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot median fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for 0.058-TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_0.058_tmp.v1 <- cor_test_Counts_shared_0.058_tmp.v1$estimate

# Format p-value in scientific notation
p_value_scientific_shared_0.058_tmp.v1 <- format(cor_test_Counts_shared_0.058_tmp.v1$p.value, 
                                                 scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.0.058.tmp.v1 <- nrow(L15.v1.v2.Counts.0.058.TMP)

# Plot based on shared mutID
Lib15_v1_v2_0.058_TMP <- ggplot(L15.v1.v2.Counts.0.058.TMP, 
                   aes(x=fitA07A05, y=fitD06D03, color=log(numprunedBCs.x))) +
  labs(x = "Lib15.v1 Median Fitness (LogFC)", y ="Lib15.v2 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n0.058 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.Counts.0.058.TMP$fitA07A05),
           y = min(L15.v1.v2.Counts.0.058.TMP$fitD06D03), 
           label = paste("p-value =", p_value_scientific_shared_0.058_tmp.v1), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.Counts.0.058.TMP$fitA07A05),
           y = min(L15.v1.v2.Counts.0.058.TMP$fitD06D03),
            label = paste("Correlation =", round(cor_value_shared_0.058_tmp.v1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.Counts.0.058.TMP$fitA07A05),
           y = max(L15.v1.v2.Counts.0.058.TMP$fitD06D03),
           label = paste("Shared Perfects =", num_rows.counts.0.058.tmp.v1), hjust = 0, vjust = 1.5)

Lib15_v1_v2_0.058_TMP_p01 <- ggMarginal(Lib15_v1_v2_0.058_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_v1_v2_0.058_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.v1.v2.correlation.perfects.median.1BC.fitness.0.058.tmp.png",
       plot=Lib15_v1_v2_0.058_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot median fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for 0.5-TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_0.5_tmp.v1 <- cor_test_Counts_shared_0.5_tmp.v1$estimate

# Format p-value in scientific notation
p_value_scientific_shared_0.5_tmp.v1 <- format(cor_test_Counts_shared_0.5_tmp.v1$p.value, 
                                                 scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.0.5.tmp.v1 <- nrow(L15.v1.v2.Counts.0.5.TMP)

# Plot based on shared mutID
Lib15_v1_v2_0.5_TMP <- ggplot(L15.v1.v2.Counts.0.5.TMP, 
                   aes(x=fitA08A05, y=fitD07D03, color=log(numprunedBCs.x))) +
  labs(x = "Lib15.v1 Median Fitness (LogFC)", y ="Lib15.v2 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n0.5 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.Counts.0.5.TMP$fitA08A05),
           y = min(L15.v1.v2.Counts.0.5.TMP$fitD07D03), 
           label = paste("p-value =", p_value_scientific_shared_0.5_tmp.v1), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.Counts.0.5.TMP$fitA08A05),
           y = min(L15.v1.v2.Counts.0.5.TMP$fitD07D03),
            label = paste("Correlation =", round(cor_value_shared_0.5_tmp.v1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.Counts.0.5.TMP$fitA08A05),
           y = max(L15.v1.v2.Counts.0.5.TMP$fitD07D03),
           label = paste("Shared Perfects =", num_rows.counts.0.5.tmp.v1), hjust = 0, vjust = 1.5)

Lib15_v1_v2_0.5_TMP_p01 <- ggMarginal(Lib15_v1_v2_0.5_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_v1_v2_0.5_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.v1.v2.correlation.perfects.median.1BC.fitness.0.5.tmp.png",
       plot=Lib15_v1_v2_0.5_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot median fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for 1.0-TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_1.0_tmp.v1 <- cor_test_Counts_shared_1.0_tmp.v1$estimate

# Format p-value in scientific notation
p_value_scientific_shared_1.0_tmp.v1 <- format(cor_test_Counts_shared_1.0_tmp.v1$p.value, 
                                                 scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.1.0.tmp.v1 <- nrow(L15.v1.v2.Counts.1.0.TMP)

# Plot based on shared mutID
Lib15_v1_v2_1.0_TMP <- ggplot(L15.v1.v2.Counts.1.0.TMP, 
                   aes(x=fitA09A05, y=fitD08D03, color=log(numprunedBCs.x))) +
  labs(x = "Lib15.v1 Median Fitness (LogFC)", y ="Lib15.v2 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n1.0 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.Counts.1.0.TMP$fitA09A05),
           y = min(L15.v1.v2.Counts.1.0.TMP$fitD08D03), 
           label = paste("p-value =", p_value_scientific_shared_1.0_tmp.v1), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.Counts.1.0.TMP$fitA09A05),
           y = min(L15.v1.v2.Counts.1.0.TMP$fitD08D03),
            label = paste("Correlation =", round(cor_value_shared_1.0_tmp.v1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.Counts.1.0.TMP$fitA09A05),
           y = max(L15.v1.v2.Counts.1.0.TMP$fitD08D03),
           label = paste("Shared Perfects =", num_rows.counts.1.0.tmp.v1), hjust = 0, vjust = 1.5)

Lib15_v1_v2_1.0_TMP_p01 <- ggMarginal(Lib15_v1_v2_1.0_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_v1_v2_1.0_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.v1.v2.correlation.perfects.median.1BC.fitness.1.0.tmp.png",
       plot=Lib15_v1_v2_1.0_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot median fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for 10-TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_10_tmp.v1 <- cor_test_Counts_shared_10_tmp.v1$estimate

# Format p-value in scientific notation
p_value_scientific_shared_10_tmp.v1 <- format(cor_test_Counts_shared_10_tmp.v1$p.value, 
                                                 scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.10.tmp.v1 <- nrow(L15.v1.v2.Counts.10.TMP)

# Plot based on shared mutID
Lib15_v1_v2_10_TMP <- ggplot(L15.v1.v2.Counts.10.TMP, 
                   aes(x=fitA10A05, y=fitD09D03, color=log(numprunedBCs.x))) +
  labs(x = "Lib15.v1 Median Fitness (LogFC)", y ="Lib15.v2 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n10 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.Counts.10.TMP$fitA10A05),
           y = min(L15.v1.v2.Counts.10.TMP$fitD09D03), 
           label = paste("p-value =", p_value_scientific_shared_10_tmp.v1), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.Counts.10.TMP$fitA10A05),
           y = min(L15.v1.v2.Counts.10.TMP$fitD09D03),
            label = paste("Correlation =", round(cor_value_shared_10_tmp.v1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.Counts.10.TMP$fitA10A05),
           y = max(L15.v1.v2.Counts.10.TMP$fitD09D03),
           label = paste("Shared Perfects =", num_rows.counts.10.tmp.v1), hjust = 0, vjust = 1.5)

Lib15_v1_v2_10_TMP_p01 <- ggMarginal(Lib15_v1_v2_10_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_v1_v2_10_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.v1.v2.correlation.perfects.median.1BC.fitness.10.tmp.png",
       plot=Lib15_v1_v2_10_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot median fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for 50-TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_50_tmp.v1 <- cor_test_Counts_shared_50_tmp.v1$estimate

# Format p-value in scientific notation
p_value_scientific_shared_50_tmp.v1 <- format(cor_test_Counts_shared_50_tmp.v1$p.value, 
                                                 scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.50.tmp.v1 <- nrow(L15.v1.v2.Counts.50.TMP)

# Plot based on shared mutID
Lib15_v1_v2_50_TMP <- ggplot(L15.v1.v2.Counts.50.TMP, 
                   aes(x=fitA11A05, y=fitD10D03, color=log(numprunedBCs.x))) +
  labs(x = "Lib15.v1 Median Fitness (LogFC)", y ="Lib15.v2 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n50 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.Counts.50.TMP$fitA11A05),
           y = min(L15.v1.v2.Counts.50.TMP$fitD10D03), 
           label = paste("p-value =", p_value_scientific_shared_50_tmp.v1), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.Counts.50.TMP$fitA11A05),
           y = min(L15.v1.v2.Counts.50.TMP$fitD10D03),
            label = paste("Correlation =", round(cor_value_shared_50_tmp.v1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.Counts.50.TMP$fitA11A05),
           y = max(L15.v1.v2.Counts.50.TMP$fitD10D03),
           label = paste("Shared Perfects =", num_rows.counts.50.tmp.v1), hjust = 0, vjust = 1.5)

Lib15_v1_v2_50_TMP_p01 <- ggMarginal(Lib15_v1_v2_50_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_v1_v2_50_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.v1.v2.correlation.perfects.median.1BC.fitness.50.tmp.png",
       plot=Lib15_v1_v2_50_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot median fitness correlations between Lib15.v1 & Lib15.v2 (perfects) for 200-TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_200_tmp.v1 <- cor_test_Counts_shared_200_tmp.v1$estimate

# Format p-value in scientific notation
p_value_scientific_shared_200_tmp.v1 <- format(cor_test_Counts_shared_200_tmp.v1$p.value, 
                                                 scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.200.tmp.v1 <- nrow(L15.v1.v2.Counts.200.TMP)

# Plot based on shared mutID
Lib15_v1_v2_200_TMP <- ggplot(L15.v1.v2.Counts.200.TMP, 
                   aes(x=fitA12A05, y=fitD11D03, color=log(numprunedBCs.x))) +
  labs(x = "Lib15.v1 Median Fitness (LogFC)", y ="Lib15.v2 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 (v1) vs Library 15 (v2) \n200 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.v1.v2.Counts.200.TMP$fitA12A05),
           y = min(L15.v1.v2.Counts.200.TMP$fitD11D03), 
           label = paste("p-value =", p_value_scientific_shared_200_tmp.v1), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.v1.v2.Counts.200.TMP$fitA12A05),
           y = min(L15.v1.v2.Counts.200.TMP$fitD11D03),
            label = paste("Correlation =", round(cor_value_shared_200_tmp.v1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.v1.v2.Counts.200.TMP$fitA12A05),
           y = max(L15.v1.v2.Counts.200.TMP$fitD11D03),
           label = paste("Shared Perfects =", num_rows.counts.200.tmp.v1), hjust = 0, vjust = 1.5)

Lib15_v1_v2_200_TMP_p01 <- ggMarginal(Lib15_v1_v2_200_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_v1_v2_200_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.v1.v2.correlation.perfects.median.1BC.fitness.200.tmp.png",
       plot=Lib15_v1_v2_200_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

### Lib15.v2 vs. Lib16

#### Subset for Plotting

Because many of the shared mutIDs have "NA" values for one library or the other at certain treatment conditions, we need to subset the dataframe into smaller datasets relevant for each condition we want to plot and remove rows containing "NA" values. **All correlations are based on the "BCs.15.16.mutID.fitness.perfects.shared" dataset.**

Subset relevant data columns and remove rows containing "NA" values:
```{r}
# Complementation - 0-TMP
L15.L16.Counts.0.TMP <- perfects_15_16_shared[, c("mutID", "numprunedBCs.x", "numprunedBCs.y", "fitD05D03", "fitD12D04")] %>%
  na.omit(L15.L16.Counts.0.TMP)

# Trimethoprim - 0.058-TMP
L15.L16.Counts.0.058.TMP <- perfects_15_16_shared[, c("mutID", "numprunedBCs.x", "numprunedBCs.y", "fitD06D03", "fitE01D04")] %>%
  na.omit(L15.L16.Counts.0.058.TMP)

# Trimethoprim - 0.5-TMP
L15.L16.Counts.0.5.TMP <- perfects_15_16_shared[, c("mutID", "numprunedBCs.x", "numprunedBCs.y", "fitD07D03", "fitE02D04")] %>%
  na.omit(L15.L16.Counts.0.5.TMP)

# Trimethoprim - 1.0-TMP
L15.L16.Counts.1.0.TMP <- perfects_15_16_shared[, c("mutID", "numprunedBCs.x", "numprunedBCs.y", "fitD08D03", "fitE03D04")] %>%
  na.omit(L15.L16.Counts.1.0.TMP)

# Trimethoprim - 10-TMP
L15.L16.Counts.10.TMP <- perfects_15_16_shared[, c("mutID", "numprunedBCs.x", "numprunedBCs.y", "fitD09D03", "fitE04D04")] %>%
  na.omit(L15.L16.Counts.10.TMP)

# Trimethoprim - 50-TMP
L15.L16.Counts.50.TMP <- perfects_15_16_shared[, c("mutID", "numprunedBCs.x", "numprunedBCs.y", "fitD10D03", "fitE05D04")] %>%
  na.omit(L15.L16.Counts.50.TMP)

# Trimethoprim - 200-TMP
L15.L16.Counts.200.TMP <- perfects_15_16_shared[, c("mutID", "numprunedBCs.x", "numprunedBCs.y", "fitD11D03", "fitE06D04")]%>%
  na.omit(L15.L16.Counts.200.TMP)
```

#### Pearson Correlations

The following section calculates Pearson's correlations based on the fitness scores of unique mutIDs shared between Lib15 and Lib16 for Time Point 1.

**Pearson's Correlation:** Determine correlations using fitness values from Libraries 15 and 16 at Time Point 1:
```{r class.output="goodCode"}
# Pearson's Correlation: 0-TMP (Complementation)
cor_test_Counts_shared_0_tmp <- cor.test(L15.L16.Counts.0.TMP$fitD05D03,
                                         L15.L16.Counts.0.TMP$fitD12D04)

# Pearson's Correlation: 0.058-TMP
cor_test_Counts_shared_0.058_tmp <- cor.test(L15.L16.Counts.0.058.TMP$fitD06D03,
                                             L15.L16.Counts.0.058.TMP$fitE01D04)

# Pearson's Correlation: 0.5-TMP
cor_test_Counts_shared_0.5_tmp <- cor.test(L15.L16.Counts.0.5.TMP$fitD07D03,
                                           L15.L16.Counts.0.5.TMP$fitE02D04)

# Pearson's Correlation: 1.0-TMP
cor_test_Counts_shared_1.0_tmp <- cor.test(L15.L16.Counts.1.0.TMP$fitD08D03,
                                           L15.L16.Counts.1.0.TMP$fitE03D04)

# Pearson's Correlation: 10-TMP
cor_test_Counts_shared_10_tmp <- cor.test(L15.L16.Counts.10.TMP$fitD09D03,
                                          L15.L16.Counts.10.TMP$fitE04D04)

# Pearson's Correlation: 50-TMP
cor_test_Counts_shared_50_tmp <- cor.test(L15.L16.Counts.50.TMP$fitD10D03,
                                          L15.L16.Counts.50.TMP$fitE05D04)

# Pearson's Correlation: 200-TMP
cor_test_Counts_shared_200_tmp <- cor.test(L15.L16.Counts.200.TMP$fitD11D03,
                                           L15.L16.Counts.200.TMP$fitE06D04)
```

```{r class.output="goodCode"}
# Print the full statistical output:
print(cor_test_Counts_shared_0_tmp)
print(cor_test_Counts_shared_0.058_tmp)
print(cor_test_Counts_shared_0.5_tmp)
print(cor_test_Counts_shared_1.0_tmp)
print(cor_test_Counts_shared_10_tmp)
print(cor_test_Counts_shared_50_tmp)
print(cor_test_Counts_shared_200_tmp)
```

#### Correlation Plots

Plot median fitness correlations between Lib15 & Lib16 (perfects) for Complementation:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_0_tmp <- cor_test_Counts_shared_0_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_0_tmp <- format(cor_test_Counts_shared_0_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.0.tmp <- nrow(L15.L16.Counts.0.TMP)

# Plot based on shared mutID
Lib15_16_0_TMP <- ggplot(L15.L16.Counts.0.TMP, 
                   aes(x=fitD05D03, y=fitD12D04, color=log(numprunedBCs.x))) +
  labs(x = "Lib15 Median Fitness (LogFC)", y ="Lib16 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 vs Library 16 \n0 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.L16.Counts.0.TMP$fitD05D03),
           y = min(L15.L16.Counts.0.TMP$fitD12D04), 
           label = paste("p-value =", p_value_scientific_shared_0_tmp), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.L16.Counts.0.TMP$fitD05D03),
           y = min(L15.L16.Counts.0.TMP$fitD12D04),
            label = paste("Correlation =", round(cor_value_shared_0_tmp, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.L16.Counts.0.TMP$fitD05D03),
           y = max(L15.L16.Counts.0.TMP$fitD12D04),
           label = paste("Shared Perfects =", num_rows.counts.0.tmp), hjust = 0, vjust = 1.5)

Lib15_16_0_TMP_p01 <- ggMarginal(Lib15_16_0_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_16_0_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.16.correlation.perfects.median.1BC.fitness.complementation.0.tmp.png",
       plot=Lib15_16_0_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot shared fitness correlations between Lib15 & Lib16 (perfects) for 0.058 TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_0.058_tmp <- cor_test_Counts_shared_0.058_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_0.058_tmp <- format(cor_test_Counts_shared_0.058_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.0.058.tmp <- nrow(L15.L16.Counts.0.058.TMP)

# Plot based on shared mutID
Lib15_16_0.058_TMP <- ggplot(L15.L16.Counts.0.058.TMP, 
                   aes(x=fitD06D03, y=fitE01D04, color=log(numprunedBCs.x))) +
  labs(x = "Lib15 Median Fitness (LogFC)", y ="Lib16 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 vs Library 16 \n0.058 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.L16.Counts.0.058.TMP$fitD06D03),
           y = min(L15.L16.Counts.0.058.TMP$fitE01D04), 
           label = paste("p-value =", p_value_scientific_shared_0.058_tmp), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.L16.Counts.0.058.TMP$fitD06D03),
           y = min(L15.L16.Counts.0.058.TMP$fitE01D04),
            label = paste("Correlation =", round(cor_value_shared_0.058_tmp, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.L16.Counts.0.058.TMP$fitD06D03),
           y = max(L15.L16.Counts.0.058.TMP$fitE01D04),
           label = paste("Shared Perfects =", num_rows.counts.0.058.tmp), hjust = 0, vjust = 1.5)

Lib15_16_0.058_TMP_p01 <- ggMarginal(Lib15_16_0.058_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_16_0.058_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.16.correlation.perfects.median.1BC.fitness.complementation.0.058.tmp.png",
       plot=Lib15_16_0.058_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot shared fitness correlations between Lib15 & Lib16 (perfects) for 0.5 TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_0.5_tmp <- cor_test_Counts_shared_0.5_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_0.5_tmp <- format(cor_test_Counts_shared_0.5_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.0.5.tmp <- nrow(L15.L16.Counts.0.5.TMP)

# Plot based on shared mutID
Lib15_16_0.5_TMP <- ggplot(L15.L16.Counts.0.5.TMP, 
                   aes(x=fitD07D03, y=fitE02D04, color=log(numprunedBCs.x))) +
  labs(x = "Lib15 Median Fitness (LogFC)", y ="Lib16 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 vs Library 16 \n0.5 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.L16.Counts.0.5.TMP$fitD07D03),
           y = min(L15.L16.Counts.0.5.TMP$fitE02D04), 
           label = paste("p-value =", p_value_scientific_shared_0.5_tmp), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.L16.Counts.0.5.TMP$fitD07D03),
           y = min(L15.L16.Counts.0.5.TMP$fitE02D04),
            label = paste("Correlation =", round(cor_value_shared_0.5_tmp, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.L16.Counts.0.5.TMP$fitD07D03),
           y = max(L15.L16.Counts.0.5.TMP$fitE02D04),
           label = paste("Shared Perfects =", num_rows.counts.0.5.tmp), hjust = 0, vjust = 1.5)

Lib15_16_0.5_TMP_p01 <- ggMarginal(Lib15_16_0.5_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_16_0.5_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.16.correlation.perfects.median.1BC.fitness.complementation.0.5.tmp.png",
       plot=Lib15_16_0.5_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot shared fitness correlations between Lib15 & Lib16 (perfects) for 1.0 TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_1.0_tmp <- cor_test_Counts_shared_1.0_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_1.0_tmp <- format(cor_test_Counts_shared_1.0_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.1.0.tmp <- nrow(L15.L16.Counts.1.0.TMP)

# Plot based on shared mutID
Lib15_16_1.0_TMP <- ggplot(L15.L16.Counts.1.0.TMP, 
                   aes(x=fitD08D03, y=fitE03D04, color=log(numprunedBCs.x))) +
  labs(x = "Lib15 Median Fitness (LogFC)", y ="Lib16 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 vs Library 16 \n1.0 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.L16.Counts.1.0.TMP$fitD08D03),
           y = min(L15.L16.Counts.1.0.TMP$fitE03D04), 
           label = paste("p-value =", p_value_scientific_shared_1.0_tmp), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.L16.Counts.1.0.TMP$fitD08D03),
           y = min(L15.L16.Counts.1.0.TMP$fitE03D04),
            label = paste("Correlation =", round(cor_value_shared_1.0_tmp, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.L16.Counts.1.0.TMP$fitD08D03),
           y = max(L15.L16.Counts.1.0.TMP$fitE03D04),
           label = paste("Shared Perfects =", num_rows.counts.1.0.tmp), hjust = 0, vjust = 1.5)

Lib15_16_1.0_TMP_p01 <- ggMarginal(Lib15_16_1.0_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_16_1.0_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.16.correlation.perfects.median.1BC.fitness.complementation.1.0.tmp.png",
       plot=Lib15_16_1.0_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot shared fitness correlations between Lib15 & Lib16 (perfects) for 10 TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_10_tmp <- cor_test_Counts_shared_10_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_10_tmp <- format(cor_test_Counts_shared_10_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.10.tmp <- nrow(L15.L16.Counts.10.TMP)

# Plot based on shared mutID
Lib15_16_10_TMP <- ggplot(L15.L16.Counts.10.TMP, 
                   aes(x=fitD09D03, y=fitE04D04, color=log(numprunedBCs.x))) +
  labs(x = "Lib15 Median Fitness (LogFC)", y ="Lib16 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 vs Library 16 \n10 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.L16.Counts.10.TMP$fitD09D03),
           y = min(L15.L16.Counts.10.TMP$fitE04D04), 
           label = paste("p-value =", p_value_scientific_shared_10_tmp), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.L16.Counts.10.TMP$fitD09D03),
           y = min(L15.L16.Counts.10.TMP$fitE04D04),
            label = paste("Correlation =", round(cor_value_shared_10_tmp, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.L16.Counts.10.TMP$fitD09D03),
           y = max(L15.L16.Counts.10.TMP$fitE04D04),
           label = paste("Shared Perfects =", num_rows.counts.10.tmp), hjust = 0, vjust = 1.5)

Lib15_16_10_TMP_p01 <- ggMarginal(Lib15_16_10_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_16_10_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.16.correlation.perfects.median.1BC.fitness.complementation.10.tmp.png",
       plot=Lib15_16_10_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot shared fitness correlations between Lib15 & Lib16 (perfects) for 50 TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_50_tmp <- cor_test_Counts_shared_50_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_50_tmp <- format(cor_test_Counts_shared_50_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.50.tmp <- nrow(L15.L16.Counts.50.TMP)

# Plot based on shared mutID
Lib15_16_50_TMP <- ggplot(L15.L16.Counts.50.TMP, 
                   aes(x=fitD10D03, y=fitE05D04, color=log(numprunedBCs.x))) +
  labs(x = "Lib15 Median Fitness (LogFC)", y ="Lib16 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 vs Library 16 \n50 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.L16.Counts.50.TMP$fitD10D03),
           y = min(L15.L16.Counts.50.TMP$fitE05D04), 
           label = paste("p-value =", p_value_scientific_shared_50_tmp), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.L16.Counts.50.TMP$fitD10D03),
           y = min(L15.L16.Counts.50.TMP$fitE05D04),
            label = paste("Correlation =", round(cor_value_shared_50_tmp, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.L16.Counts.50.TMP$fitD10D03),
           y = max(L15.L16.Counts.50.TMP$fitE05D04),
           label = paste("Shared Perfects =", num_rows.counts.50.tmp), hjust = 0, vjust = 1.5)

Lib15_16_50_TMP_p01 <- ggMarginal(Lib15_16_50_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_16_50_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.16.correlation.perfects.median.1BC.fitness.complementation.50.tmp.png",
       plot=Lib15_16_50_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

Plot shared fitness correlations between Lib15 & Lib16 (perfects) for 200 TMP:
```{r}
# Extract correlation value from cor_value_shared object
cor_value_shared_200_tmp <- cor_test_Counts_shared_200_tmp$estimate

# Format p-value in scientific notation
p_value_scientific_shared_200_tmp <- format(cor_test_Counts_shared_200_tmp$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.200.tmp <- nrow(L15.L16.Counts.200.TMP)

# Plot based on shared mutID
Lib15_16_200_TMP <- ggplot(L15.L16.Counts.200.TMP, 
                   aes(x=fitD11D03, y=fitE06D04, color=log(numprunedBCs.x))) +
  labs(x = "Lib15 Median Fitness (LogFC)", y ="Lib16 Median Fitness (LogFC)",color="") +
  ggtitle("Shared Perfects Median Fitness Correlation \nLibrary 15 vs Library 16 \n200 g/mL tmp") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("",low="blue", high="red", mid="blue") + 
  theme(legend.position="left") +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank()) +
  panel_border(color = "black") +
  annotate("text",
           x = max(L15.L16.Counts.200.TMP$fitD11D03),
           y = min(L15.L16.Counts.200.TMP$fitE06D04), 
           label = paste("p-value =", p_value_scientific_shared_200_tmp), hjust = 1, vjust = 0) +
  annotate("text",
           x = max(L15.L16.Counts.200.TMP$fitD11D03),
           y = min(L15.L16.Counts.200.TMP$fitE06D04),
            label = paste("Correlation =", round(cor_value_shared_200_tmp, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(L15.L16.Counts.200.TMP$fitD11D03),
           y = max(L15.L16.Counts.200.TMP$fitE06D04),
           label = paste("Shared Perfects =", num_rows.counts.200.tmp), hjust = 0, vjust = 1.5)

Lib15_16_200_TMP_p01 <- ggMarginal(Lib15_16_200_TMP, type = "histogram", fill = "aquamarine4", alpha = 0.5)

Lib15_16_200_TMP_p01
```

```{r echo=FALSE}
ggsave(file="plots/correlation/counts/Lib15.16.correlation.perfects.median.1BC.fitness.complementation.200.tmp.png",
       plot=Lib15_16_200_TMP_p01,
       dpi=600, width = 8, height = 6, units = "in")
```

## Perfects Plots
The following section plots various summarizes of the Perfects BCs (minimum 5BC count/mutID):

Re-order the "perfects" dataset by "numprunedBCs" in ascending order:
```{r}
# Rank order based on numprunedBCs in Lib15
perfects_shared.rank.15 <- perfects_15_16_shared %>%
  arrange(numprunedBCs.x)

# Rank order based on numprunedBCs in Lib16
perfects_shared.rank.16 <- perfects_15_16_shared %>%
  arrange(numprunedBCs.y)
```

Make plotting key based on "numprunedBCs"
```{r}
# Plotting key based on numprunedBCs in Lib15
perfects_shared.rank.15$numprunedBCs.x.key <- 1:length(perfects_shared.rank.15$mutID)

# Plotting key based on numprunedBCs in Lib16
perfects_shared.rank.16$numprunedBCs.y.key <- 1:length(perfects_shared.rank.16$mutID)
```

### Homolog Fitness Plots

#### Rank Order Fitness Plots
Plot the number of perfects barcodes recovered based on the rank order of homologs:

**Shared mutIDs**
```{r}
# Rename columns in one of the data frames
colnames(perfects_shared.rank.16) <- paste0(colnames(perfects_shared.rank.16), "_16")

# Combine the data frames
perfects_shared.rank.15.16 <- cbind(perfects_shared.rank.15, perfects_shared.rank.16)
```

```{r}
# Create the plot
perfects_shared.rank.15.16_plot <- ggplot(perfects_shared.rank.15.16, aes(x = numprunedBCs.x.key)) +
  geom_point(aes(y = numprunedBCs.x, color = "Lib15"), size = 2) +
  geom_point(aes(y = numprunedBCs.y_16, color = "Lib16"), size = 2) +
  scale_color_manual(name = "Library", values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00")) +
  ylab("Number of Barcodes") +
  xlab("Rank Ordered Homolog") +
  scale_y_log10(limits = c(1, 2000)) +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        legend.text = element_text(size = 12),
        legend.position = "none")

perfects_shared.rank.15.16_plot
```

```{r echo=FALSE}
ggsave(file="plots/perfects/perfects15_16_rank_ordered_num_1BCs.png", plot=perfects_shared.rank.15.16_plot,
       dpi=600, width = 8, height = 6, units = "in")
```

##### Perfects (>1 BC) Histogram

Plot the Perfects counts based on fitness values between D05 vs. D03 (Lib15) or D12 vs. D04 (Lib16):
```{r}
rank_histogram_1BC_15_16 <- ggplot(perfects_shared.rank.15.16, aes(x = fitD05D03, fill = "Lib15")) +
  geom_histogram(binwidth = 0.1, alpha = 0.5, color = "black") +
  geom_histogram(aes(x = fitD12D04, fill = "Lib16"), binwidth = 0.1, alpha = 0.5, color = "black") +
  xlab("Median Fitness \n(Log2 Fold Change)") +
  ylab("Counts") +
  ggtitle("Complementation Rank Count \n(Perfects >1 BC)") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    legend.position = "none") +
  scale_x_continuous(limits = c(-7, 3)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 50)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00"), name = "Library")

rank_histogram_1BC_15_16
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.BC.perfects.fitness.counts.1BC.png", plot=rank_histogram_1BC_15_16,
       dpi=600, width = 10, height = 4, units = "in")
```

Summarize the total number of unique Perfects regardless of fitness value:
```{r class.output="goodCode"}
# Lib15
perfects15 %>%
  nrow(.)

# Lib16
perfects16 %>%
  nrow(.)

# Shared Perfects
perfects_15_16_shared %>%
  nrow(.)
```

Summarize the number of Perfects with fitness greater than -0.5 in D05 vs. D03 (Lib15) or D12 vs. D04 (Lib16) conditions:
```{r class.output="goodCode"}
# Shared Perfects - Lib15
perfects_15_16_shared %>% filter(fitD05D03>-0.5) %>%
  nrow(.)

# Shared Perfects - Lib16
perfects_15_16_shared %>% filter(fitD12D04>-0.5) %>%
  nrow(.)
```

##### Perfects (>2 BCs) Histogram

Plot the Perfects counts based on fitness values between D05 vs. D03 (Lib15) or D12 vs. D04 (Lib16) at > 2 BCs:

```{r}
rank_histogram_2BC_15_16 <- ggplot(perfects_15_16_shared_2BCs, aes(x = fitD05D03, fill = "Lib15")) +
  geom_histogram(binwidth = 0.1, alpha = 0.5, color = "black") +
  geom_histogram(aes(x = fitD12D04, fill = "Lib16"), binwidth = 0.1, alpha = 0.5, color = "black") +
  xlab("Fitness (Log2 Fold Change)") +
  ylab("Counts") +
  ggtitle("Complementation Rank Count \n(Perfects >2 BC)") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    legend.position = "none") +
  scale_x_continuous(limits = c(-7, 3)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 50)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00"), name = "Library")

rank_histogram_2BC_15_16
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.BC.perfects.fitness.counts.2BC.png", plot=rank_histogram_2BC_15_16,
       dpi=600, width = 8, height = 6, units = "in")
```

Summarize the total number of unique Perfects (>2 BCs) regardless of fitness value:
```{r class.output="goodCode"}
# Shared Perfects
perfects_15_16_shared_2BCs %>%
  nrow(.)
```

Summarize the number of Perfects (>2 BCs) with fitness greater than -0.5 in D05 vs. D03 (Lib15) or D12 vs. D04 (Lib16) conditions:
```{r class.output="goodCode"}
# Lib15
perfects_15_16_shared_2BCs %>% filter(fitD05D03>-0.5) %>%
  nrow(.)

# Lib16
perfects_15_16_shared_2BCs %>% filter(fitD12D04>-0.5) %>%
  nrow(.)
```

##### Perfects (>5 BCs) Histogram

Plot the Perfects counts based on fitness values between D05 vs. D03 (Lib15) or D12 vs. D04 (Lib16) at > 5 BCs:
```{r}
rank_histogram_5BC_15_16 <- ggplot(perfects_15_16_shared_5BCs, aes(x = fitD05D03, fill = "Lib15")) +
  geom_histogram(binwidth = 0.1, alpha = 0.5, color = "black") +
  geom_histogram(aes(x = fitD12D04, fill = "Lib16"), binwidth = 0.1, alpha = 0.5, color = "black") +
  xlab("Fitness (Log2 Fold Change)") +
  ylab("Counts") +
  ggtitle("Complementation Rank Count \n(Perfects >5 BC)") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    legend.position = "bottom") +
  scale_x_continuous(limits = c(-7, 3)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 50)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00"), name = "Library")

rank_histogram_5BC_15_16
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.BC.perfects.fitness.counts.5BC.png", plot=rank_histogram_5BC_15_16,
       dpi=600, width = 8, height = 6, units = "in")
```

Summarize the total number of unique Perfects (>2 BCs) regardless of fitness value:
```{r class.output="goodCode"}
# Shared Perfects
perfects_15_16_shared_5BCs %>%
  nrow(.)
```

Summarize the number of Perfects (>2 BCs) with fitness greater than -0.5 in D05 vs. D03 (Lib15) or D12 vs. D04 (Lib16) conditions:
```{r class.output="goodCode"}
# Lib15
perfects_15_16_shared_5BCs %>% filter(fitD05D03>-0.5) %>%
  nrow(.)

# Lib16
perfects_15_16_shared_5BCs %>% filter(fitD12D04>-0.5) %>%
  nrow(.)
```

**Plot all minimum BC levels together**
```{r echo=FALSE}
patch9 <- perfects_shared.rank.15.16_plot / rank_histogram_1BC_15_16 / rank_histogram_2BC_15_16 / rank_histogram_5BC_15_16
patch9
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.allBCs.2BCs.5BCs.perfects.rank.order.fitness.counts.png", plot=patch9,
       dpi=600, width = 5, height = 12, units = "in")
```

#### Perfects Scatter Plot (>1 BCs)
Plot the Perfects fitness scores for D05 vs. D03 (Lib15) or D12 vs. D04 (Lib16) based on the number of recovered barcodes:

```{r}
BC_scatter_1BC_15_16 <- ggplot() +
  geom_point(data = perfects_15_16_shared, aes(x = numprunedBCs.x, y = fitD05D03), color = "#0072B2", alpha = 0.8) +
  geom_point(data = perfects_15_16_shared, aes(x = numprunedBCs.y, y = fitD12D04), color = "#E69F00", alpha = 0.8) +
  xlab("Number of Barcodes") +
  ylab("Fitness (Log2 Fold Change)") +
  ggtitle("Barcode Counts \n(Perfects >1 BC)") +
  scale_x_log10() +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())

BC_scatter_1BC_15_16
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.1BCs.perfects.scatter.fitD05D03.fitD12D04.png", plot=BC_scatter_1BC_15_16,
       dpi=600, width = 12, height = 7.5, units = "in")
```

#### Perfects Dose Response (>1 BCs)

Gather the median fitness of Perfects at each Trimethoprim concentration based on filtered 1BC dataset.

**Library 15**
```{r}
# Filter perfects_15_16 dataset by minimum of numprunedBCs
perfects15_1BCsdr <- perfects_15_16_shared %>%
  select(mutID, fitD05D03, fitD06D03, fitD07D03, fitD08D03, fitD09D03, fitD10D03, fitD11D03, numprunedBCs.x) %>%#
  gather("selection","fitness",-mutID,-numprunedBCs.x)

# Create naming factors to convert column names into trimethoprim concentrations for plotting
perfects15_1BCsdr$tmpfactor <- "0"
perfects15_1BCsdr$tmpfactor[perfects15_1BCsdr$selection== "fitD05D03"] <- "0"
perfects15_1BCsdr$tmpfactor[perfects15_1BCsdr$selection== "fitD06D03"] <- "0.0058"
perfects15_1BCsdr$tmpfactor[perfects15_1BCsdr$selection== "fitD07D03"] <- "0.5"
perfects15_1BCsdr$tmpfactor[perfects15_1BCsdr$selection== "fitD08D03"] <- "1"
perfects15_1BCsdr$tmpfactor[perfects15_1BCsdr$selection== "fitD09D03"] <- "10"
perfects15_1BCsdr$tmpfactor[perfects15_1BCsdr$selection== "fitD10D03"] <- "50"
perfects15_1BCsdr$tmpfactor[perfects15_1BCsdr$selection== "fitD11D03"] <- "200"

perfects15_1BCsdr$tmpname[perfects15_1BCsdr$selection== "fitD05D03"] <- "A"
perfects15_1BCsdr$tmpname[perfects15_1BCsdr$selection== "fitD06D03"] <- "B"
perfects15_1BCsdr$tmpname[perfects15_1BCsdr$selection== "fitD07D03"] <- "C"
perfects15_1BCsdr$tmpname[perfects15_1BCsdr$selection== "fitD08D03"] <- "D"
perfects15_1BCsdr$tmpname[perfects15_1BCsdr$selection== "fitD09D03"] <- "E"
perfects15_1BCsdr$tmpname[perfects15_1BCsdr$selection== "fitD10D03"] <- "F"
perfects15_1BCsdr$tmpname[perfects15_1BCsdr$selection== "fitD11D03"] <- "G"

perfects15_1BCsdrlabs <- c("0","0.058","0.5","1","10","50","200")
```

##### Lib15 Violin Plot
```{r}
TMP_plot_1BC_15 <- ggplot(perfects15_1BCsdr,aes(x=tmpname,y=fitness)) + 
  geom_violin(fill = "#0072B2", alpha=0.75) +
  geom_boxplot(width=0.1) +
  xlab("Trimethoprim (ug/mL)") +
  ylab("Median Fitness") +
  scale_x_discrete(labels= perfects15_1BCsdrlabs) +
  ggtitle("Library 15 Dose Response \n(Perfects >1 BC)") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        legend.text = element_text(size = 12),
        legend.position = c(0.16, 1),
        legend.justification = c(1, 1),
        legend.box.background = element_rect(colour = "black")) +
  scale_y_continuous(expand = c(0, 0), limits = c(-12,8))

TMP_plot_1BC_15
```

```{r echo=FALSE}
# Lib15
ggsave(file="plots/perfects/Lib15.1BCs.perfects.dose.response.day.1.violin.png", plot=TMP_plot_1BC_15,
       dpi=600, width = 12, height = 7.5, units = "in")
```

##### Lib16 Violin Plot
```{r}
# Filter perfects16_5BCs dataset by minimum of numprunedBCs
perfects16_1BCsdr <- perfects_15_16_shared %>%
  #filter(numprunedBCs>10) %>%
  select(mutID, fitD12D04, fitE01D04, fitE02D04, fitE03D04, fitE04D04, fitE05D04, fitE06D04, numprunedBCs.y) %>%#
  gather("selection","fitness",-mutID,-numprunedBCs.y)

# Create naming factors to convert column names into trimethoprim concentrations for plotting
perfects16_1BCsdr$tmpfactor <- "0"
perfects16_1BCsdr$tmpfactor[perfects16_1BCsdr$selection== "fitD12D04"] <- "0"
perfects16_1BCsdr$tmpfactor[perfects16_1BCsdr$selection== "fitE01D04"] <- "0.0058"
perfects16_1BCsdr$tmpfactor[perfects16_1BCsdr$selection== "fitE02D04"] <- "0.5"
perfects16_1BCsdr$tmpfactor[perfects16_1BCsdr$selection== "fitE03D04"] <- "1"
perfects16_1BCsdr$tmpfactor[perfects16_1BCsdr$selection== "fitE04D04"] <- "10"
perfects16_1BCsdr$tmpfactor[perfects16_1BCsdr$selection== "fitE05D04"] <- "50"
perfects16_1BCsdr$tmpfactor[perfects16_1BCsdr$selection== "fitE06D04"] <- "200"

perfects16_1BCsdr$tmpname[perfects16_1BCsdr$selection== "fitD12D04"] <- "A"
perfects16_1BCsdr$tmpname[perfects16_1BCsdr$selection== "fitE01D04"] <- "B"
perfects16_1BCsdr$tmpname[perfects16_1BCsdr$selection== "fitE02D04"] <- "C"
perfects16_1BCsdr$tmpname[perfects16_1BCsdr$selection== "fitE03D04"] <- "D"
perfects16_1BCsdr$tmpname[perfects16_1BCsdr$selection== "fitE04D04"] <- "E"
perfects16_1BCsdr$tmpname[perfects16_1BCsdr$selection== "fitE05D04"] <- "F"
perfects16_1BCsdr$tmpname[perfects16_1BCsdr$selection== "fitE06D04"] <- "G"

perfects16_1BCsdrlabs <- c("0","0.058","0.5","1","10","50","200")
```

**Lib16 Violin Plot:** based on filtered 5BC dataset:
```{r}
TMP_plot_1BC_16 <- ggplot(perfects16_1BCsdr,aes(x=tmpname,y=fitness)) + 
  geom_violin(fill = "#E69F00") +
  geom_boxplot(width=0.1) +
  xlab("Trimethoprim (ug/mL)") +
  ylab("Median Fitness") +
  scale_x_discrete(labels= perfects16_1BCsdrlabs) +
  ggtitle("Library 16 Dose Response \n(Perfects >1 BC)") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.title = element_blank(),
        legend.text = element_text(size = 12),
        legend.position = c(0.16, 1),
        legend.justification = c(1, 1),
        legend.box.background = element_rect(colour = "black")) +
  scale_y_continuous(expand = c(0, 0), limits = c(-12,8))

TMP_plot_1BC_16
```

```{r echo=FALSE}
# Lib16
ggsave(file="plots/perfects/Lib16.1BCs.perfects.dose.response.day.1.violin.png", plot=TMP_plot_1BC_16,
       dpi=600, width = 12, height = 7.5, units = "in")
```

```{r echo=FALSE}
patch11 <- (TMP_plot_1BC_15 | TMP_plot_1BC_16)
patch11
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.1BCs.perfects.dose.response.day.1.violin.png", plot=patch11,
       dpi=600, width = 10, height = 4, units = "in")
```

##### Both Lib Boxplot

Combine the two data frames:
```{r}
perfects_15_16_1BCsdr <- bind_rows(
  perfects15_1BCsdr %>% mutate(Lib = "Lib15"), # Values derived from Lib15 perfects_15_16_shared_1BCs
  perfects16_1BCsdr %>% mutate(Lib = "Lib16"), # Values derived from Lib16 perfects_15_16_shared_1BCs
  .id = "id")

perfects_15_16_1BCsdrlabs <- c("0","0.058","0.5","1","10","50","200")
```

Plot the median fitness of Perfects at each Trimethoprim concentration for Day 1 based on filtered 5BC dataset:
```{r}
perfects_15_16_1BCsdr_plot <- ggplot(perfects_15_16_1BCsdr, aes(x = tmpname, y = fitness, fill = Lib)) +
  geom_boxplot(position = "dodge", alpha=0.8) +
  xlab("Trimethoprim (ug/mL)") +
  ylab("Fitness (Log2 Fold Change)") +
  scale_x_discrete(labels = perfects_15_16_1BCsdrlabs) +
  ggtitle("Dose Response to Trimethoprim \n(Perfects >1 BC)") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    legend.position = "bottom") +
  scale_y_continuous(expand = c(0, 0), limits = c(-12, 8)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00"))

# Display the plot
perfects_15_16_1BCsdr_plot
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.1BCs.perfects.dose.response.day.1.boxplot.png", plot=perfects_15_16_1BCsdr_plot,
       dpi=600, width = 10, height = 4, units = "in")
```

## DHFR Genes
Load in the organism dataset associated with DHFR genes for mapping taxonomy to the phylogenetic tree.
```{r}
#load in all the organisms info for unique BCs associated with DHFR genes: 
orginfo = read.csv("OUTPUT/DHFR_chip_3_proteins_addedseveral.csv", head=TRUE)  # read csv file
```

Subset the dataset:
```{r}
orginfo <- orginfo %>%
  select(-Lib.codon1, -Lib.codon2, -Construct., -Barcode) %>%
  dplyr::rename(IDfull=Accession) %>%
  #mutate(ID=strsplit(IDfull, split = ".")[1])
  tidyr::separate(IDfull, c("ID", "ver"), "\\.",remove = FALSE) %>%
  select(-ver)
names(orginfo)
```

Add the organism info to the perfects info as a new object called "perfects_tree":
```{r}
# Make a copy of "mutID" column called "ID" for matching with orginfo object:
perfects_15_16_shared <- perfects_15_16_shared %>%
  mutate(ID = mutID)

# Add orginfo to perfects_5BCs_tree
perfects_15_16_1BCs_tree <- right_join(orginfo,perfects_15_16_shared,by="ID") %>%
  select(-IDfull,-ID.x,-seq.x,-pct_ident.x,-BCs.x,-BCcode.x,-ID.y,-seq.y,-pct_ident.y,-BCs.y,-BCcode.y)
```

### Perfects % Similar E. coli Plot

#### Scatter Plot (>5 BCs)

Plot the Perfects fitness scores for D05 vs. D03 (Lib15) or D12 vs. D04 (Lib16) based on percent similarity of the each variant's gene sequences to the E. coli DHFR gene sequence:
```{r}
perfects_15_16_1BCs_scatter_plot <- ggplot() +
  geom_point(data = perfects_15_16_1BCs_tree, aes(x = PctIdentEcoli, y = fitD05D03), color = "#0072B2", alpha = 0.8) +
  geom_point(data = perfects_15_16_1BCs_tree, aes(x = PctIdentEcoli, y = fitD12D04), color = "#E69F00", alpha = 0.8) +
  xlab("Percent Similarity to E. coli DHFR") +
  ylab("Fitness (Log2 Fold Change)") +
  ggtitle("Median Fitness based on \n% Similarity to E. coli") +
  scale_x_log10() +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()) #+
  #scale_y_continuous(expand = c(0, 0), limits = c(-7, 1))

perfects_15_16_1BCs_scatter_plot
```

#### Binned Plot (>5 BCs)

Bin the % Similarity values in 10% increments and replot as boxplots:
```{r}
# Convert data to long format
data_long <- perfects_15_16_1BCs_tree %>%
  pivot_longer(cols = c(fitD05D03, fitD12D04), names_to = "variable", values_to = "value")

# Define new x-axis labels
new_x_labels <- c("30-40%", "40-50%", "50-60%", "60-70%", "70-80%", "80-90%", "90-100%")

perfects_15_16_1BCs_binned_plot <- ggplot(data_long, aes(x = cut(PctIdentEcoli, breaks = seq(0, 1.0, by = 0.1)), y = value, fill = variable)) +
  geom_boxplot(position = "dodge", alpha = 0.8) +
  xlab("Percent Similarity to E. coli DHFR (Binned)") +
  ylab("Median Fitness \n(Log2 Fold Change)") +
  ggtitle("Percent Similarity to E. coli \n(Perfects >1 BC)") +
  scale_x_discrete(labels = new_x_labels) +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    legend.position = "bottom") +
  scale_fill_manual(values = c("#0072B2", "#E69F00"), labels = c("Lib15", "Lib16"))

perfects_15_16_1BCs_binned_plot
```

```{r echo=FALSE}
# Scatterplot
ggsave(file="plots/combined/Lib15.16.1BCs.perfects.pctsim.vs.fitD05D03.fitD12D04.scatter.png",
       plot=perfects_15_16_1BCs_scatter_plot,
       dpi=600, width = 12, height = 7.5, units = "in")

# Boxplot
ggsave(file="plots/combined/Lib15.16.1BCs.perfects.pctsim.vs.fitD05D03.fitD12D04.boxplot.png",
       plot=perfects_15_16_1BCs_binned_plot,
       dpi=600, width = 12, height = 7.5, units = "in")
```

### Perfects Fitness Ridge Plots

**This section uses the `library(ggridges)` package.**

Subset the perfects_tree_5BCs object to retain only "ID" and fitness scores for select conditions. This code will transpose the individual fitness score columns into two columns with the fitness label and values, respectively, for each unique ID.

#### Day 1 (>5 BCs)
```{r}
# Lib15
perfects15_tree_1BCs_d1 <- perfects_15_16_1BCs_tree %>%
  select(ID, fitD05D03, fitD06D03, fitD07D03, fitD08D03, fitD09D03, fitD10D03, fitD11D03) %>%
  pivot_longer(!ID, names_to = "fc", values_to = "val") %>%
  mutate(TMP = case_when(
    fc == "fitD05D03" ~ "0-TMP",
    fc == "fitD06D03" ~ "0.058-TMP",
    fc == "fitD07D03" ~ "0.5-TMP",
    fc == "fitD08D03" ~ "1.0-TMP",
    fc == "fitD09D03" ~ "10-TMP",
    fc == "fitD10D03" ~ "50-TMP",
    fc == "fitD11D03" ~ "200-TMP",
    TRUE ~ NA_character_))

# Lib16
perfects16_tree_1BCs_d1 <- perfects_15_16_1BCs_tree %>%
  select(ID, fitD12D04, fitE01D04, fitE02D04, fitE03D04, fitE04D04, fitE05D04, fitE06D04) %>%
  pivot_longer(!ID, names_to = "fc", values_to = "val") %>%
  mutate(TMP = case_when(
    fc == "fitD12D04" ~ "0-TMP",
    fc == "fitE01D04" ~ "0.058-TMP",
    fc == "fitE02D04" ~ "0.5-TMP",
    fc == "fitE03D04" ~ "1.0-TMP",
    fc == "fitE04D04" ~ "10-TMP",
    fc == "fitE05D04" ~ "50-TMP",
    fc == "fitE06D04" ~ "200-TMP",
    TRUE ~ NA_character_))
```

```{r}
# Combine the two data frames
perfects_15_16_tree_1BCs_d1 <- bind_rows(
  perfects15_tree_1BCs_d1 %>% mutate(Lib = "Lib15"),
  perfects16_tree_1BCs_d1 %>% mutate(Lib = "Lib16"),
  .id = "id")
```

Plot Perfects fitness scores based on Supplementation treatment for first sampling time point
```{r}
perfects_15_16_tree_1BCs_d1_order <- c("200-TMP", "50-TMP", "10-TMP", "1.0-TMP", "0.5-TMP", "0.058-TMP", "0-TMP")

tmp_ridges_15_16_d1 <- ggplot(perfects_15_16_tree_1BCs_d1, aes(x = val, y = factor(TMP, level = perfects_15_16_tree_1BCs_d1_order), fill = Lib)) +
  geom_density_ridges(alpha = 0.7) +
  scale_y_discrete(labels = c('200 ug/mL TMP', '50 ug/mL TMP', '10 ug/mL TMP', '1 ug/mL TMP', '0.5 ug/mL TMP', '0.058 ug/mL TMP', 'M9 no supp.')) +
  xlab("Fitness (Log2 Fold Change)") +
  ylab("Selection Condition") +
  ggtitle("Dose Response \nDay 1") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "bottom",
    legend.text = element_text(size = 12),
    legend.title = element_blank()) +
  scale_x_continuous(limits = c(-15, 10)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00"), name = "Library")

# Display the plot
tmp_ridges_15_16_d1
```

```{r}
ggsave(file="plots/perfects/Lib15.16.1BCs.perfects.dose.response.ridges.day.1.png", plot=tmp_ridges_15_16_d1,
       dpi=600, width = 4, height = 8, units = "in")
```

#### Day 2 (>5 BCs)
```{r}
# Lib15
perfects15_tree_1BCs_d2 <- perfects_15_16_1BCs_tree %>%
  select(ID, fitE07D03, fitE08D03, fitE09D03, fitE10D03, fitE11D03, fitE12D03, fitF01D03) %>%
  pivot_longer(!ID, names_to = "fc", values_to = "val") %>%
  mutate(TMP = case_when(
    fc == "fitE07D03" ~ "0-TMP",
    fc == "fitE08D03" ~ "0.058-TMP",
    fc == "fitE09D03" ~ "0.5-TMP",
    fc == "fitE10D03" ~ "1.0-TMP",
    fc == "fitE11D03" ~ "10-TMP",
    fc == "fitE12D03" ~ "50-TMP",
    fc == "fitF01D03" ~ "200-TMP",
    TRUE ~ NA_character_))

# Lib16
perfects16_tree_1BCs_d2 <- perfects_15_16_1BCs_tree %>%
  select(ID, fitF02D04, fitF03D04, fitF04D04, fitF05D04, fitF06D04, fitF07D04, fitF08D04) %>%
  pivot_longer(!ID, names_to = "fc", values_to = "val") %>%
  mutate(TMP = case_when(
    fc == "fitF02D04" ~ "0-TMP",
    fc == "fitF03D04" ~ "0.058-TMP",
    fc == "fitF04D04" ~ "0.5-TMP",
    fc == "fitF05D04" ~ "1.0-TMP",
    fc == "fitF06D04" ~ "10-TMP",
    fc == "fitF07D04" ~ "50-TMP",
    fc == "fitF08D04" ~ "200-TMP",
    TRUE ~ NA_character_))
```

```{r}
# Combine the two data frames
perfects_15_16_tree_1BCs_d2 <- bind_rows(
  perfects15_tree_1BCs_d2 %>% mutate(Lib = "Lib15"),
  perfects16_tree_1BCs_d2 %>% mutate(Lib = "Lib16"),
  .id = "id")
```

Plot Perfects fitness scores based on Supplementation treatment for first sampling time point
```{r}
perfects_15_16_tree_1BCs_d2_order <- c("200-TMP", "50-TMP", "10-TMP", "1.0-TMP", "0.5-TMP", "0.058-TMP", "0-TMP")

tmp_ridges_15_16_d2 <- ggplot(perfects_15_16_tree_1BCs_d2, aes(x = val, y = factor(TMP, level = perfects_15_16_tree_1BCs_d2_order), fill = Lib)) +
  geom_density_ridges(alpha = 0.7) +
  scale_y_discrete(labels = c('200 ug/mL TMP', '50 ug/mL TMP', '10 ug/mL TMP', '1 ug/mL TMP', '0.5 ug/mL TMP', '0.058 ug/mL TMP', 'M9 no supp.')) +
  xlab("Fitness (Log2 Fold Change)") +
  ylab("Selection Condition") +
  ggtitle("Dose Response \nDay 2") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "none") +
  scale_x_continuous(limits = c(-15, 10)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00"), name = "Library")

# Display the plot
tmp_ridges_15_16_d2
```

```{r}
ggsave(file="plots/perfects/Lib15.16.1BCs.perfects.dose.response.ridges.day.2.png", plot=tmp_ridges_15_16_d2,
       dpi=600, width = 4, height = 8, units = "in")
```

#### Day 3 (>5 BCs)
```{r}
# Lib15
perfects15_tree_1BCs_d3 <- perfects_15_16_1BCs_tree %>%
  select(ID, fitF09D03, fitF10D03, fitF11D03, fitF12D03, fitG01D03, fitG02D03, fitG03D03) %>%
  pivot_longer(!ID, names_to = "fc", values_to = "val") %>%
  mutate(TMP = case_when(
    fc == "fitF09D03" ~ "0-TMP",
    fc == "fitF10D03" ~ "0.058-TMP",
    fc == "fitF11D03" ~ "0.5-TMP",
    fc == "fitF12D03" ~ "1.0-TMP",
    fc == "fitG01D03" ~ "10-TMP",
    fc == "fitG02D03" ~ "50-TMP",
    fc == "fitG03D03" ~ "200-TMP",
    TRUE ~ NA_character_))

# Lib16
perfects16_tree_1BCs_d3 <- perfects_15_16_1BCs_tree %>%
  select(ID, fitG04D04, fitG05D04, fitG06D04, fitG07D04, fitG08D04, fitG09D04, fitG10D04) %>%
  pivot_longer(!ID, names_to = "fc", values_to = "val") %>%
  mutate(TMP = case_when(
    fc == "fitG04D04" ~ "0-TMP",
    fc == "fitG05D04" ~ "0.058-TMP",
    fc == "fitG06D04" ~ "0.5-TMP",
    fc == "fitG07D04" ~ "1.0-TMP",
    fc == "fitG08D04" ~ "10-TMP",
    fc == "fitG09D04" ~ "50-TMP",
    fc == "fitG10D04" ~ "200-TMP",
    TRUE ~ NA_character_))
```

```{r}
# Combine the two data frames
perfects_15_16_tree_1BCs_d3 <- bind_rows(
  perfects15_tree_1BCs_d3 %>% mutate(Lib = "Lib15"),
  perfects16_tree_1BCs_d3 %>% mutate(Lib = "Lib16"),
  .id = "id")
```

Plot Perfects fitness scores based on Supplementation treatment for first sampling time point
```{r}
perfects_15_16_tree_1BCs_d3_order <- c("200-TMP", "50-TMP", "10-TMP", "1.0-TMP", "0.5-TMP", "0.058-TMP", "0-TMP")

tmp_ridges_15_16_d3 <- ggplot(perfects_15_16_tree_1BCs_d3, aes(x = val, y = factor(TMP, level = perfects_15_16_tree_1BCs_d3_order), fill = Lib)) +
  geom_density_ridges(alpha = 0.7) +
  scale_y_discrete(labels = c('200 ug/mL TMP', '50 ug/mL TMP', '10 ug/mL TMP', '1 ug/mL TMP', '0.5 ug/mL TMP', '0.058 ug/mL TMP', 'M9 no supp.')) +
  xlab("Fitness (Log2 Fold Change)") +
  ylab("Selection Condition") +
  ggtitle("Dose Response \nDay 3") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "none") +
  scale_x_continuous(limits = c(-15, 10)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00"), name = "Library")

# Display the plot
tmp_ridges_15_16_d3
```

```{r}
ggsave(file="plots/perfects/Lib15.16.1BCs.perfects.dose.response.ridges.day.3.png", plot=tmp_ridges_15_16_d3,
       dpi=600, width = 4, height = 8, units = "in")
```

#### Day 4 (>5 BCs)
```{r}
# Lib15
perfects15_tree_1BCs_d4 <- perfects_15_16_1BCs_tree %>%
  select(ID, fitG11D03, fitG12D03, fitH01D03, fitH02D03, fitH03D03, fitH04D03, fitH05D03) %>%
  pivot_longer(!ID, names_to = "fc", values_to = "val") %>%
  mutate(TMP = case_when(
    fc == "fitG11D03" ~ "0-TMP",
    fc == "fitG12D03" ~ "0.058-TMP",
    fc == "fitH01D03" ~ "0.5-TMP",
    fc == "fitH02D03" ~ "1.0-TMP",
    fc == "fitH03D03" ~ "10-TMP",
    fc == "fitH04D03" ~ "50-TMP",
    fc == "fitH05D03" ~ "200-TMP",
    TRUE ~ NA_character_))

# Lib16
perfects16_tree_1BCs_d4 <- perfects_15_16_1BCs_tree %>%
  select(ID, fitH06D04, fitH07D04, fitH08D04, fitH09D04, fitH10D04, fitH11D04, fitH12D04) %>%
  pivot_longer(!ID, names_to = "fc", values_to = "val") %>%
  mutate(TMP = case_when(
    fc == "fitH06D04" ~ "0-TMP",
    fc == "fitH07D04" ~ "0.058-TMP",
    fc == "fitH08D04" ~ "0.5-TMP",
    fc == "fitH09D04" ~ "1.0-TMP",
    fc == "fitH10D04" ~ "10-TMP",
    fc == "fitH11D04" ~ "50-TMP",
    fc == "fitH12D04" ~ "200-TMP",
    TRUE ~ NA_character_))
```

```{r}
# Combine the two data frames
perfects_15_16_tree_1BCs_d4 <- bind_rows(
  perfects15_tree_1BCs_d4 %>% mutate(Lib = "Lib15"),
  perfects16_tree_1BCs_d4 %>% mutate(Lib = "Lib16"),
  .id = "id")
```

Plot Perfects fitness scores based on Supplementation treatment for first sampling time point
```{r}
perfects_15_16_tree_1BCs_d4_order <- c("200-TMP", "50-TMP", "10-TMP", "1.0-TMP", "0.5-TMP", "0.058-TMP", "0-TMP")

tmp_ridges_15_16_d4 <- ggplot(perfects_15_16_tree_1BCs_d4, aes(x = val, y = factor(TMP, level = perfects_15_16_tree_1BCs_d4_order), fill = Lib)) +
  geom_density_ridges(alpha = 0.7) +
  scale_y_discrete(labels = c('200 ug/mL TMP', '50 ug/mL TMP', '10 ug/mL TMP', '1 ug/mL TMP', '0.5 ug/mL TMP', '0.058 ug/mL TMP', 'M9 no supp.')) +
  xlab("Fitness (Log2 Fold Change)") +
  ylab("Selection Condition") +
  ggtitle("Dose Response \nDay 4") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_blank(),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_blank(),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "none") +
  scale_x_continuous(limits = c(-15, 10)) +
  scale_fill_manual(values = c("Lib15" = "#0072B2", "Lib16" = "#E69F00"), name = "Library")

# Display the plot
tmp_ridges_15_16_d4
```

```{r}
ggsave(file="plots/perfects/Lib15.16.1BCs.perfects.dose.response.ridges.day.4.png", plot=tmp_ridges_15_16_d4,
       dpi=600, width = 4, height = 8, units = "in")
```

#### Combined (>5 BCs)
```{r}
patch13 <- tmp_ridges_15_16_d1 | tmp_ridges_15_16_d2 | tmp_ridges_15_16_d3 | tmp_ridges_15_16_d4
patch13
```

```{r}
ggsave(file="plots/combined/Lib15.16.1BCs.perfects.dose.response.ridges.png", plot=patch13,
       dpi=600, width = 12, height = 6, units = "in")
```

```{r}
patch14 <- (perfects_15_16_1BCs_binned_plot / perfects_15_16_1BCsdr_plot) | (tmp_ridges_15_16_d1 | tmp_ridges_15_16_d2 | tmp_ridges_15_16_d3 | tmp_ridges_15_16_d4)
patch14
```

```{r}
ggsave(file="plots/combined/Lib15.16.1BCs.perfects.dose.response.pctsim.vs.fit.ridges.png",
       plot=patch14,
       dpi=600, width = 20, height = 12, units = "in")
```

## Phylogenetic Trees

**This section uses the `library(ggtree)` and `library(castor)` packages.**

<font color="red">THIS SECTION NEEDS TO BE UPDATED TO GENERATE NEW ALIGNED TREE FILE</font>

First, we need to subset the "ID", "PctIdentEcoli", "TaxID", and "Sequence", values from the `perfects15_tree_5BCs` object to generate a Newick-formatted phylogenetic tree based on unique perfects mutIDs recovered from the 5BCs dataset.
```{r eval=FALSE}
# # Subset desired columns from "perfects15_tree_5BCs" object
# perfects15_tree_5BCs_IDs <- perfects_15_16_1BCs_tree[, c("mutID", "PctIdentEcoli", "TaxID", "Sequence")]
# 
# # Write these same columns to a .csv file for use outside of RStudio
# write.table(perfects_15_16_1BCs_tree[, c("mutID", "PctIdentEcoli", "TaxID", "Sequence")],
#             file = "OUTPUT/tree_build/Lib15.perfects.5BCs.final.ID.list.csv", 
#             sep = ",", row.names = F,quote=F,col.names = T)
```

We can also create a FASTA file containing the mutID and its associated protein sequence for alignment
```{r eval=FALSE, results='hide'}
# # Create the sequences in FASTA format
# perfects15_tree_5BCs_fasta_content <- paste(">", perfects15_tree_5BCs$ID, "\n", perfects15_tree_5BCs$Sequence, "\n", sep = "", collapse = "")
# 
# # Define the file path in the working directory
# perfects15_tree_5BCs_fasta_path <- file.path(getwd(), "OUTPUT/tree_build/perfects15.tree.5BCs.fasta")
# 
# # Write the FASTA content to the file
# writeLines(perfects15_tree_5BCs_fasta_content, con = perfects15_tree_5BCs_fasta_path)
```

<font color="red">Use Python to generate Newick formatted tree from the FASTA file</font>

### Tree File
Import the newick tree file based on the sequence alignment of perfects derived from Lib15 with a minimum of 5 BCs:
```{r}
Alltree15 <- read.tree("OUTPUT/perfects_tree_Lib15_5BCs_aligned.tree")   # newick format
Alltree15
```

Extract the tip labels from the newick tree file to match with NCBI taxonomy for downstream plotting:
```{r}
# Extract tip labels from Alltree15
Alltree15_tip_labels <- Alltree15$tip.label

# Create a new data frame with unique tip labels
Alltree15_tip_labels_df <- data.frame(tip.label = unique(Alltree15_tip_labels))

# Print the first few rows of the new data frame
head(Alltree15_tip_labels_df)
```

Match each tip.label ID in `Alltree15` with it's associated TaxID from `orginfo` dataframe:
```{r}
# Rename column "tip.label" to "ID"
colnames(Alltree15_tip_labels_df) <- c("ID")

# Merge orginfo with Alltree15_tip_labels_df based on the shared ID
Alltree15_taxa <- merge(Alltree15_tip_labels_df, orginfo, by = "ID", all.x = TRUE)

# Print the first few rows of the merged data frame
head(Alltree15_taxa)
```

### NCBI Taxonomy

Import the full up-to-date NCBI taxonomy dataset containing 2,580,388 unique TaxID.
```{r}
# Import updated NCBI taxonomy mapping file
ncbi_taxa = read.csv("OUTPUT/taxonomy/all.ncbi.taxa.lineage.csv", head=TRUE)  # read csv file

# Convert TaxID column from chr to int
ncbi_taxa$TaxID <- as.integer(ncbi_taxa$TaxID)

# Print the first few rows of the NCBI taxonomy data frame
head(ncbi_taxa)
```

```{r}
# Merge the NCBI taxonomy columns to Alltree15_taxa based on shared TaxID
Alltree15_taxa_merged <- Alltree15_taxa
Alltree15_taxa_merged$NCBI.name <- NA
Alltree15_taxa_merged$NCBI.superkingdom <- NA
Alltree15_taxa_merged$NCBI.phylum <- NA
Alltree15_taxa_merged$NCBI.class <- NA
Alltree15_taxa_merged$NCBI.order <- NA
Alltree15_taxa_merged$NCBI.family <- NA
Alltree15_taxa_merged$NCBI.genus <- NA
Alltree15_taxa_merged$NCBI.species <- NA

# NCBI.name
Alltree15_taxa_merged$NCBI.name[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID] <- ncbi_taxa$NCBI.name[match(Alltree15_taxa_merged$TaxID[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID], ncbi_taxa$TaxID)]

# NCBI.superkingdom
Alltree15_taxa_merged$NCBI.superkingdom[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID] <- ncbi_taxa$NCBI.superkingdom[match(Alltree15_taxa_merged$TaxID[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID], ncbi_taxa$TaxID)]

# NCBI.phylum
Alltree15_taxa_merged$NCBI.phylum[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID] <- ncbi_taxa$NCBI.phylum[match(Alltree15_taxa_merged$TaxID[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID], ncbi_taxa$TaxID)]

# NCBI.class
Alltree15_taxa_merged$NCBI.class[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID] <- ncbi_taxa$NCBI.class[match(Alltree15_taxa_merged$TaxID[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID], ncbi_taxa$TaxID)]

# NCBI.order
Alltree15_taxa_merged$NCBI.order[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID] <- ncbi_taxa$NCBI.order[match(Alltree15_taxa_merged$TaxID[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID], ncbi_taxa$TaxID)]

# NCBI.family
Alltree15_taxa_merged$NCBI.family[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID] <- ncbi_taxa$NCBI.family[match(Alltree15_taxa_merged$TaxID[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID], ncbi_taxa$TaxID)]

# NCBI.family
Alltree15_taxa_merged$NCBI.genus[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID] <- ncbi_taxa$NCBI.genus[match(Alltree15_taxa_merged$TaxID[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID], ncbi_taxa$TaxID)]

# NCBI.family
Alltree15_taxa_merged$NCBI.species[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID] <- ncbi_taxa$NCBI.species[match(Alltree15_taxa_merged$TaxID[Alltree15_taxa_merged$TaxID %in% ncbi_taxa$TaxID], ncbi_taxa$TaxID)]
```

```{r}
# Remove rows with Unclassified. in NCBI.phylum column
Alltree15_taxa_merged <- subset(Alltree15_taxa_merged, Taxa1 != "Unclassified.")

# Remove rows with NA in NCBI.phylum column
Alltree15_taxa_merged <- Alltree15_taxa_merged[!is.na(Alltree15_taxa_merged$NCBI.phylum) & Alltree15_taxa_merged$NCBI.phylum != "NA", ]

# Print the first few rows of the Alltree15_taxa_merged data frame
head(Alltree15_taxa_merged)
```

```{r}
# Replace the value in "NCBI.phylum" column with the value from "NCBI.class" if "NCBI.phylum" is "Pseudomonadota"
Alltree15_taxa_merged$NCBI.phylum <- ifelse(Alltree15_taxa_merged$NCBI.phylum == "Pseudomonadota", Alltree15_taxa_merged$NCBI.class, Alltree15_taxa_merged$NCBI.phylum)

# Print the first few rows of the Alltree15_taxa_merged data frame
head(Alltree15_taxa_merged)
```

### DHFR Diversity Trees

Plot a circular phylogenetic tree with color-scale based on phylogenetic distance between each DHFR homolog relative to the E. coli DHFR gene.
```{r}
phylotree_NCBI_ecoli_ident <- ggtree(Alltree15, layout="circular", branch.length="none") %<+% 
  Alltree15_taxa_merged + 
  aes(color=PctIdentEcoli*100) +
  geom_tippoint(aes(color=PctIdentEcoli*100), size=1, alpha=0.8) +
  geom_tiplab2(aes(color=PctIdentEcoli*100, label=NCBI.name, angle=angle), size=1) +
  theme(legend.position="left") + 
  scale_colour_gradient2("Sequence\nIdentity (%)", low="blue", mid="green", high="red",
                         midpoint=(100+min(Alltree15_taxa_merged$PctIdentEcoli)*100)/2)

phylotree_NCBI_ecoli_ident
```

```{r echo=FALSE}
ggsave(file="plots/trees/Lib15.FastTree.5BCs.perfects.NCBI.ecoli.pctident.names.png", plot=phylotree_NCBI_ecoli_ident,
       dpi=600, width = 12, height = 7.5, units = "in")
```

The following section builds on the initial DHFR phylogenetic tree and adds the NCBI taxonomic lineages as an outer ring to display the breadth of sequence diversity in the 1,536-DHFR designed library. However, this tree only contains 852 unique branch tips (55% of full library diversity) and does not contain any Eukaryota included in the full library design.
```{r}
# Generate distinct colors for each unique value in the "NCBI.phylum" column
distinct_colors_ncbi <- rainbow(length(unique(Alltree15_taxa_merged$NCBI.phylum)))

# Reverse the order of colors
#distinct_colors_ncbi <- rev(distinct_colors_ncbi)

# Create a new column "NCBI.phylum_colors" and assign colors based on the unique values in "NCBI.phylum"
Alltree15_taxa_merged <- Alltree15_taxa_merged %>%
  mutate(NCBI.phylum_colors = distinct_colors_ncbi[as.integer(factor(NCBI.phylum))])

#Establish color scheme for plotting
NCBIphyloColor <- Alltree15_taxa_merged %>%
  select(c("NCBI.phylum", "NCBI.phylum_colors")) %>%
  distinct()
NCBIphyloColor <- NCBIphyloColor[order(NCBIphyloColor$NCBI.phylum, decreasing=FALSE),]

# List phylum in alphabetical order for legend and plotting
Alltree15_taxa_merged$NCBI.phylum <- factor(Alltree15_taxa_merged$NCBI.phylum, levels=NCBIphyloColor$NCBI.phylum)
```

Build the initial DHFR tree with color-scale based on phylogenetic distance between each DHFR homolog relative to the E. coli DHFR gene and add an additional ring representing taxonomic lineages at the Phylum-level. Note that the phylum "Pseudomonadota" has been replaced with it's associated classes ("Alphaproteobacteria", "Betaproteobacteria", etc.). This tree includes Archaea (Euryarchaeota) and dsDNA Viruses (Uroviricota), but no Eukaryota from the original 1,536-DHFR library.
```{r}
phylotree_NCBI_ecoli_taxa_p1 <- ggtree(Alltree15, layout="circular", branch.length="none") %<+% 
  Alltree15_taxa_merged + 
  aes(color=PctIdentEcoli*100) +
  geom_tippoint(aes(color=PctIdentEcoli*100), size=1, alpha=0.8) +
  theme(legend.position="left") + 
  scale_colour_gradient2("Sequence\nIdentity (%)", low="blue", mid="green", high="red",
                         midpoint=(100+min(Alltree15_taxa_merged$PctIdentEcoli)*100)/2)

phylotree_NCBI_ecoli_taxa_p2 <- phylotree_NCBI_ecoli_taxa_p1 +
  new_scale_fill() +
  geom_fruit(
    geom=geom_tile,
#    mapping=aes(fill=NCBI.phylum_colors),
    mapping=aes(fill=NCBI.phylum),
    width=4,
    offset=0.1
  ) +
  scale_fill_manual(
    name="Phylum",
    values=NCBIphyloColor$NCBI.phylum_colors,
    guide=guide_legend(keywidth=0.3, keyheight=0.3, ncol=1)
  ) +
  theme(
    legend.title=element_text(size=10), 
           legend.text=element_text(size=8),
           legend.spacing.y = unit(0.2, "cm")
  )

phylotree_NCBI_ecoli_taxa_p2
```

```{r echo=FALSE}
ggsave(file="plots/trees/Lib15.FastTree.5BCs.perfects.NCBI.ecoli.pctident.phylum.ring.png", plot=phylotree_NCBI_ecoli_taxa_p2,
       dpi=600, width = 12, height = 7.5, units = "in")
```

Re-build the phylogenetic tree but color the branches by the NCBI phylum-level taxonomy (instead of by pctIdent E. coli). Leave the phylum name labels on the tree as reference.
```{r}
phylotree_NCBI_ecoli_taxa_names_p1 <- ggtree(Alltree15, layout="circular", branch.length="none") %<+%
  Alltree15_taxa_merged + 
  aes(color=NCBI.phylum) +
  geom_tippoint(aes(color=NCBI.phylum), size=1, alpha=0.8) +
  geom_tiplab2(aes(color=NCBI.phylum, label=NCBI.phylum, angle=angle), size=1)

#p13NCBI_15taxa2

phylotree_NCBI_ecoli_taxa_names_p2 <- phylotree_NCBI_ecoli_taxa_names_p1 +
  geom_tippoint(
    mapping=aes(colour=NCBI.phylum),
    size=1.5,
    stroke=0,
    alpha=0.4
  ) +
  scale_colour_manual(
    name="Phylum",
    values=NCBIphyloColor$NCBI.phylum_colors,
    guide=guide_legend(keywidth=0.3,
                            keyheight=0.3,
                            ncol=1,
                            override.aes=list(size=2,alpha=1),
                            order=1)
  ) +
  theme(
    legend.title=element_text(size=12),
         legend.text=element_text(size=10),
         legend.spacing.y = unit(0.1, "cm")
  )

phylotree_NCBI_ecoli_taxa_names_p2
```

```{r echo=FALSE}
ggsave(file="plots/trees/Lib15.FastTree.5BCs.perfects.NCBI.phylum.names.png", plot=phylotree_NCBI_ecoli_taxa_names_p2,
       dpi=600, width = 12, height = 7.5, units = "in")
```

### Fitness Trees

**Library 15**

Add fitness scores to the `Alltree15_taxa_merged` object prior to plotting
```{r}
Alltree15_taxa_merged <- Alltree15_taxa_merged %>%
  left_join(perfects_15_16_1BCs_tree %>% select(ID, fitD05D03, fitD06D03, fitD07D03, fitD08D03, fitD09D03, fitD10D03, fitD11D03), by = "ID")
```

#### Complementation Tree
Show the minimum and maximum fitness values between D05 (M9 no supp) vs. D03 (M9 full supp) dataset:
```{r class.output="goodCode"}
min(Alltree15_taxa_merged$fitD05D03,na.rm=T)
max(Alltree15_taxa_merged$fitD05D03,na.rm=T)
```

Plot a circular phylogenetic tree for complementation with color-scale based on fitness values between D05 vs. D03 for each DHFR homolog:
```{r}
tree_perfects15_1BCs_0tmp_fitness <- ggtree(Alltree15, layout="circular", branch.length="none") %<+%
  Alltree15_taxa_merged +
  aes(color=fitD05D03) +
  geom_tippoint(aes(color=fitD05D03), size=1, alpha=0.8) +
  #geom_tiplab2(aes(color=fitD05D03, label=Source, angle=angle), size=1) +
  theme(legend.position="left") + 
  ggtitle("Library 15 Median Fitness at Complementation") +
  scale_colour_gradient2("fitness",
                         low="black", 
                         mid="gold",
                         high="red",
                         na.value="gray",
                         limit = c(-7,1))

tree_perfects15_1BCs_0tmp_fitness_phylum_ring <- tree_perfects15_1BCs_0tmp_fitness +
  new_scale_fill() +
  geom_fruit(
    geom=geom_tile,
    mapping=aes(fill=NCBI.phylum),
    width=4,
    offset=0.1
  ) +
  scale_fill_manual(
    name="Phylum",
    values=NCBIphyloColor$NCBI.phylum_colors,
    guide=guide_legend(keywidth=0.3, keyheight=0.3, ncol=1)
  ) +
  theme(
    legend.title=element_text(size=10), 
           legend.text=element_text(size=8),
           legend.spacing.y = unit(0.2, "cm")
  )

tree_perfects15_1BCs_0tmp_fitness_phylum_ring
```

```{r echo=FALSE}
ggsave(file="plots/trees/Lib15.FastTree.1BCs.perfects.fitD05D03.COMPLEMENTATION.phylum.ring.png",
       plot=tree_perfects15_1BCs_0tmp_fitness_phylum_ring,
       dpi=600, width = 12, height = 7.5, units = "in")
```

#### D11 vs. D03 Tree Plot
Show the minimum and maximum fitness values between D11 (200 mg/uL Day 1) vs. D03 (M9 no supp.) in the dataset:
```{r class.output="goodCode"}
min(Alltree15_taxa_merged$fitD11D03,na.rm=T)
max(Alltree15_taxa_merged$fitD11D03,na.rm=T)
```

Plot a circular phylogenetic tree with color-scale based on fitness values between D10 vs. D03 for each DHFR homolog:
```{r}
tree_perfects15_1BCs_50tmp_fitness <- ggtree(Alltree15, layout="circular", branch.length="none") %<+%
  Alltree15_taxa_merged +
  aes(color=fitD10D03) +
  geom_tippoint(aes(color=fitD10D03), size=1, alpha=0.8) +
  #geom_tiplab2(aes(color=fitD05D03, label=Source, angle=angle), size=1) +
  theme(legend.position="left") + 
  ggtitle("Library 15 Median Fitness at 50-TMP") +
  scale_colour_gradient2("fitness",
                         low="black", 
                         mid="gold",
                         high="red",
                         na.value="gray",
                         limit = c(-7,1))

tree_perfects15_1BCs_50tmp_fitness_phylum_ring <- tree_perfects15_1BCs_50tmp_fitness +
  new_scale_fill() +
  geom_fruit(
    geom=geom_tile,
    mapping=aes(fill=NCBI.phylum),
    width=4,
    offset=0.1
  ) +
  scale_fill_manual(
    name="Phylum",
    values=NCBIphyloColor$NCBI.phylum_colors,
    guide=guide_legend(keywidth=0.3, keyheight=0.3, ncol=1)
  ) +
  theme(
    legend.title=element_text(size=10),
           legend.text=element_text(size=8),
           legend.spacing.y = unit(0.2, "cm")
  )

tree_perfects15_1BCs_50tmp_fitness_phylum_ring
```

```{r echo=FALSE}
ggsave(file="plots/trees/Lib15.FastTree.1BCs.perfects.fitD10D03.50.tmp.phylum.ring.png",
       plot=tree_perfects15_1BCs_50tmp_fitness_phylum_ring,
       dpi=600, width = 12, height = 7.5, units = "in")
```

```{r}
patch21<- (tree_perfects15_1BCs_0tmp_fitness_phylum_ring | tree_perfects15_1BCs_50tmp_fitness_phylum_ring)
patch21
```

```{r echo=FALSE}
ggsave(file="plots/trees/Lib15.FastTree.Median.Fitness.Complementation.50mg.png", plot=patch21,
       dpi=600, width = 14, height = 12, units = "in")
```

# Fitness vs Distance

<font color="blue">**This section is based on the R file: "R_change_in_fitness_vs_distance.R".**</font> It determines how fitness changes with mutation distance.

## Filter Data

Grab only the BCs with up to 5 mutations (also need to ensure it has greater than 0 mutations since some BCs have negative values):
```{r}
BCs5_15 <- BCs15_map %>%
  filter(mutations >= 0 & mutations <= 5) %>%
  left_join(mutIDinfo15 %>% select(mutID), by="mutID") %>%
  select(BC,IDalign,mutID,mutations,D05D03fc)
```

Retain only the homologs with good data:
```{r}
fitness_distance_15 <- perfects_15_16_1BCs_tree %>%
  select(ID,fitD05D03) %>%
  dplyr::rename(IDalign=ID)
```

Determine median and sd for 1 mutation:
```{r}
fitness_distance_15 <- BCs5_15 %>%
    filter(mutations==1) %>%
    group_by(IDalign) %>%
    summarise(mut1fit=median(D05D03fc),
              mut1sd=sd(D05D03fc),
              num1points=n()) %>%
    right_join(fitness_distance_15,by="IDalign")
```

Determine median and sd for 2 mutation:
```{r}
fitness_distance_15 <-  BCs5_15 %>%
  filter(mutations==2) %>%
  group_by(IDalign) %>%
  summarise(mut2fit=median(D05D03fc),
            mut2sd=sd(D05D03fc),
            num2points=n()) %>%
  right_join(fitness_distance_15,by="IDalign") 
```

Determine median and sd for 3 mutations:
```{r}
fitness_distance_15 <-  BCs5_15 %>%
  filter(mutations==3) %>%
  group_by(IDalign) %>%
  summarise(mut3fit=median(D05D03fc),
            mut3sd=sd(D05D03fc),
            num3points=n()) %>%
  right_join(fitness_distance_15,by="IDalign")
```

Determine median and sd for 4 mutations:
```{r}
fitness_distance_15 <-  BCs5_15 %>%
  filter(mutations==4) %>%
  group_by(IDalign) %>%
  summarise(mut4fit=median(D05D03fc),
            mut4sd=sd(D05D03fc),
            num4points=n()) %>%
  right_join(fitness_distance_15,by="IDalign")
```

Determine median and sd for 5 mutations:
```{r}
fitness_distance_15 <-  BCs5_15 %>%
  filter(mutations==5) %>%
  group_by(IDalign) %>%
  summarise(mut5fit=median(D05D03fc),
            mut5sd=sd(D05D03fc),
            num5points=n()) %>%
  right_join(fitness_distance_15,by="IDalign")
```

Determine change in fitness:
```{r}
fitness_distance_nu_15 <- fitness_distance_15 %>%
  mutate(mut1fitn=(mut1fit-fitD05D03),
         mut2fitn=(mut2fit-fitD05D03),
         mut3fitn=(mut3fit-fitD05D03),
         mut4fitn=(mut4fit-fitD05D03),
         mut5fitn=(mut5fit-fitD05D03),
         mut0fitn=0)
```

Melt data on number of mutations:
```{r}
fitness_distance_m_15 <- fitness_distance_nu_15 %>%
  select(IDalign,fitD05D03,mut0fitn,mut1fitn,mut2fitn,mut3fitn,mut4fitn,mut5fitn) %>%
  gather(mutations,fitness,mut0fitn,mut1fitn,mut2fitn,mut3fitn,mut4fitn,mut5fitn)
```

Replace names with numbers:
```{r}
fitness_distance_m_15$mutations[which(fitness_distance_m_15$mutations=="mut0fitn")] <- as.numeric(0)
fitness_distance_m_15$mutations[which(fitness_distance_m_15$mutations=="mut1fitn")] <- as.numeric(1)
fitness_distance_m_15$mutations[which(fitness_distance_m_15$mutations=="mut2fitn")] <- as.numeric(2)
fitness_distance_m_15$mutations[which(fitness_distance_m_15$mutations=="mut3fitn")] <- as.numeric(3)
fitness_distance_m_15$mutations[which(fitness_distance_m_15$mutations=="mut4fitn")] <- as.numeric(4)
fitness_distance_m_15$mutations[which(fitness_distance_m_15$mutations=="mut5fitn")] <- as.numeric(5)
```

Remove those with NA fitness:
```{r}
fitness_distance_m_15 <- fitness_distance_m_15 %>%
  filter(!is.na(fitness))
```

## Fitness vs. Distance Plots

The first plot version uses traces to display results:
```{r}
lib15_fit_dist_5muts_line <- ggplot(fitness_distance_m_15, aes(x=mutations, y=fitness, group=IDalign, color=IDalign)) +
  geom_point() +
  geom_line() +
  xlab("Distance from homolog (a.a.)") +
  ylab("Change in fitness relative to homolog") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none")

lib15_fit_dist_5muts_line
```

```{r echo=FALSE}
ggsave(file="plots/FitvDist/Lib15.fitness.vs.distance.all.traces.5aa.muts.scatter.png", plot=lib15_fit_dist_5muts_line,
       dpi=600, width = 8, height = 6, units = "in")
```

The second plot version uses a boxplot to display results:
```{r}
lib15_fit_dist_5muts_boxplot <- ggplot(fitness_distance_m_15, aes(x=mutations, y=fitness)) +
  geom_boxplot(color="black", fill="#0072B2", alpha=0.8) +
  xlab("Distance from homolog (a.a.)") +
  ylab("Change in fitness relative to homolog") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-10,10))

lib15_fit_dist_5muts_boxplot
```

```{r echo=FALSE}
ggsave(file="plots/FitvDist/Lib15.fitness.vs.distance.all.traces.5aa.muts.boxplot.png", plot=lib15_fit_dist_5muts_boxplot,
       dpi=600, width = 8, height = 6, units = "in")
```

Calculate Spearman correlations between fitness and distance from homolog:
```{r, warning=FALSE, class.output="goodCode"}
# Calculate Spearman coefficient:
cor(as.numeric(fitness_distance_m_15$mutations),fitness_distance_m_15$fitness,
    method=c("spearman"))

# Run correlation test:
cor.test(as.numeric(fitness_distance_m_15$mutations),fitness_distance_m_15$fitness,
         method=c("spearman"))
```

# Plot Mutants
<font color="blue">**This section is based on the R file: "R_plot_all_mutants.R".**</font> It describes how to plot all mutants per homolog independently.

Determine the number of mutants per homolog:
```{r}
# Lib15
mutantsperhomolog15 <- mutIDinfo15 %>%
  filter(mutations != 0) %>%
  select(mutID,IDalign) %>%
  distinct() %>%
  group_by(IDalign) %>%
  summarise(count=n())

# Lib16
mutantsperhomolog16 <- mutIDinfo16 %>%
  filter(mutations != 0) %>%
  select(mutID,IDalign) %>%
  distinct() %>%
  group_by(IDalign) %>%
  summarise(count=n())
```

Add a column and label each ID for the library it comes from to keep track of the data source:
```{r}
# Lib15
mutantsperhomolog15$lib <- "Lib15"

# Lib16
mutantsperhomolog16$lib <- "Lib16"
```

Combine both library datasets for plotting:
```{r}
mutantsperhomolog_15_16 <- bind_rows(mutantsperhomolog15, mutantsperhomolog16, .id = "library")
```

Plot the mutant count for both libraries:
```{r}
mutantsperhomolog_15_16_plot <- ggplot(mutantsperhomolog_15_16, aes(x = library, y = count, fill = library)) +
  geom_violin(color = "black", alpha = 0.75) +
  xlab("Library") +
  ylab("Mutants per homolog") +
  theme_minimal() +
  theme(
    axis.line = element_line(colour = 'black', size = 0.5),
    axis.ticks = element_line(colour = "black", size = 0.5),
    plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 10),
    axis.title.x = element_blank(),
    axis.title.y = element_text(size = 12),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 600)) +
  scale_fill_manual(values = c("#0072B2", "#E69F00")) +
  scale_x_discrete(labels = c("Library 15", "Library 16"))

mutantsperhomolog_15_16_plot
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.mutants.per.homolog.violin.png", plot=mutantsperhomolog_15_16_plot,
       dpi=600, width = 6, height = 6, units = "in")
```

Calculate the median mutant counts for each distinct homolog:
```{r class.output="goodCode"}
#Lib15

#Median mutant count per homolog
median(mutantsperhomolog15$count)

#Lib16

#Median mutant count per homolog
median(mutantsperhomolog16$count)
```

Calculate the mean mutant counts for each distinct homolog:
```{r}
#Lib15

#Mean mutant count per homolog
mean(mutantsperhomolog15$count)

#Lib16

#Mean mutant count per homolog
mean(mutantsperhomolog16$count)
```

<font color="green">If both measures (mean and median) are considerably different, this indicates that the data are skewed (i.e. they are far from being normally distributed) and the **MEDIAN** generally gives a more appropriate idea of the data distribution.</font>

## Top 10 Mutants

Arrange by biotin enrich score
```{r}
#Lib15
mutantsperhomolog15 <- mutantsperhomolog15 %>%
  arrange(-count)

#Lib16
mutantsperhomolog16 <- mutantsperhomolog16 %>%
  arrange(-count)
```

<font color="green">**Select the top 10 mutants based on greatest count values**</font>
```{r echo=FALSE}
#Lib15

# Display dataframe with kable formatting
mutantsperhomolog15_10.count <- head(mutantsperhomolog15, 10)

knitr::kable(mutantsperhomolog15_10.count,
  col.names = c('ID Align', 'Count', 'Library'),
  align = "lll",
  format.args = list(big.mark = ","))

#Lib16

# Display dataframe with kable formatting
mutantsperhomolog16_10.count <- head(mutantsperhomolog16, 10)

knitr::kable(mutantsperhomolog16_10.count,
  col.names = c('ID Align', 'Count', 'Library'),
  align = "lll",
  format.args = list(big.mark = ","))
```

Make keys for plotting:
```{r}
#Lib15

mutantsperhomolog15$key <- 1:length(mutantsperhomolog15$count)

mutantsperhomolog15_10 <- mutantsperhomolog15 %>%
  filter(key<11)

mutantsdist15 <- mutIDinfo15 %>%
  filter(IDalign %in% mutantsperhomolog15_10$IDalign) %>%
  filter(mutations>-1)

#Lib16

mutantsperhomolog16$key <- 1:length(mutantsperhomolog16$count)

mutantsperhomolog16_10 <- mutantsperhomolog16 %>%
  filter(key<11)

mutantsdist16 <- mutIDinfo16 %>%
  filter(IDalign %in% mutantsperhomolog16_10$IDalign) %>%
  filter(mutations>-1)
```

Plot the top 10 mutants with mean and SD based on total counts:
```{r}
Lib15_top10_muts <- ggplot(mutantsdist15, aes(x=IDalign, y=mutations))+
  geom_boxplot(color="black", fill="#0072B2", alpha=0.75) +
  ggtitle("Library 15") +
  xlab("") +
  ylab("Distribution of Mutants at Distance (a.a.)") +
  coord_flip() +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none")

Lib15_top10_muts
```

```{r}
Lib16_top10_muts <- ggplot(mutantsdist16, aes(x=IDalign, y=mutations))+
  geom_boxplot(color="black", fill="#E69F00") +
  ggtitle("Library 16") +
  xlab("") +
  ylab("Distribution of Mutants at Distance (a.a.)") +
  coord_flip() +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none")

Lib16_top10_muts
```

```{r}
patch23<- (Lib15_top10_muts | Lib16_top10_muts)
patch23
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.mutants.at.distance.top10.png", plot=patch23,
       dpi=600, width = 16, height = 12, units = "in")
```

Summarize the total number of reads associated with all BCs:

<font color="red">**Does this value include the original designed homologs AND all mutants, or just the total number of mutants?**</font>
```{r class.output="goodCode"}
#Lib15
BCinfo.read.count15 <- sum(BCinfo15$reads)

format(BCinfo.read.count15, big.mark = ",")

#Lib16
BCinfo.read.count16 <- sum(BCinfo16$reads)

format(BCinfo.read.count16, big.mark = ",")
```

## Mutant Fitness

First, create a `mutant` object that filters the `mutIDinfo` object to retain mutIDs only if they have > 0 mutations:
```{r}
# Lib15
mutants15 <- mutIDinfo15 %>%
  filter(mutations!=0) %>%
  dplyr::rename(ID = IDalign)

# Lib16
mutants16 <- mutIDinfo16 %>%
  filter(mutations!=0) %>%
  dplyr::rename(ID = IDalign)
```

Add the actual pct_ident to E. coli score from the `orginfo` object
```{r}
# Lib15
mutants15 <- merge(mutants15, orginfo[, c("ID", "PctIdentEcoli")], by = "ID", all.x = TRUE)

# Lib16
mutants16 <- merge(mutants16, orginfo[, c("ID", "PctIdentEcoli")], by = "ID", all.x = TRUE)
```

**Count the number of unique mutIDs:**
```{r class.output="goodCode"}
# Lib15
mutants15.count <- length(unique(mutants15$mutID))
format(mutants15.count, big.mark = ",")

# Lib16
mutants16.count <- length(unique(mutants16$mutID))
format(mutants16.count, big.mark = ",")
```

**Now, count the number of unique IDaligns that each mutID is associated with:**
```{r class.output="goodCode"}
# Lib15
mutants15.ID.count <- length(unique(mutants15$ID))
format(mutants15.ID.count, big.mark = ",")

# Lib16
mutants16.ID.count <- length(unique(mutants16$ID))
format(mutants16.ID.count, big.mark = ",")
```

Bin mutants by the percent similarity to their designed homologs:
```{r}
#Lib15
mutants15$identbins <- cut(mutants15$pct_ident,
                         breaks = seq(0,1.005,1/100),
                         labels=as.character(seq(0.005,0.995,1/100)))

#Lib16
mutants16$identbins <- cut(mutants16$pct_ident,
                         breaks = seq(0,1.005,1/100),
                         labels=as.character(seq(0.005,0.995,1/100)))
```

Determine the **minimum** percent similarity mutant in the dataset (most different from designed homolog):
```{r class.output="goodCode"}
#Lib15
min(mutants15$pct_ident)

#Lib16
min(mutants16$pct_ident)
```

Determine the **maximum** percent similarity mutant in the dataset (most similar to designed homolog):
```{r class.output="goodCode"}
#Lib15
max(mutants15$pct_ident)

#Lib16
max(mutants16$pct_ident)
```

Calculate the total number of mutants with at least 1 barcode recovered:
```{r class.output="goodCode"}
#Lib15
mut15.1BCs.count <- nrow(mutants15 %>% filter(numprunedBCs >= 1))
format(mut15.1BCs.count, big.mark = ",")

#Lib16
mut16.1BCs.count <- nrow(mutants16 %>% filter(numprunedBCs >= 1))
format(mut16.1BCs.count, big.mark = ",")
```

### Histogram Plots

Plot these mutants (>1 BCs recovered) with histograms:
```{r warning=FALSE}
#Lib15
mutant_hist15_plot <- mutants15 %>%
  filter(numprunedBCs >= 1) %>%
  ggplot(aes(x=pct_ident, y=fitD05D03)) +
  labs(x = "Fractional Sequence Identity", y ="Fitness",color="") +
  geom_point(alpha=0.3,color='#0072B2') +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none")

mutant_hist15_plot2 <- ggMarginal(mutant_hist15_plot, type = "histogram", fill = "#0072B2", bins=40)
mutant_hist15_plot2

#Lib16
mutant_hist16_plot <- mutants16 %>%
  filter(numprunedBCs >= 1) %>%
  ggplot(aes(x=pct_ident, y=fitD12D04)) +
  labs(x = "Fractional Sequence Identity", y ="Fitness",color="") +
  geom_point(alpha=0.3,color='#E69F00') +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none")

mutant_hist16_plot2 <- ggMarginal(mutant_hist16_plot, type = "histogram", fill = "#E69F00", bins=40)
mutant_hist16_plot2
```

```{r echo=FALSE}
#Lib15
ggsave(file="plots/mutants/Lib15.mutants.pctsimhomo.fitD05D03.min1BCs.png", plot=mutant_hist15_plot2,
       dpi=600, width = 8, height = 6, units = "in")

#Lib16
ggsave(file="plots/mutants/Lib16.mutants.pctsimhomo.fitD05D03.min1BCs.png", plot=mutant_hist16_plot2,
       dpi=600, width = 8, height = 6, units = "in")
```

### Boxplots

Plot boxplots based on mutant percent similarity to their designed homologs for fitness between M9 (No Supp) vs. M9 (Full Supp)
```{r warning=FALSE}
#Lib15
mutant_box15_plot <- mutants15 %>%
  filter(numprunedBCs >= 1) %>%
  ggplot(aes(x=as.numeric(as.character(identbins))*100,y=fitD05D03,color=identbins)) +
  labs(x = "Sequence Identity to Homolog (%)", y ="Fitness",color="") +
  ggtitle("Lib15: Complementation") +
  geom_boxplot() +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-10,5))

mutant_box15_plot

#Lib16
mutant_box16_plot <- mutants16 %>%
  filter(numprunedBCs >= 1) %>%
  ggplot(aes(x=as.numeric(as.character(identbins))*100,y=fitD12D04,color=identbins)) +
  labs(x = "Sequence Identity to Homolog (%)", y ="Fitness",color="") +
  ggtitle("Lib16: Complementation") +
  geom_boxplot() +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-10,5))

mutant_box16_plot
```

```{r}
patch24<- (mutant_box15_plot | mutant_box16_plot)
patch24
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.mutants.by.seq.ident.min1BC.Complementation.png", plot=patch24,
       dpi=600, width = 18, height = 8, units = "in")
```

Plot boxplots based on mutant percent similarity to their designed homologs for fitness between 50 ug/ml TMP
```{r}
#Lib15
mutant_box15_50tmp <- mutants15 %>%
  filter(numprunedBCs >= 1) %>%
  ggplot(aes(x=as.numeric(as.character(identbins))*100,y=fitD10D03,color=identbins)) +
  labs(x = "Sequence Identity to Homolog (%)", y ="Fitness",color="") +
  ggtitle("Lib15: 50 TMP") +
  geom_boxplot() +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-15,10))

mutant_box15_50tmp

#Lib16
mutant_box16_50tmp <- mutants16 %>%
  filter(numprunedBCs >= 1) %>%
  ggplot(aes(x=as.numeric(as.character(identbins))*100,y=fitE05D04,color=identbins)) +
  labs(x = "Sequence Identity to Homolog (%)", y ="Fitness",color="") +
  ggtitle("Lib16: 50 TMP") +
  geom_boxplot() +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-15,10))

mutant_box16_50tmp
```

```{r}
patch25<- (mutant_box15_50tmp | mutant_box16_50tmp)
patch25
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.mutants.by.seq.ident.min1BC.50TMP.png", plot=patch25,
       dpi=600, width = 18, height = 12, units = "in")
```

Plot boxplots based on mutant percent similarity to their designed homologs for fitness between 200 ug/ml TMP
```{r}
#Lib15
mutant_box15_200tmp <- mutants15 %>%
  filter(numprunedBCs >= 1) %>%
  ggplot(aes(x=as.numeric(as.character(identbins))*100,y=fitD11D03,color=identbins)) +
  labs(x = "Sequence Identity to Homolog (%)", y ="Fitness",color="") +
  ggtitle("Lib15: 200 TMP") +
  geom_boxplot() +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-15,10))

mutant_box15_200tmp

#Lib16
mutant_box16_200tmp <- mutants16 %>%
  filter(numprunedBCs >= 1) %>%
  ggplot(aes(x=as.numeric(as.character(identbins))*100,y=fitE06D04,color=identbins)) +
  labs(x = "Sequence Identity to Homolog (%)", y ="Fitness",color="") +
  ggtitle("Lib16: 200 TMP") +
  geom_boxplot() +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none") +
  scale_y_continuous(expand = c(0, 0), limits = c(-15,10))

mutant_box16_200tmp
```

```{r}
patch26<- (mutant_box15_200tmp | mutant_box16_200tmp)
patch26
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.mutants.by.seq.ident.min1BC.200TMP.png", plot=patch26,
       dpi=600, width = 18, height = 8, units = "in")
```

Combine them all:
```{r}
patch27<- (mutant_box15_plot | mutant_box16_plot) / (mutant_box15_50tmp | mutant_box16_50tmp) / (mutant_box15_200tmp | mutant_box16_200tmp)
patch27
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.mutants.by.seq.ident.min1BC.All.Combined.png", plot=patch27,
       dpi=600, width = 12, height = 14, units = "in")
```

# Collapse Mutants
<font color="blue">**This section is based on the R file: "R_collapse_mutants.R".**</font>

## 5 AA Distance

The following code describes how to collapse mutant BCs on their designed homologs within a distance of 5 amino acids.

### Lib15

Begin by selecting all mutants within a distance of 5 AA from their designed homologs
```{r}
mut_collapse_15 <- mutants15 %>%
  filter(mutations >= 0 & mutations < 6) %>%
  group_by(ID)
```

Merge these mutants with their designed homologs (perfects >5BCs) if they have a matching "ID". Use the shared perfects mutIDs for merging and downstream library comparisons:
```{r}
# Add perfects to mut_collapse by shared columns:
mut_collapse_15 <- full_join(mut_collapse_15, perfects15)

# Subset the df to retain only relevant columns:
mut_collapse_15 <- mut_collapse_15[, c(1:36)]
```

Only retain mutIDs if the "ID" contains a designed variant (mutations == 0):
```{r}
mut_collapse_15 <- mut_collapse_15 %>%
  group_by(ID) %>%
  filter(0 %in% mutations) %>%
  ungroup()
```

Summarize the number of unique "ID" with mutations==0 (perfects) after filtering:
```{r}
mut_collapse_15.count <- mut_collapse_15 %>%
  filter(mutations == 0) %>%
  summarise(unique_rows = n_distinct(ID))

print(mut_collapse_15.count)
```

Summarize the number of unique "ID" at each mutation level:
```{r class.output="goodCode"}
mut_collapse_15.summary <- mut_collapse_15 %>%
  group_by(mutations) %>%
  summarise(unique_IDs = n_distinct(ID))

# View the summary table
print(mut_collapse_15.summary)
```

Summarize the number of collapsed homologs after filtering
```{r class.output="goodCode"}
# Count the number of unique designed homologs retained in the filtered dataset:
format(length(unique(mut_collapse_15$ID)), big.mark = ",")

# Count the number of unique "mutID" after excluding rows with mutations==0 (retains mutants only)
format(length(unique(mut_collapse_15$mutID[mut_collapse_15$mutations != 0])), big.mark = ",")

# Now, count the number of unique "mutID" (this includes designed homologs and their mutants)
format(length(unique(mut_collapse_15$mutID)), big.mark = ",")
```

#### Mutation Similarity

Next, run correlation analyses between designed homologs and their corresponding mutant versions (1, 2, 3, 4, or 5 mutations) to determine if mutations share similar fitness values with designed variants

```{r}
# Lib15

# Filter the dataframe for mutations at each level (0,1,2,3,4,5)
mutations15_0 <- subset(mut_collapse_15, mutations == 0)
mutations15_1 <- subset(mut_collapse_15, mutations == 1)
mutations15_2 <- subset(mut_collapse_15, mutations == 2)
mutations15_3 <- subset(mut_collapse_15, mutations == 3)
mutations15_4 <- subset(mut_collapse_15, mutations == 4)
mutations15_5 <- subset(mut_collapse_15, mutations == 5)

# Merge the dataframes based on shared "ID" for each mutation level against perfects
Mut0vsMut1_15 <- merge(mutations15_0, mutations15_1, by = "ID", suffixes = c("_mutations_0", "_mutations_1"))
Mut0vsMut2_15 <- merge(mutations15_0, mutations15_2, by = "ID", suffixes = c("_mutations_0", "_mutations_2"))
Mut0vsMut3_15 <- merge(mutations15_0, mutations15_3, by = "ID", suffixes = c("_mutations_0", "_mutations_3"))
Mut0vsMut4_15 <- merge(mutations15_0, mutations15_4, by = "ID", suffixes = c("_mutations_0", "_mutations_4"))
Mut0vsMut5_15 <- merge(mutations15_0, mutations15_5, by = "ID", suffixes = c("_mutations_0", "_mutations_5"))

# Subset relevant data columns and remove rows containing "NA" values
Mut0vsMut1_15 <- Mut0vsMut1_15[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_1", "fitD05D03_mutations_0", "fitD05D03_mutations_1")] %>% na.omit(Mut0vsMut1_15)
Mut0vsMut2_15 <- Mut0vsMut2_15[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_2", "fitD05D03_mutations_0", "fitD05D03_mutations_2")] %>% na.omit(Mut0vsMut2_15)
Mut0vsMut3_15 <- Mut0vsMut3_15[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_3", "fitD05D03_mutations_0", "fitD05D03_mutations_3")] %>% na.omit(Mut0vsMut3_15)
Mut0vsMut4_15 <- Mut0vsMut4_15[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_4", "fitD05D03_mutations_0", "fitD05D03_mutations_4")] %>% na.omit(Mut0vsMut4_15)
Mut0vsMut5_15 <- Mut0vsMut5_15[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_5", "fitD05D03_mutations_0", "fitD05D03_mutations_5")] %>% na.omit(Mut0vsMut5_15)

# Calculate correlation and p-value
cor_test15_Mut0vsMut1 <- cor.test(Mut0vsMut1_15$fitD05D03_mutations_0, Mut0vsMut1_15$fitD05D03_mutations_1)
cor_test15_Mut0vsMut2 <- cor.test(Mut0vsMut2_15$fitD05D03_mutations_0, Mut0vsMut2_15$fitD05D03_mutations_2)
cor_test15_Mut0vsMut3 <- cor.test(Mut0vsMut3_15$fitD05D03_mutations_0, Mut0vsMut3_15$fitD05D03_mutations_3)
cor_test15_Mut0vsMut4 <- cor.test(Mut0vsMut4_15$fitD05D03_mutations_0, Mut0vsMut4_15$fitD05D03_mutations_4)
cor_test15_Mut0vsMut5 <- cor.test(Mut0vsMut5_15$fitD05D03_mutations_0, Mut0vsMut5_15$fitD05D03_mutations_5)

cor_test15_Mut0vsMut1
cor_test15_Mut0vsMut2
cor_test15_Mut0vsMut3
cor_test15_Mut0vsMut4
cor_test15_Mut0vsMut5
```

#### Plot Correlations
```{r}
# Extract correlation value from cor_result15_Mut0vsMut1 object
cor_value_Mut0vsMut1 <- cor_test15_Mut0vsMut1$estimate
cor_value_Mut0vsMut2 <- cor_test15_Mut0vsMut2$estimate
cor_value_Mut0vsMut3 <- cor_test15_Mut0vsMut3$estimate
cor_value_Mut0vsMut4 <- cor_test15_Mut0vsMut4$estimate
cor_value_Mut0vsMut5 <- cor_test15_Mut0vsMut5$estimate


# Format p-value in scientific notation
p_value_scientific15_v1 <- format(cor_test15_Mut0vsMut1$p.value, scientific = TRUE, digits = 4)
p_value_scientific15_v2 <- format(cor_test15_Mut0vsMut2$p.value, scientific = TRUE, digits = 4)
p_value_scientific15_v3 <- format(cor_test15_Mut0vsMut3$p.value, scientific = TRUE, digits = 4)
p_value_scientific15_v4 <- format(cor_test15_Mut0vsMut4$p.value, scientific = TRUE, digits = 4)
p_value_scientific15_v5 <- format(cor_test15_Mut0vsMut5$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows15.mut0v1 <- nrow(Mut0vsMut1_15)
num_rows15.mut0v2 <- nrow(Mut0vsMut2_15)
num_rows15.mut0v3 <- nrow(Mut0vsMut3_15)
num_rows15.mut0v4 <- nrow(Mut0vsMut4_15)
num_rows15.mut0v5 <- nrow(Mut0vsMut5_15)

# Plot the correlation (Mut0vsMut1)
mut0v1_15plot <- ggplot(Mut0vsMut1_15, 
             aes(x = fitD05D03_mutations_0, y = fitD05D03_mutations_1, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD05D03 (mutations = 0)",
       y = "fitD05D03 (mutations = 1)", color="",
       title = "Lib15 Complementation (Mut=0 vs Mut=1)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut1_15$fitD05D03_mutations_0), y = min(Mut0vsMut1_15$fitD05D03_mutations_1), 
           label = paste("p-value =", p_value_scientific15_v1), hjust = 1, vjust = 0) +
  annotate("text", x = max(Mut0vsMut1_15$fitD05D03_mutations_0), y = min(Mut0vsMut1_15$fitD05D03_mutations_1),
            label = paste("Correlation =", round(cor_value_Mut0vsMut1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut1_15$fitD05D03_mutations_0), y = max(Mut0vsMut1_15$fitD05D03_mutations_1),
           label = paste("Mutants =", num_rows15.mut0v1), hjust = 0, vjust = 1.5)

mut0v1_15plot2 <- ggMarginal(mut0v1_15plot, type = "histogram", fill = "#0072B2", alpha=0.75) #add side histograms
mut0v1_15plot2

# Plot the correlation (Mut0vsMut2)
mut0v2_15plot <- ggplot(Mut0vsMut2_15, 
             aes(x = fitD05D03_mutations_0, y = fitD05D03_mutations_2, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD05D03 (mutations = 0)",
       y = "fitD05D03 (mutations = 2)", color="",
       title = "Lib15 Complementation (Mut=0 vs Mut=2)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut2_15$fitD05D03_mutations_0), y = min(Mut0vsMut2_15$fitD05D03_mutations_2), 
           label = paste("p-value =", p_value_scientific15_v2), hjust = 1, vjust = 0)+
  annotate("text", x = max(Mut0vsMut2_15$fitD05D03_mutations_0), y = min(Mut0vsMut2_15$fitD05D03_mutations_2),
            label = paste("Correlation =", round(cor_value_Mut0vsMut2, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut2_15$fitD05D03_mutations_0), y = max(Mut0vsMut2_15$fitD05D03_mutations_2),
           label = paste("Mutants =", num_rows15.mut0v2), hjust = 0, vjust = 1.5)

mut0v2_15plot2 <- ggMarginal(mut0v2_15plot, type = "histogram", fill = "#0072B2", alpha=0.75) #add side histograms
mut0v2_15plot2

# Plot the correlation (Mut0vsMut3)
mut0v3_15plot <- ggplot(Mut0vsMut3_15, 
             aes(x = fitD05D03_mutations_0, y = fitD05D03_mutations_3, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD05D03 (mutations = 0)",
       y = "fitD05D03 (mutations = 3)", color="",
       title = "Lib15 Complementation (Mut=0 vs Mut=3)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut3_15$fitD05D03_mutations_0), y = min(Mut0vsMut3_15$fitD05D03_mutations_3), 
           label = paste("p-value =", p_value_scientific15_v3), hjust = 1, vjust = 0)+
  annotate("text", x = max(Mut0vsMut3_15$fitD05D03_mutations_0), y = min(Mut0vsMut3_15$fitD05D03_mutations_3),
            label = paste("Correlation =", round(cor_value_Mut0vsMut3, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut3_15$fitD05D03_mutations_0), y = max(Mut0vsMut3_15$fitD05D03_mutations_3),
           label = paste("Mutants =", num_rows15.mut0v3), hjust = 0, vjust = 1.5)

mut0v3_15plot2 <- ggMarginal(mut0v3_15plot, type = "histogram", fill = "#0072B2", alpha=0.75) #add side histograms
mut0v3_15plot2

# Plot the correlation (Mut0vsMut4)
mut0v4_15plot <- ggplot(Mut0vsMut4_15, 
             aes(x = fitD05D03_mutations_0, y = fitD05D03_mutations_4, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD05D03 (mutations = 0)",
       y = "fitD05D03 (mutations = 4)", color="",
       title = "Lib15 Complementation (Mut=0 vs Mut=4)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut4_15$fitD05D03_mutations_0), y = min(Mut0vsMut4_15$fitD05D03_mutations_4), 
           label = paste("p-value =", p_value_scientific15_v4), hjust = 1, vjust = 0)+
  annotate("text", x = max(Mut0vsMut4_15$fitD05D03_mutations_0), y = min(Mut0vsMut4_15$fitD05D03_mutations_4),
            label = paste("Correlation =", round(cor_value_Mut0vsMut4, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut4_15$fitD05D03_mutations_0), y = max(Mut0vsMut4_15$fitD05D03_mutations_4),
           label = paste("Mutants =", num_rows15.mut0v4), hjust = 0, vjust = 1.5)

mut0v4_15plot2 <- ggMarginal(mut0v4_15plot, type = "histogram", fill = "#0072B2", alpha=0.75) #add side histograms
mut0v4_15plot2

# Plot the correlation (Mut0vsMut5)
mut0v5_15plot <- ggplot(Mut0vsMut5_15, 
             aes(x = fitD05D03_mutations_0, y = fitD05D03_mutations_5, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD05D03 (mutations = 0)",
       y = "fitD05D03 (mutations = 5)", color="",
       title = "Lib15 Complementation (Mut=0 vs Mut=5)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut5_15$fitD05D03_mutations_0), y = min(Mut0vsMut5_15$fitD05D03_mutations_5), 
           label = paste("p-value =", p_value_scientific15_v5), hjust = 1, vjust = 0)+
  annotate("text", x = max(Mut0vsMut5_15$fitD05D03_mutations_0), y = min(Mut0vsMut5_15$fitD05D03_mutations_5),
            label = paste("Correlation =", round(cor_value_Mut0vsMut5, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut5_15$fitD05D03_mutations_0), y = max(Mut0vsMut5_15$fitD05D03_mutations_5),
           label = paste("Mutants =", num_rows15.mut0v5), hjust = 0, vjust = 1.5)

mut0v5_15plot2 <- ggMarginal(mut0v5_15plot, type = "histogram", fill = "#0072B2", alpha=0.75) #add side histograms
mut0v5_15plot2
```

```{r echo=FALSE}
ggsave(file="plots/correlation/L15.mutant.correlation.mut0.vs.mut1.complementation.png",
       plot=mut0v1_15plot2,
       dpi=600, width = 8, height = 6, units = "in")

ggsave(file="plots/correlation/L15.mutant.correlation.mut0.vs.mut2.complementation.png",
       plot=mut0v2_15plot2,
       dpi=600, width = 8, height = 6, units = "in")

ggsave(file="plots/correlation/L15.mutant.correlation.mut0.vs.mut3.complementation.png",
       plot=mut0v3_15plot2,
       dpi=600, width = 8, height = 6, units = "in")

ggsave(file="plots/correlation/L15.mutant.correlation.mut0.vs.mut4.complementation.png",
       plot=mut0v4_15plot2,
       dpi=600, width = 8, height = 6, units = "in")

ggsave(file="plots/correlation/L15.mutant.correlation.mut0.vs.mut5.complementation.png",
       plot=mut0v5_15plot2,
       dpi=600, width = 8, height = 6, units = "in")
```

### Lib16

Begin by selecting all mutants within a distance of 5 AA from their designed homologs
```{r}
mut_collapse_16 <- mutants16 %>%
  filter(mutations >= 0 & mutations < 6) %>%
  group_by(ID)
```

Merge these mutants with their designed homologs (perfects) if they have a matching "ID"
```{r}
# Add perfects to mut_collapse by shared columns:
mut_collapse_16 <- full_join(mut_collapse_16, perfects16)

# Subset the df to retain only relevant columns:
mut_collapse_16 <- mut_collapse_16[, c(1:36)]
```

Only retain mutIDs if the "ID" contains a designed variant (mutations == 0):
```{r}
mut_collapse_16 <- mut_collapse_16 %>%
  group_by(ID) %>%
  filter(0 %in% mutations) %>%
  ungroup()
```

Summarize the number of unique "ID" with mutations==0 (perfects) after filtering:
```{r}
mut_collapse_16.count <- mut_collapse_16 %>%
  filter(mutations == 0) %>%
  summarise(unique_rows = n_distinct(ID))

print(mut_collapse_16.count)
```

Summarize the number of unique "ID" at each mutation level:
```{r class.output="goodCode"}
mut_collapse_16.summary <- mut_collapse_16 %>%
  group_by(mutations) %>%
  summarise(unique_IDs = n_distinct(ID))

# View the summary table
print(mut_collapse_16.summary)
```

Summarize the number of collapsed homologs after filtering
```{r class.output="goodCode"}
# Count the number of unique designed homologs retained in the filtered dataset:
format(length(unique(mut_collapse_16$ID)), big.mark = ",")

# Count the number of unique "mutID" after excluding rows with mutations==0 (retains mutants only)
format(length(unique(mut_collapse_16$mutID[mut_collapse_15$mutations != 0])), big.mark = ",")

# Now, count the number of unique "mutID" (this includes designed homologs and their mutants)
format(length(unique(mut_collapse_16$mutID)), big.mark = ",")
```

#### Mutation Similarity

Next, run correlation analyses between designed homologs and their corresponding mutant versions (1, 2, or 3 mutations) to determine if mutations share similar fitness values with designed variants
```{r}
# Lib16

# Filter the dataframe for perfects = 0 and subsequent mutations = 1,2,3,4,5
mutations16_0 <- subset(mut_collapse_16, mutations == 0)
mutations16_1 <- subset(mut_collapse_16, mutations == 1)
mutations16_2 <- subset(mut_collapse_16, mutations == 2)
mutations16_3 <- subset(mut_collapse_16, mutations == 3)
mutations16_4 <- subset(mut_collapse_16, mutations == 4)
mutations16_5 <- subset(mut_collapse_16, mutations == 5)

# Merge the dataframes based on shared "ID"
Mut0vsMut1_16 <- merge(mutations16_0, mutations16_1, by = "ID", suffixes = c("_mutations_0", "_mutations_1"))
Mut0vsMut2_16 <- merge(mutations16_0, mutations16_2, by = "ID", suffixes = c("_mutations_0", "_mutations_2"))
Mut0vsMut3_16 <- merge(mutations16_0, mutations16_3, by = "ID", suffixes = c("_mutations_0", "_mutations_3"))
Mut0vsMut4_16 <- merge(mutations16_0, mutations16_4, by = "ID", suffixes = c("_mutations_0", "_mutations_4"))
Mut0vsMut5_16 <- merge(mutations16_0, mutations16_5, by = "ID", suffixes = c("_mutations_0", "_mutations_5"))

# Subset relevant data columns and remove rows containing "NA" values
Mut0vsMut1_16 <- Mut0vsMut1_16[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_1", "fitD12D04_mutations_0", "fitD12D04_mutations_1")] %>% na.omit(Mut0vsMut1_16)
Mut0vsMut2_16 <- Mut0vsMut2_16[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_2", "fitD12D04_mutations_0", "fitD12D04_mutations_2")] %>% na.omit(Mut0vsMut2_16)
Mut0vsMut3_16 <- Mut0vsMut3_16[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_3", "fitD12D04_mutations_0", "fitD12D04_mutations_3")] %>% na.omit(Mut0vsMut3_16)
Mut0vsMut4_16 <- Mut0vsMut4_16[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_4", "fitD12D04_mutations_0", "fitD12D04_mutations_4")] %>% na.omit(Mut0vsMut4_16)
Mut0vsMut5_16 <- Mut0vsMut5_16[, c("ID", "numprunedBCs_mutations_0", "numprunedBCs_mutations_5", "fitD12D04_mutations_0", "fitD12D04_mutations_5")] %>% na.omit(Mut0vsMut5_16)


# Calculate correlation and p-value
cor_test16_Mut0vsMut1 <- cor.test(Mut0vsMut1_16$fitD12D04_mutations_0, Mut0vsMut1_16$fitD12D04_mutations_1)
cor_test16_Mut0vsMut2 <- cor.test(Mut0vsMut2_16$fitD12D04_mutations_0, Mut0vsMut2_16$fitD12D04_mutations_2)
cor_test16_Mut0vsMut3 <- cor.test(Mut0vsMut3_16$fitD12D04_mutations_0, Mut0vsMut3_16$fitD12D04_mutations_3)
cor_test16_Mut0vsMut4 <- cor.test(Mut0vsMut4_16$fitD12D04_mutations_0, Mut0vsMut4_16$fitD12D04_mutations_4)
cor_test16_Mut0vsMut5 <- cor.test(Mut0vsMut5_16$fitD12D04_mutations_0, Mut0vsMut5_16$fitD12D04_mutations_5)

cor_test16_Mut0vsMut1
cor_test16_Mut0vsMut2
cor_test16_Mut0vsMut3
cor_test16_Mut0vsMut4
cor_test16_Mut0vsMut5
```

#### Plot Correlations
```{r}
# Extract correlation value from cor_result16_Mut0vsMut1 object
cor_value_Mut0vsMut1 <- cor_test16_Mut0vsMut1$estimate
cor_value_Mut0vsMut2 <- cor_test16_Mut0vsMut2$estimate
cor_value_Mut0vsMut3 <- cor_test16_Mut0vsMut3$estimate
cor_value_Mut0vsMut4 <- cor_test16_Mut0vsMut4$estimate
cor_value_Mut0vsMut5 <- cor_test16_Mut0vsMut5$estimate


# Format p-value in scientific notation
p_value_scientific16_v1 <- format(cor_test16_Mut0vsMut1$p.value, scientific = TRUE, digits = 4)
p_value_scientific16_v2 <- format(cor_test16_Mut0vsMut2$p.value, scientific = TRUE, digits = 4)
p_value_scientific16_v3 <- format(cor_test16_Mut0vsMut3$p.value, scientific = TRUE, digits = 4)
p_value_scientific16_v4 <- format(cor_test16_Mut0vsMut4$p.value, scientific = TRUE, digits = 4)
p_value_scientific16_v5 <- format(cor_test16_Mut0vsMut5$p.value, scientific = TRUE, digits = 4)

# Extract number of rows
num_rows16.mut0v1 <- nrow(Mut0vsMut1_16)
num_rows16.mut0v2 <- nrow(Mut0vsMut2_16)
num_rows16.mut0v3 <- nrow(Mut0vsMut3_16)
num_rows16.mut0v4 <- nrow(Mut0vsMut4_16)
num_rows16.mut0v5 <- nrow(Mut0vsMut5_16)

# Plot the correlation (Mut0vsMut1)
mut0v1_16plot <- ggplot(Mut0vsMut1_16, 
             aes(x = fitD12D04_mutations_0, y = fitD12D04_mutations_1, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD12D04 (mutations = 0)",
       y = "fitD12D04 (mutations = 1)", color="",
       title = "Lib16 Complementation (Mut=0 vs Mut=1)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut1_16$fitD12D04_mutations_0), y = min(Mut0vsMut1_16$fitD12D04_mutations_1), 
           label = paste("p-value =", p_value_scientific16_v1), hjust = 1, vjust = 0) +
  annotate("text", x = max(Mut0vsMut1_16$fitD12D04_mutations_0), y = min(Mut0vsMut1_16$fitD12D04_mutations_1),
            label = paste("Correlation =", round(cor_value_Mut0vsMut1, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut1_16$fitD12D04_mutations_0), y = max(Mut0vsMut1_16$fitD12D04_mutations_1),
           label = paste("Mutants =", num_rows16.mut0v1), hjust = 0, vjust = 1.5)

mut0v1_16plot2 <- ggMarginal(mut0v1_16plot, type = "histogram", fill = "#E69F00", alpha=0.75) #add side histograms
mut0v1_16plot2

# Plot the correlation (Mut0vsMut2)
mut0v2_16plot <- ggplot(Mut0vsMut2_16, 
             aes(x = fitD12D04_mutations_0, y = fitD12D04_mutations_2, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD12D04 (mutations = 0)",
       y = "fitD12D04 (mutations = 2)", color="",
       title = "Lib16 Complementation (Mut=0 vs Mut=2)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut2_16$fitD12D04_mutations_0), y = min(Mut0vsMut2_16$fitD12D04_mutations_2), 
           label = paste("p-value =", p_value_scientific16_v2), hjust = 1, vjust = 0)+
  annotate("text", x = max(Mut0vsMut2_16$fitD12D04_mutations_0), y = min(Mut0vsMut2_16$fitD12D04_mutations_2),
            label = paste("Correlation =", round(cor_value_Mut0vsMut2, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut2_16$fitD12D04_mutations_0), y = max(Mut0vsMut2_16$fitD12D04_mutations_2),
           label = paste("Mutants =", num_rows16.mut0v2), hjust = 0, vjust = 1.5)

mut0v2_16plot2 <- ggMarginal(mut0v2_16plot, type = "histogram", fill = "#E69F00", alpha=0.75) #add side histograms
mut0v2_16plot2

# Plot the correlation (Mut0vsMut3)
mut0v3_16plot <- ggplot(Mut0vsMut3_16, 
             aes(x = fitD12D04_mutations_0, y = fitD12D04_mutations_3, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD12D04 (mutations = 0)",
       y = "fitD12D04 (mutations = 3)", color="",
       title = "Lib16 Complementation (Mut=0 vs Mut=3)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut3_16$fitD12D04_mutations_0), y = min(Mut0vsMut3_16$fitD12D04_mutations_3), 
           label = paste("p-value =", p_value_scientific16_v3), hjust = 1, vjust = 0)+
  annotate("text", x = max(Mut0vsMut3_16$fitD12D04_mutations_0), y = min(Mut0vsMut3_16$fitD12D04_mutations_3),
            label = paste("Correlation =", round(cor_value_Mut0vsMut3, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut3_16$fitD12D04_mutations_0), y = max(Mut0vsMut3_16$fitD12D04_mutations_3),
           label = paste("Mutants =", num_rows16.mut0v3), hjust = 0, vjust = 1.5)

mut0v3_16plot2 <- ggMarginal(mut0v3_16plot, type = "histogram", fill = "#E69F00", alpha=0.75) #add side histograms
mut0v3_16plot2

# Plot the correlation (Mut0vsMut4)
mut0v4_16plot <- ggplot(Mut0vsMut4_16, 
             aes(x = fitD12D04_mutations_0, y = fitD12D04_mutations_4, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD12D04 (mutations = 0)",
       y = "fitD12D04 (mutations = 4)", color="",
       title = "Lib16 Complementation (Mut=0 vs Mut=4)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut4_16$fitD12D04_mutations_0), y = min(Mut0vsMut4_16$fitD12D04_mutations_4), 
           label = paste("p-value =", p_value_scientific16_v4), hjust = 1, vjust = 0)+
  annotate("text", x = max(Mut0vsMut4_16$fitD12D04_mutations_0), y = min(Mut0vsMut4_16$fitD12D04_mutations_4),
            label = paste("Correlation =", round(cor_value_Mut0vsMut4, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut4_16$fitD12D04_mutations_0), y = max(Mut0vsMut4_16$fitD12D04_mutations_4),
           label = paste("Mutants =", num_rows16.mut0v4), hjust = 0, vjust = 1.5)

mut0v4_16plot2 <- ggMarginal(mut0v4_16plot, type = "histogram", fill = "#E69F00", alpha=0.75) #add side histograms
mut0v4_16plot2

# Plot the correlation (Mut0vsMut5)
mut0v5_16plot <- ggplot(Mut0vsMut5_16, 
             aes(x = fitD12D04_mutations_0, y = fitD12D04_mutations_5, color=numprunedBCs_mutations_0)) +
  labs(x = "fitD12D04 (mutations = 0)",
       y = "fitD12D04 (mutations = 5)", color="",
       title = "Lib16 Complementation (Mut=0 vs Mut=5)") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", x = max(Mut0vsMut5_16$fitD12D04_mutations_0), y = min(Mut0vsMut5_16$fitD12D04_mutations_5), 
           label = paste("p-value =", p_value_scientific16_v5), hjust = 1, vjust = 0)+
  annotate("text", x = max(Mut0vsMut5_16$fitD12D04_mutations_0), y = min(Mut0vsMut5_16$fitD12D04_mutations_5),
            label = paste("Correlation =", round(cor_value_Mut0vsMut5, 2)), hjust = 1, vjust = -1.5) +
  annotate("text", x = min(Mut0vsMut5_16$fitD12D04_mutations_0), y = max(Mut0vsMut5_16$fitD12D04_mutations_5),
           label = paste("Mutants =", num_rows16.mut0v5), hjust = 0, vjust = 1.5)

mut0v5_16plot2 <- ggMarginal(mut0v5_16plot, type = "histogram", fill = "#E69F00", alpha=0.75) #add side histograms
mut0v5_16plot2
```

```{r echo=FALSE}
ggsave(file="plots/correlation/L16.mutant.correlation.mut0.vs.mut1.complementation.png",
       plot=mut0v1_16plot2,
       dpi=600, width = 8, height = 6, units = "in")

ggsave(file="plots/correlation/L16.mutant.correlation.mut0.vs.mut2.complementation.png",
       plot=mut0v2_16plot2,
       dpi=600, width = 8, height = 6, units = "in")

ggsave(file="plots/correlation/L16.mutant.correlation.mut0.vs.mut3.complementation.png",
       plot=mut0v3_16plot2,
       dpi=600, width = 8, height = 6, units = "in")

ggsave(file="plots/correlation/L16.mutant.correlation.mut0.vs.mut4.complementation.png",
       plot=mut0v4_16plot2,
       dpi=600, width = 8, height = 6, units = "in")

ggsave(file="plots/correlation/L16.mutant.correlation.mut0.vs.mut5.complementation.png",
       plot=mut0v5_16plot2,
       dpi=600, width = 8, height = 6, units = "in")
```

## Generate FASTA

Generate a FASTA file for each library containing each unique mutID (designed homologs and mutants up to 5 AA difference) and their corresponding protein sequence for use in broad mutational scanning (BMS) and gain-of-function (GOF) analysis.
```{r}
# Lib15

# Create the sequences in FASTA format
fasta_content_15 <- paste(">", mut_collapse_15$mutID, "\n", mut_collapse_15$seq, "\n", sep = "", collapse = "")

# Define the file path in the working directory
fasta_file_path_15 <- file.path(getwd(), "OUTPUT/mutant.collapse.5BC.Lib15.fasta")

# Write the FASTA content to the file
writeLines(fasta_content_15, con = fasta_file_path_15)

# Lib16

# Create the sequences in FASTA format
fasta_content_16 <- paste(">", mut_collapse_16$mutID, "\n", mut_collapse_16$seq, "\n", sep = "", collapse = "")

# Define the file path in the working directory
fasta_file_path_16 <- file.path(getwd(), "OUTPUT/mutant.collapse.2BC.Lib16.fasta")

# Write the FASTA content to the file
writeLines(fasta_content_16, con = fasta_file_path_16)
```

## Median Fitness
Generate median fitness values for each homolog and associated mutants (up to 5 A.A. distance) by grouping by "ID"

**Lib15**
```{r}
#Calculate median fitness for each homolog and associated mutants and sum the total number of BCs (numBCs and numprunedBCs)
mut_collapse_15info <- mut_collapse_15 %>%
  group_by(ID) %>%
  summarise(medD05D03=median(fitD05D03),
            medD06D03=median(fitD06D03),
            medD07D03=median(fitD07D03),
            medD08D03=median(fitD08D03),
            medD09D03=median(fitD09D03),
            medD10D03=median(fitD10D03),
            medD11D03=median(fitD11D03),
            totalnumBCs.L15=sum(numBCs),
            totalnumprunedBCs.L15=sum(numprunedBCs))
```

Count the number of unique IDs after collapsing mutants up to 5 A.A. distance:
```{r class.output="goodCode"}
format(length(unique(mut_collapse_15info$ID)), big.mark = ",")
```

**Lib16**
```{r}
#Calculate median fitness for each homolog and associated mutants and sum the total number of BCs (numBCs and numprunedBCs)
mut_collapse_16info <- mut_collapse_16 %>%
  group_by(ID) %>%
  summarise(medD12D04=median(fitD12D04),
            medE01D04=median(fitE01D04),
            medE02D04=median(fitE02D04),
            medE03D04=median(fitE03D04),
            medE04D04=median(fitE04D04),
            medE05D04=median(fitE05D04),
            medE06D04=median(fitE06D04),
            totalnumBCs.L16=sum(numBCs),
            totalnumprunedBCs.L16=sum(numprunedBCs))
```

Count the number of unique IDs after collapsing mutants up to 5 A.A. distance:
```{r class.output="goodCode"}
format(length(unique(mut_collapse_16info$ID)), big.mark = ",")
```

Generate a new dataframe retaining only the unique IDs shared between libraries:
```{r}
shared_mut_collapse_15.16info <- merge(mut_collapse_15info, mut_collapse_16info, by = "ID")
```

Count the number of unique IDs shared between libraries:
```{r class.output="goodCode"}
format(length(unique(shared_mut_collapse_15.16info$ID)), big.mark = ",")
```

Subset relevant data columns for correlations and remove rows containing "NA" values:
```{r}
# Complementation - 0-TMP
Shared.Mut.Collapse.counts.0.tmp <- shared_mut_collapse_15.16info[, c("ID", "totalnumprunedBCs.L15", "totalnumprunedBCs.L16", "medD05D03","medD12D04")] %>% na.omit(Shared.Mut.Collapse.counts.0.tmp)
```

Calculate correlation between median fitness values for unique IDs shared between libraries:
```{r}
# Calculate correlation and p-value between Lib15 and Lib16 Complementation
cor_test_shared_mut_collapse_15.16info <- cor.test(Shared.Mut.Collapse.counts.0.tmp$medD05D03,
                                                   Shared.Mut.Collapse.counts.0.tmp$medD12D04)

cor_test_shared_mut_collapse_15.16info
```

Plot the median fitness correlation between unique IDs shared between Lib15 and Lib16 (median with collapsed mutants):
```{r}
# Extract correlation value from cor_test_shared_mut_collapse_15.16info object
cor_value_shared <- cor_test_shared_mut_collapse_15.16info$estimate

# Format p-value in scientific notation
p_value_scientific_shared <- format(cor_test_shared_mut_collapse_15.16info$p.value, 
                                                    scientific = TRUE, digits = 4)

# Extract number of rows
num_rows.counts.5aa.0.tmp <- nrow(Shared.Mut.Collapse.counts.0.tmp)

p33.1 <- ggplot(Shared.Mut.Collapse.counts.0.tmp, 
             aes(x = medD05D03, y = medD12D04, color=totalnumprunedBCs.L15)) +
  labs(x = "Median Lib15 Fitness (Complementation)", 
       y = "Median Lib16 Fitness (Complementation)", color="", 
       title = "Median Fitness between Shared Perfects up to 5 AA") +
  geom_smooth(method=lm,colour="black") +
  geom_density2d(colour="black",alpha=0.2) +
  geom_point(alpha=0.7) +
  scale_colour_gradient2("BCs",low="blue", high="red", mid="blue") +
  theme_minimal() +
  theme(axis.line = element_line(colour = 'black', size = 0.5), 
        axis.ticks = element_line(colour = "black", size = 0.5),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"),
        axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position="left") +
  annotate("text", 
           x = max(Shared.Mut.Collapse.counts.0.tmp$medD05D03), 
           y = min(Shared.Mut.Collapse.counts.0.tmp$medD12D04), 
           label = paste("p-value =", p_value_scientific_shared), hjust = 1, vjust = 0) +
  annotate("text", 
           x = max(Shared.Mut.Collapse.counts.0.tmp$medD05D03), 
           y = min(Shared.Mut.Collapse.counts.0.tmp$medD12D04),
           label = paste("Correlation =", round(cor_value_shared, 2)), hjust = 1, vjust = -1.5) +
  annotate("text",
           x = min(Shared.Mut.Collapse.counts.0.tmp$medD05D03),
           y = max(Shared.Mut.Collapse.counts.0.tmp$medD12D04),
           label = paste("Shared Perfects =", num_rows.counts.5aa.0.tmp), hjust = 0, vjust = 1.5)

p33.2 <- ggMarginal(p33.1, type = "histogram", fill = "#0072B2", alpha=0.75) #add side histograms
p33.2
```

```{r echo=FALSE}
ggsave(file="plots/combined/Lib15.16.shared.collapsed.mutants.5AA.median.complementation.png",
       plot=p33.2,
       dpi=600, width = 8, height = 6, units = "in")
```

# BMS Analysis

<font color="blue">**This section is based on the R file: "R_BMS_all.Lib15.R".**</font> It describes how to generate MSA mapping files for each homolog and map their fitness values by sequential amino acid positions aligned to E. coli as the reference sequence. The end result is a heatmap displaying median fitness values for each amino acid at each position along the protein sequence.

## BMS Python

**Broad Mutational Scanning (BMS) Analysis Script:**
This set of scripts facilitates broad mutational scanning analysis where data from many related protein homologs and their mutants is combined and collapsed for further analysis and visualization. This script is based on the approach used in: Plesa C, Sidore AM, Lubock N, Zhang D, Kosuri S. Multiplexed Gene Synthesis in Emulsions for Exploring Protein Functional Landscapes. Science 359, 343347 (2018), [DOI: 10.1126/science.aao5167](https://www.science.org/doi/10.1126/science.aao5167).

**Procedure**
Download the following python scripts via [GitHub](link_to_files) and place in working directory:

- dssp.py
- clustalo
- FastTree
  
The analysis can be carried out by running the following scripts, which include <ins>python</ins> and <ins>bash</ins>:

- `clustalo` Alignment python script based on fasta files generated for each library
- `map.aligned.residues.py` Residue mapping from aligned fasta file generated for each library
- `parse_dssp.py` Generate RSA and SS information files from the WT E. coli DHFR dssp file

**Alignment:** Use the `clustalo` executable to align the protein sequences associated with designed homologs and associated mutants up to two A.A. distance as generated in the **mutant.collapse.2BC.Lib_.fasta** files.
```{bash eval=FALSE}
# May need to enable permissions to run the executable:
# chmod +x ./clustalo
#./clustalo -i OUTPUT/mutant.collapse.2BC.Lib15.new.fasta -o #OUTPUT/mutant.collapse.2BC.Lib15_aligned.new.fa --outfmt=a2m --force

./clustalo -i OUTPUT/tree_build/perfects15.tree.5BCs.fasta -o perfects15.tree.5BCs.aligned.fa --outfmt=a2m --force
```

**Mapping Residues:** Use the following `map.aligned.residues.py` python script to generate csv files for each designed homolog and associated mutant that maps residue positions of each A.A. from alignment fasta:

- `map_aligned_residues.py`
This will parse the alignments and generate tables of which homolog's residue corresponds to which position in the alignment table so that co-aligned residues can be determined.
```{python eval=FALSE}
import time
import csv
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO

#
# Note; modify the file to remove blank lines
#

##################################
#FUNCTIONS:
def getFastaSeqs(filename):
    fastaseqs = []
    handle = open(filename)
    for seqrec in SeqIO.parse(handle,"fasta"):
        fastaseqs.append(seqrec)
    handle.close()
    return fastaseqs

##################################
#INPUTS:

base_path = ""
trees_path_prefix = base_path+""

#clustal format alignment file
#align_file_in = [trees_path_prefix+"perfects_tree_5BCs_aligned_mod.aln"] #Original aligned FASTA from Carmen Lib15 analysis
align_file_in = [trees_path_prefix+"perfects15.tree.5BCs.aligned.fa"] #New aligned FASTA, but not same format as original

#number of seqs in each alignment file
#num_samples_in_file = [852] #Original FASTA
num_samples_in_file = [797] #New FASTA

##################################
#OUTPUTS:

msa_map_out_path = [trees_path_prefix+"MSA_BMS_1/"]


for alni in range(1):#len(align_file_in)):
    print(alni)
    
    ##################################
    #VARIABLES:
    
    #ID as key, align as value
    align_dict = dict()
    
    #num_samples = 454
    num_samples = num_samples_in_file[alni]
    
    #pos key, consensus pos val
    IDaadictlist = [dict() for x in range(num_samples)]
    
    IDtoindexdict = dict()
    indexdtoIDict = dict()
    
    ##################################
    #CODE:
    
    line_count = 0
    #loop over all alignments:
    print(align_file_in[alni])
    for line in open(align_file_in[alni]):
        #skip header
        if line_count > 1:
            listWords = line.split('    ')
            ID = listWords[0]
            align = line[16:].rstrip()
            if ID.strip() != "":
                align_dict[ID] = align_dict.get(ID, "") + align.replace(" ", "")
        line_count += 1
    
    print("NP_414590")
    print(align_dict["NP_414590"])

    counter = 0
    for ID in align_dict:
        #print(ID)
        #print(align_dict[ID])
        IDtoindexdict[ID] = counter
        indexdtoIDict[counter]=ID
        align = align_dict[ID]
        
        aacounter = 1
        
        
        for i in range(len(align)):
            if align[i] != "-":
                
                #print(str(counter)+" "+str(aacounter))
                IDaadictlist[counter][aacounter]=i+1
                aacounter += 1
        counter += 1
        
    print(len(IDaadictlist))
    for i in range(len(IDaadictlist)-1):
        #print(indexdtoIDict[i])
        #print(i)
        #print(alni)
        #print(indexdtoIDict[i])
        csvfile = open(str(msa_map_out_path[alni]+indexdtoIDict[i]+".csv"), 'w')
        fieldnames = ['orth_aanum','msa_aanum']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for j in IDaadictlist[i]:
            #print(str(j)+" "+str(IDaadictlist[i][j]))
            #save all data:
            writer.writerow({'orth_aanum':str(j),'msa_aanum':str(IDaadictlist[i][j])})
        csvfile.close()
```

- `parse_dssp.py`
This is used to generate Relative-Solvent-Accessibility and Secondary-Structure information files from the WT E. coli DHFR dssp file. This uses Jesse Bloom's dssp module from mapmuts.

  - Script requires a properly formatted dssp file derived from the WT E. coli PDB file available online
  - **PDB File for WT E. coli (4KJK):** Download PDB file from  [https://www.rcsb.org/structure/4KJK](https://www.rcsb.org/structure/4KJK) 
  - **DSSP File Generator (4KJK):** Navigate to [http://bioinformatica.isa.cnr.it/SUSAN/DSSP-web/](http://bioinformatica.isa.cnr.it/SUSAN/DSSP-web/)
    - Open the PDB file in text editor, select all, copy and paste in text box on Bioinformatica website
    - Select "DSSP file" from option list and hit "SEND"
    - Select entire dssp output from browser window and copy and paste in text editor
    - Save the text file as: <font color="green">4kjk.dssp.txt</font>
    - Remove the last two rows and save as: <font color="green">4kjk.dsspmod1.txt</font> (necessary for python script to work)
  - Run the following `parse_dssp.py` script calling in the <font color="green">4kjk.dsspmod1.txt</font> file
    - Python script will generate the following two text files:
      - <font color="green">4kjk.SSs.txt</font> (Secondary Structures)
      - <font color="green">4kjk.RSAs.txt</font> (Relative-Solvent-Accessibility)
  

**parse_dssp.py** python script
```{python eval=FALSE}
import dssp

dsspdat = dssp.ReadDSSP('OUTPUT/structures/4kjk.dsspmod1.txt', 'Tien2013', 'A')

frsa = open('OUTPUT/structures/4kjk.RSAs.txt', 'w')
frsa.write('#Relative solvent accessibilities from a DSSP analysis of the 4KJK, taking results for chain A. Absolute solvent accessibilities are normalized to relative ones using the maximum solvent accessibilities of Tien et al, PLoS One, 8:e80635.\n#SITE RSA\n')
fss = open('OUTPUT/structures/4kjk.SSs.txt', 'w')
fss.write('#Secondary structures from a DSSP analysis of the 4KJK, taking results for chain A.\n#SITE SS\n')
sites = sorted(dsspdat.keys())
for site in sites:
    fss.write('%d %s\n' % (site, dsspdat[site]['SS_CLASS']))
    frsa.write('%d %s\n' % (site, dsspdat[site]['RSA']))
fss.close()
frsa.close()
```

## MSA Mapping
Define the directory containing the parse MSA mapping files (.csv) for each collapsed homolog (<2 A.A. distance):
```{r}
BMS_MSA_directory = "MSA_BMS_1"

# AA map + X
BMS_aa_list<-data.frame(aa=c('G','P','A','V','L','I','M','C','F','Y','W','H','K','R','Q','N','E','D','S','T','X'),
                        aanum=c(1:21))

BMS_aa_dim <- length(BMS_aa_list$aa)

# Wildtype E. coli is:
#NP_414590

# AA length of homolog which collapsing on
BMS_ref_len <- 159

# Minimum number of BCs to use a mutant
BMS_min_BCs = 1

# Largest number of mutations to use
#currently limited to 5 due to mutation naming scheme
BMS_max_mutations = 5

# Minimum fitness to include the mutation
BMS_min_fitness <- -1
```

```{r}
# Grab perfects (perfects15_2BCs) %>%
BMS_homolog15_ID_list <- perfects15_2BCs %>%
  filter(fitD05D03 > BMS_min_fitness) %>%
  dplyr::select(ID)

write.table(BMS_homolog15_ID_list, file = paste("OUTPUT/BMS_Fitness/BMS_homolog15_ID_list_min_fitness_",as.character(BMS_min_fitness),".csv",sep=""), sep = ",", row.names = F,quote=F,col.names = F)
```

```{r}
#make sure all of the perfects are in the MSA
BMS_index_of_mut_to_drop = numeric()
for (i in 1:length(BMS_homolog15_ID_list$ID)){
  mutant_current_temp <- BMS_homolog15_ID_list$ID[i]
  if(!file.exists(paste(BMS_MSA_directory,"/",mutant_current_temp,".csv",sep=""))){
    print(mutant_current_temp)
    BMS_index_of_mut_to_drop[length(BMS_index_of_mut_to_drop)+1] <- which(BMS_homolog15_ID_list$ID==mutant_current_temp)
  }
}
if (length(BMS_index_of_mut_to_drop) > 0){
  BMS_homolog15_ID_list <- BMS_homolog15_ID_list[-BMS_index_of_mut_to_drop,]
}

#rm(BMS_index_of_mut_to_drop,
#   mutant_current_temp)
```

```{r}
#load ecoli MSA mapping
BMS_ecoli_map <- read.csv(file=paste(BMS_MSA_directory,"/NP_414590.csv",sep=""),
                          head=TRUE,
                          sep=",")

#E.coli PPAT seq:
BMS_ecoli_seq <- "MISLIAALAVDRVIGMENAMPWNLPADLAWFKRNTLNKPVIMGRHTWESIGRPLPGRKNIILSSQPGTDDRVTWVKSVDEAIAACGDVPEIMVIGGGRVYEQFLPKAQKLYLTHIDAEVEGDTHFPDYEPDDWESVFSEFHDADAQNSHSYCFEILERR"
```

Determine the total number of mutants included in BMS analysis
```{r class.output="goodCode"}
mutants15 %>%
  filter(mutations > 0 & mutations < 6 & numprunedBCs >= BMS_min_BCs) %>%
  #dplyr::rename(ID=IDalign) %>%
  semi_join(BMS_homolog15_ID_list,by="ID") %>%
  ungroup() %>%
  dplyr::rename(IDalign=ID) %>%
  nrow(.)
```

## BMS Perfects

Grab the perfects with this number of mutations (this actually filters by min number of pruned BCs, not mutations):
```{r}
BMS_mutants15_temp <- mutants15 %>%
  filter(mutations == 0 &
           numprunedBCs >= BMS_min_BCs) %>%
  dplyr::rename(ID=IDalign) %>%
  semi_join(BMS_homolog15_ID_list,by="ID") %>%#filtering join
  ungroup() %>%
  dplyr::rename(IDalign=ID)
```

Make a new data frame which will keep info:
```{r}
BMS_fitness15_map <- data.frame(position=numeric(),
                              aa=character(),
                              mutations=numeric(),
                              fitness=numeric(),
                              posortho=numeric(),
                              ingap=character(),
                              mutID=character(),
                              ID=character())
```

Loop over all perfects:
```{r}
for (i in 1:nrow(BMS_mutants15_temp)) {
  #current ortholog:
  mutant_current_temp <- BMS_mutants15_temp$IDalign[i]
  
  #get the MSA mapping:
  mutant_map_temp <- read.csv(file=paste(BMS_MSA_directory,"/",mutant_current_temp,".csv",sep=""), head=TRUE, sep=",")
  
  #load the full seq and add an M at start
  BMS_seq_temp <- paste("M", as.character(BMS_mutants15_temp$seq[i]), sep="")
  
  #get fitness for this ortholog
  BMS_fit_temp <- BMS_mutants15_temp$fitD05D03[i]
  
  #loop over all residues
  for (j in 1:nchar(BMS_seq_temp)) {
    #find the corresponding residue in E.coli using MSA
    BMS_cons_aanum <- mutant_map_temp$msa_aanum[which(mutant_map_temp$orth_aanum == j)]
    
    #does this map to a non-gap residue in E.coli?
    if (BMS_cons_aanum %in% BMS_ecoli_map$msa_aanum) {
      #get the E.coli residue
      e_coli_residue <- BMS_ecoli_map$orth_aanum[which(BMS_ecoli_map$msa_aanum == BMS_cons_aanum)]
      
      #aa at this residue
      BMS_aa_temp <- substr(BMS_seq_temp, j, j)
      
      #add info for this residue to df
      BMS_fitness15_map <- rbind(BMS_fitness15_map,
                               data.frame(position=e_coli_residue,
                                          aa=BMS_aa_temp,
                                          mutations=0,
                                          fitness=BMS_fit_temp,
                                          posortho=j,
                                          ingap="No",
                                          mutID=mutant_current_temp,
                                          ID=mutant_current_temp))
    } else {
      #if it's here it maps to a gap
      BMS_aa_temp <- substr(BMS_seq_temp, j, j)
      BMS_fitness15_map <- rbind(BMS_fitness15_map,
                               data.frame(position=-1,
                                          aa=BMS_aa_temp,
                                          mutations=0,
                                          fitness=BMS_fit_temp,
                                          posortho=j,
                                          ingap="Yes",
                                          mutID=mutant_current_temp,
                                          ID=mutant_current_temp))
    }
  }
}
```

```{r eval=FALSE, echo=FALSE}
write.table(BMS_fitness15_map, file = paste("OUTPUT/BMS_Fitness/BMS_fitness15_map.csv",sep=""), sep = ",", row.names = F,quote=F,col.names = T)
```

Collapse fitness values for each position onto the BMS Fitness Map:
```{r}
BMS_fitness15_collapsed <- BMS_fitness15_map %>%
  filter(position > 0) %>%
  group_by(position, aa) %>%
  summarise(fitval=median(fitness),
            numpoints=n(),
            stdfit=sd(fitness))
```

These matrices have the fitness for each aa at each position:
```{r}
BMS_matrix15_perfects = matrix(rep(NA, BMS_ref_len*BMS_aa_dim),nrow=BMS_aa_dim,ncol=BMS_ref_len)
BMS_matrix15_perfects_num = matrix(rep(NA, BMS_ref_len*BMS_aa_dim),nrow=BMS_aa_dim,ncol=BMS_ref_len)
BMS_matrix15_perfects_sd = matrix(rep(NA, BMS_ref_len*BMS_aa_dim),nrow=BMS_aa_dim,ncol=BMS_ref_len)
```

Populate matrix:
```{r}
for (i in 1:nrow(BMS_fitness15_collapsed)){
  BMS_matrix15_perfects[which(BMS_aa_list$aa==as.character(BMS_fitness15_collapsed$aa[i])),
                      BMS_fitness15_collapsed$position[i]] <- as.numeric(BMS_fitness15_collapsed$fitval[i])
  BMS_matrix15_perfects_num[which(BMS_aa_list$aa==as.character(BMS_fitness15_collapsed$aa[i])),
                          BMS_fitness15_collapsed$position[i]] <- as.numeric(BMS_fitness15_collapsed$numpoints[i])
  BMS_matrix15_perfects_sd[which(BMS_aa_list$aa==as.character(BMS_fitness15_collapsed$aa[i])),
                         BMS_fitness15_collapsed$position[i]] <- as.numeric(BMS_fitness15_collapsed$stdfit[i])
}
```

Assign AA names and position numbers to matrices:
```{r warning=FALSE}
rownames(BMS_matrix15_perfects)<-BMS_aa_list$aa
colnames(BMS_matrix15_perfects)<-c(1:BMS_ref_len)
rownames(BMS_matrix15_perfects_num)<-BMS_aa_list$aa
colnames(BMS_matrix15_perfects_num)<-c(1:BMS_ref_len)
rownames(BMS_matrix15_perfects_sd)<-BMS_aa_list$aa
colnames(BMS_matrix15_perfects_sd)<-c(1:BMS_ref_len)

BMS_matrix15_perfects_melt <- melt(BMS_matrix15_perfects)
BMS_matrix15_perfects_num_melt <- melt(BMS_matrix15_perfects_num)
BMS_matrix15_perfects_sd_melt <- melt(BMS_matrix15_perfects_sd)
```

### Perfects Plotting

Plot the fitness data:
```{r}
ggplot(data = BMS_matrix15_perfects_melt, aes(x=X2, y=X1, fill=value)) +
  geom_tile()+ labs(x = "Position (aa)", y ="Amino acid",color="") +
  scale_fill_gradient2(low = "blue", high = "red", mid="gold",name="Fitness",na.value="grey", limit = c(-1,1)) +
  theme_minimal() + 
  scale_x_continuous(breaks=seq(0,155,5))
```

```{r echo=FALSE, eval=FALSE}
ggsave(file=paste("plots/BMS/BMS_allpos15_min",toString(BMS_min_BCs),"_0_fit.pdf",sep=""))
```

Plot the coverage data:
```{r}
ggplot(data = BMS_matrix15_perfects_num_melt, aes(x=X2, y=X1, fill=log(value))) +
  geom_tile()+ labs(x = "Position (aa)", y ="Amino acid",color="") +
  scale_fill_gradient(low = "blue", high = "red",name="log(#points)",na.value="grey", limit = c(0,max(BMS_matrix15_perfects_num_melt$value))) +
  theme_minimal() + 
  scale_x_continuous(breaks=seq(0,155,5))
```

```{r echo=FALSE, eval=FALSE}
ggsave(file=paste("plots/BMS/BMS_allpos15_min",toString(BMS_min_BCs),"_0_num.pdf",sep=""))
```

Plot the STD Data:
```{r}
ggplot(data = BMS_matrix15_perfects_sd_melt, aes(x=X2, y=X1, fill=value)) +
  geom_tile()+ labs(x = "Position (aa)", y ="Amino acid",color="") +
  scale_fill_gradient2(low = "blue", high = "red", mid="gold",name="std(Fitness)",na.value="grey", limit = c(0,1.1*max(BMS_matrix15_perfects_sd_melt$value))) +
  theme_minimal() + 
  scale_x_continuous(breaks=seq(0,155,5))
```

```{r echo=FALSE, eval=FALSE}
ggsave(file=paste("plots/BMS/BMS_allpos15_min",toString(BMS_min_BCs),"_0_sd.pdf",sep=""))
```

## BMS Mutants

Grab the mutants associated with the perfects:
```{r}
# Make a copy of the dataframe for mutants
BMS_fitness15_map_all <- BMS_fitness15_map
```

Loop over mutants at some distance:
```{r warning=FALSE}
for (BMS_cur_mut_num in 1:BMS_max_mutations){
  
  #grab the mutants
  BMS_mutants15_temp <- mutants15 %>%
    filter(mutations == BMS_cur_mut_num &
             numprunedBCs >= BMS_min_BCs) %>%
    dplyr::rename(ID=IDalign) %>%
    semi_join(BMS_homolog15_ID_list,by="ID") %>%#filtering join
    ungroup() %>%
    dplyr::rename(IDalign=ID)
  
  #initialize new df
  BMS_fitness15_map1 <- data.frame(position=numeric(),
                                 aa=character(),
                                 mutations=numeric(),
                                 fitness=numeric(),
                                 posortho=numeric(),
                                 ingap=character(),
                                 mutID=character(),
                                 ID=character())
  
  #loop over mutants
  for (i in 1:nrow(BMS_mutants15_temp)){
    
    #mutant base name
    mutant_current_temp <- BMS_mutants15_temp$IDalign[i]
    
    #length of the name
    name_size = nchar(paste(mutant_current_temp,"_",sep=""))
    
    #residue mappings
    mutant_map_temp <- read.csv(file=paste(BMS_MSA_directory,"/",mutant_current_temp,".csv",sep=""),head=TRUE,sep=",")
    
    #this mutants fitness
    BMS_fit_temp <- BMS_mutants15_temp$fitD05D03[i]
    
    #grab the mut name
    mutations15_names <- as.character(BMS_mutants15_temp$mutID[i])
    
    #grab only the relevant portion of the name
    mutations15_names <- substr(mutations15_names, name_size+1, nchar(mutations15_names))
    
    ## split mutation string at non-digits
    s <- strsplit(mutations15_names, "_")
    
    for (mutnum in 1:BMS_cur_mut_num){
      
      #grab the corresponding mutation string
      mutcurr<-s[[1]][mutnum]
      
      #get the position
      mutpos <- as.numeric(str_extract(mutcurr, "[0-9]+"))
      
      #get ending aa
      to_aa <- substr(mutcurr, nchar(mutpos)+2, nchar(mutcurr))
      
      #find the number in the consensus seq
      BMS_cons_aanum <- mutant_map_temp$msa_aanum[which(mutant_map_temp$orth_aanum == mutpos)]
      
      #does this map to a non-gap
      if (BMS_cons_aanum %in% BMS_ecoli_map$msa_aanum){
        
        #the corresponding e.coli residue
        e_coli_residue <- BMS_ecoli_map$orth_aanum[which(BMS_ecoli_map$msa_aanum == BMS_cons_aanum)]
        
        #add this point to the data
        BMS_fitness15_map1 <- rbind(BMS_fitness15_map1,
                                  data.frame(position=e_coli_residue,
                                             aa=to_aa,
                                             mutations=BMS_cur_mut_num,
                                             fitness=BMS_fit_temp,
                                             posortho=mutpos,
                                             ingap="No",
                                             mutID=as.character(BMS_mutants15_temp$mutID[i]),
                                             ID=mutant_current_temp))
        
      } else {
        #if it's here it maps to a gap
        
        #add this point to the data
        BMS_fitness15_map1 <- rbind(BMS_fitness15_map1,
                                  data.frame(position=-1,
                                             aa=to_aa,
                                             mutations=BMS_cur_mut_num,
                                             fitness=BMS_fit_temp,
                                             posortho=mutpos,
                                             ingap="Yes",
                                             mutID=as.character(BMS_mutants15_temp$mutID[i]),
                                             ID=mutant_current_temp))
        
      }
      
    }
    
  }

  #Add these mutants onto the existing data:
  BMS_fitness15_map_all <- rbind(BMS_fitness15_map_all,BMS_fitness15_map1)

  write.table(BMS_fitness15_map1, file = paste("OUTPUT/BMS_Fitness/BMS_fitness15_map_",as.character(BMS_cur_mut_num),".csv",sep=""), 
            sep = ",", row.names = F,quote=F,col.names = T)
  
  #calc all data and stats
  BMS_fitness15_collapsed_all <- BMS_fitness15_map_all %>%
    filter(position > 0) %>%
    group_by(position, aa) %>%
    summarise(fitval=median(fitness),
              numpoints=n(),
              stdfit=sd(fitness))
  
  #these matrices have the fitness/num/sd for each aa at each position:
  BMS_matrix15_perfects_and_1 = matrix(rep(NA, BMS_ref_len*BMS_aa_dim),nrow=BMS_aa_dim,ncol=BMS_ref_len)
  BMS_matrix15_perfects_and_1_num = matrix(rep(NA, BMS_ref_len*BMS_aa_dim),nrow=BMS_aa_dim,ncol=BMS_ref_len)
  BMS_matrix15_perfects_and_1_sd = matrix(rep(NA, BMS_ref_len*BMS_aa_dim),nrow=BMS_aa_dim,ncol=BMS_ref_len)
  
  #populate matrix
  for (i in 1:nrow(BMS_fitness15_collapsed_all)){
    
    BMS_matrix15_perfects_and_1[which(BMS_aa_list$aa==as.character(BMS_fitness15_collapsed_all$aa[i])),BMS_fitness15_collapsed_all$position[i]] <- as.numeric(BMS_fitness15_collapsed_all$fitval[i])
    BMS_matrix15_perfects_and_1_num[which(BMS_aa_list$aa==as.character(BMS_fitness15_collapsed_all$aa[i])),BMS_fitness15_collapsed_all$position[i]] <- as.numeric(BMS_fitness15_collapsed_all$numpoints[i])
    BMS_matrix15_perfects_and_1_sd[which(BMS_aa_list$aa==as.character(BMS_fitness15_collapsed_all$aa[i])),BMS_fitness15_collapsed_all$position[i]] <- as.numeric(BMS_fitness15_collapsed_all$stdfit[i])
  }
  
  rownames(BMS_matrix15_perfects_and_1)<-BMS_aa_list$aa
  colnames(BMS_matrix15_perfects_and_1)<-c(1:BMS_ref_len)
  rownames(BMS_matrix15_perfects_and_1_num)<-BMS_aa_list$aa
  colnames(BMS_matrix15_perfects_and_1_num)<-c(1:BMS_ref_len)
  rownames(BMS_matrix15_perfects_and_1_sd)<-BMS_aa_list$aa
  colnames(BMS_matrix15_perfects_and_1_sd)<-c(1:BMS_ref_len)
  
  BMS_matrix15_perfects_and_1_melt <- melt(BMS_matrix15_perfects_and_1)
  BMS_matrix15_perfects_and_1_num_melt <- melt(BMS_matrix15_perfects_and_1_num)
  BMS_matrix15_perfects_and_1_sd_melt <- melt(BMS_matrix15_perfects_and_1_sd)
  
  #plot the data from these mutants:
  ggplot(data = BMS_matrix15_perfects_and_1_melt, aes(x=X2, y=X1, fill=value)) +
    geom_tile()+ labs(x = "Position (aa)", y ="Amino acid",color="") +
    scale_fill_gradient2(low = "blue", high = "red", mid="gold",name="Fitness",na.value="grey", limit = c(-5,5)) +
    theme_minimal() + 
    scale_x_continuous(breaks=seq(0,155,5))
  ggsave(file=paste("plots/BMS/BMS_allpos15_min",toString(BMS_min_BCs),"_max",toString(BMS_cur_mut_num),"_fit.pdf",sep=""))
  
  ggplot(data = BMS_matrix15_perfects_and_1_num_melt, aes(x=X2, y=X1, fill=log(value))) +
    geom_tile()+ labs(x = "Position (aa)", y ="Amino acid",color="") +
    scale_fill_gradient(low = "blue", high = "red",name="log(#points)",na.value="grey", limit = c(0,max(BMS_matrix15_perfects_and_1_num_melt$value))) +
    theme_minimal() + 
    scale_x_continuous(breaks=seq(0,155,5))
  ggsave(file=paste("plots/BMS/BMS_allpos15_min",toString(BMS_min_BCs),"_max",toString(BMS_cur_mut_num),"_num.pdf",sep=""))
  
  ggplot(data = BMS_matrix15_perfects_and_1_sd_melt, aes(x=X2, y=X1, fill=value)) +
    geom_tile()+ labs(x = "Position (aa)", y ="Amino acid",color="") +
    scale_fill_gradient2(low = "blue", high = "red", mid="gold",name="std(Fitness)",na.value="grey", limit = c(0,1.1*max(BMS_matrix15_perfects_and_1_sd_melt$value))) +
    theme_minimal() + 
    scale_x_continuous(breaks=seq(0,155,5))
  ggsave(file=paste("plots/BMS/BMS_allpos15_min",toString(BMS_min_BCs),"_max",toString(BMS_cur_mut_num),"_sd.pdf",sep=""))
}
```

```{r echo=FALSE}
write.table(BMS_matrix15_perfects_and_1_melt, 
            file = paste("OUTPUT/BMS_Fitness/BMS_matrix_perfects_and_1_melt.csv",sep=""),
            sep = ",", row.names = F,quote=F,col.names = T)
write.table(BMS_matrix15_perfects_and_1_num_melt, 
            file = paste("OUTPUT/BMS_Fitness/BMS_matrix_perfects_and_1_num_melt.csv",sep=""),
            sep = ",", row.names = F,quote=F,col.names = T)
write.table(BMS_matrix15_perfects_and_1_sd_melt, 
            file = paste("OUTPUT/BMS_Fitness/BMS_matrix_perfects_and_1_sd_melt.csv",sep=""),
            sep = ",", row.names = F,quote=F,col.names = T)
```

## BMS Custom Build

Begin by adding a new column for the WT residues:
```{r}
BMS_matrix15_perfects_and_1_melt$WTcolor <- NA
#X1 is aa, X2 is position

BMS_matrix15_perfects_and_1_melt$aanum <- 0

for (i in 1:nrow(BMS_matrix15_perfects_and_1_melt)){
  
  #find the corresponding residue in E.coli using MSA
  BMS_cons_aanum <- BMS_matrix15_perfects_and_1_melt$X2[i]
  
  #is this the WT E.coli residue?
  if (BMS_matrix15_perfects_and_1_melt$X1[i] == substr(BMS_ecoli_seq, BMS_cons_aanum, BMS_cons_aanum)){
    
    #assign WT color
    BMS_matrix15_perfects_and_1_melt$WTcolor[i] <- "red"
    
  }
  
  BMS_matrix15_perfects_and_1_melt$aanum[i] <- which(BMS_aa_list$aa == BMS_matrix15_perfects_and_1_melt$X1[i])
  
}
```

Read in the RSA and SS files generated from the `parse_dssp.py` script above:
```{r}
RSA_1H1T <- read.table( "OUTPUT/structures/4KJK.RSAs.txt" , skip = 2 , header = FALSE )
SS_1H1T <- read.table( "OUTPUT/structures/4KJK.SSs.txt" , skip = 2 , header = FALSE )
cons_1H1T <- read.table( "OUTPUT/structures/4KJK.JSD_out.txt" , skip = 5 , header = FALSE )
```

<font color="red">**I have no idea what this code is doing:**</font>
```{r}
colnames(cons_1H1T) <- c("pos","cons","col")
cons_1H1T$pos <- cons_1H1T$pos+1

protein_info_1H1T <- RSA_1H1T %>%
  right_join(SS_1H1T, by="V1")

colnames(protein_info_1H1T) <- c("pos","RSA","SS")

protein_info_1H1T$cons <- 0

for (i in 1:nrow(cons_1H1T)){
  #get MSA position: cons_1H1T$pos[i]
  #find if this position exists in the e.coli MSA
  if (cons_1H1T$pos[i] %in% BMS_ecoli_map$msa_aanum){
    #get corresponding residue
    e_coli_residue <- BMS_ecoli_map$orth_aanum[which(BMS_ecoli_map$msa_aanum==cons_1H1T$pos[i])]
    protein_info_1H1T$cons[which(protein_info_1H1T$pos==e_coli_residue)] <- cons_1H1T$cons[i]
  }
}

protein_info_1H1T <- BMS_matrix15_perfects_and_1_melt %>%
  filter(X1 != "X") %>%
  group_by(X2) %>%
  dplyr::rename(pos=X2) %>%
  summarise(avgfit=mean(value,na.rm=TRUE),
            numcov=20-sum(is.na(value))) %>%
  right_join(protein_info_1H1T, by="pos")

protein_info_1H1T_melt <- melt(as.data.frame(protein_info_1H1T),
                               id=c("pos"))

protein_info_1H1T_melt$yval <- 0
protein_info_1H1T_melt$yval[which(protein_info_1H1T_melt$variable=="avgfit")] <- 23
protein_info_1H1T_melt$yval[which(protein_info_1H1T_melt$variable=="RSA")] <- 24
protein_info_1H1T_melt$yval[which(protein_info_1H1T_melt$variable=="SS")] <- 25

BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="X")] <- 21.3
```

Determine coverage:
```{r warning=FALSE, class.output="goodCode"}
(nrow(BMS_matrix15_perfects_and_1_melt %>%
            filter(X1 != "X") %>%
            dplyr::select(value)) -
  sum(is.na(BMS_matrix15_perfects_and_1_melt %>%
              filter(X1 != "X") %>%
              dplyr::select(value))))/nrow(BMS_matrix15_perfects_and_1_melt %>%
                                             filter(X1 != "X") %>%
                                             dplyr::select(value))



BMS_Fig_yminlim <- -2
BMS_Fig_ymaxlim <- 30
BMS_Fig_xminlim <- -1
BMS_Fig_xmaxlim <- 160

BMS_1mut15_del <- read.table( "OUTPUT/BMS_Fitness/BMS_fitness15_map_1.csv" , skip = 0 , sep=",",header = TRUE )
#calc all data and stats
BMS_1mut15_del_collapsed_all <- BMS_1mut15_del %>%
  filter(position > 0) %>%
  group_by(position, aa) %>%
  summarise(fitval=median(fitness),
            numpoints=n(),
            stdfit=sd(fitness))

#these matrices have the fitness/num/sd for each aa at each position:
BMS_1mut15_del_matrix = matrix(rep(NA, BMS_ref_len*BMS_aa_dim),nrow=BMS_aa_dim,ncol=BMS_ref_len)

#populate matrix
for (i in 1:nrow(BMS_1mut15_del_collapsed_all)){
  
  BMS_1mut15_del_matrix[which(BMS_aa_list$aa==as.character(BMS_1mut15_del_collapsed_all$aa[i])),BMS_1mut15_del_collapsed_all$position[i]] <- as.numeric(BMS_1mut15_del_collapsed_all$fitval[i])
}

rownames(BMS_1mut15_del_matrix)<-BMS_aa_list$aa
colnames(BMS_1mut15_del_matrix)<-c(1:BMS_ref_len)

BMS_1mut15_del_matrix_melt <- melt(BMS_1mut15_del_matrix)
BMS_1mut15_del_matrix_melt <- BMS_1mut15_del_matrix_melt %>%
  filter(X1=="X")
BMS_1mut15_del_matrix_melt$WTcolor <- NA
BMS_1mut15_del_matrix_melt$aanum <- 21.3
  
BMS_matrix15_perfects_and_1_melt <- BMS_matrix15_perfects_and_1_melt %>%
  filter(X1!="X")

BMS_matrix15_perfects_and_1_melt <- rbind(BMS_matrix15_perfects_and_1_melt,BMS_1mut15_del_matrix_melt)

BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="A")] <- 12
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="C")] <- 10
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="D")] <- 5
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="E")] <- 4
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="F")] <- 19
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="G")] <- 11
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="H")] <- 3
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="I")] <- 15
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="K")] <- 1
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="L")] <- 14
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="M")] <- 16
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="N")] <- 6
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="P")] <- 17
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="Q")] <- 7
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="R")] <- 2
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="S")] <- 9
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="T")] <- 8
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="V")] <- 13
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="W")] <- 20
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="Y")] <- 18
BMS_matrix15_perfects_and_1_melt$aanum[which(BMS_matrix15_perfects_and_1_melt$X1=="X")] <- 22.6

BMS_matrix15_perfects_and_1_melt_WT <- BMS_matrix15_perfects_and_1_melt %>%
  filter(WTcolor=="red")
```

## BMS Custom Plot

Bring it all together to build a custom BMS plot for COMPLEMENTATION (fitD05D03) for LIBRARY 15:
```{r}
BMS_plot15 <- ggplot() +
  #BMS matrix
  geom_rect(data=BMS_matrix15_perfects_and_1_melt,aes(xmin=X2, xmax=X2+1, ymin=aanum, ymax=aanum+1, fill=value))+
  #WT seq
  geom_rect(data=BMS_matrix15_perfects_and_1_melt_WT,aes(xmin=X2, xmax=X2+1, ymin=aanum, ymax=aanum+1), color="green",alpha=0)+
  #avg fit
  geom_rect(data=protein_info_1H1T,aes(xmin=pos, xmax=pos+1, ymin=21.3, ymax=22.3,fill=avgfit))+
  labs(x = "Position (aa)", y ="Amino acid",color="") +
  scale_fill_gradient2(low = "blue", high = "red", mid="gold",name="Fitness",na.value="grey", limit = c(-2,2)) +     #1.1*max(BMS_matrix_perfects_and_1_melt$value)
  geom_text(data=BMS_matrix15_perfects_and_1_melt[1:21,], aes(x=-1, y=aanum+0.5, label=X1), size=3.5)+
  geom_text(data=data.frame(pos=seq(0,150,30)),aes(x=pos+0.5,y=0,label=pos))+
  geom_segment(aes(x = 14.5, y = 1, xend = 14.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 15.5, y = 1, xend = 15.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 16.5, y = 1, xend = 16.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 17.5, y = 1, xend = 17.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 20.5, y = 1, xend = 20.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 27.5, y = 1, xend = 27.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 31.5, y = 1, xend = 31.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 32.5, y = 1, xend = 32.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 46.5, y = 1, xend = 46.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 52.5, y = 1, xend = 52.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 57.5, y = 1, xend = 57.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 94.5, y = 1, xend = 94.5, yend = 0), colour = "blue")+
  geom_segment(aes(x = 100.5, y = 1, xend = 100.5, yend = 0), colour = "blue")+
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.line=element_blank())+
  xlim(BMS_Fig_xminlim,BMS_Fig_xmaxlim)+
  ylim(BMS_Fig_yminlim,BMS_Fig_ymaxlim)

BMS_plot15
```

```{r eval=FALSE, echo=FALSE}
#Saving 13.3 x 6.51 in images
ggsave(file="plots/BMS/BMS_Lib15_Complementation_Legend.pdf", plot=BMS_plot15,
       width=13.3, height=6.5, units="in")

#Plot without legend and save copy
BMS_plot15_2 <- BMS_plot15 + theme(legend.position="none")

#Saving 13.3 x 6.51 in images
ggsave(file="plots/BMS/BMS_Lib15_Complementation_no_Legend.pdf", plot=BMS_plot15_2,
       width=13.3, height=6.5, units="in")
```

Determine the minimum and maximum average fitness values:
```{r class.output="goodCode"}
min(protein_info_1H1T$avgfit)
max(protein_info_1H1T$avgfit)
```

Plot the SS string to go above the custom BMS plot:
```{r}
protein_info_1H1T_no_loop <- protein_info_1H1T %>%
  filter(SS != "loop")

# Plot SS

SS_plot15 <- ggplot()+
  geom_segment(aes(x = 1, y = 24.5, xend = 160, yend = 24.5), colour = "black")+
  geom_rect(data=protein_info_1H1T_no_loop,aes(xmin=pos, xmax=pos+1, ymin=24, ymax=25, fill=SS))+
  xlim(BMS_Fig_xminlim,BMS_Fig_xmaxlim)+
  ylim(BMS_Fig_yminlim,BMS_Fig_ymaxlim)+
  labs(x = "", y ="",color="") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.line=element_blank())

SS_plot15
```

```{r eval=FALSE, echo=FALSE}
#Saving 13.3 x 6.51 in images
ggsave(file="plots/BMS/SS_Lib15_Complementation_Legend.pdf", plot=SS_plot15,
       width=13.3, height=6.5, units="in")

#Plot without legend and save copy
SS_plot15_2 <- SS_plot15 + theme(legend.position="none")

#Saving 13.3 x 6.51 in images
ggsave(file="plots/BMS/SS_Lib15_Complementation_no_Legend.pdf", plot=SS_plot15_2,
       width=13.3, height=6.5, units="in")
```

Plot the RSA (protein) string:
```{r}
RSA_plot15 <- ggplot(protein_info_1H1T)+
  geom_rect(aes(xmin=pos, xmax=pos+1, ymin=25.3, ymax=26.3, fill=RSA))+
  xlim(BMS_Fig_xminlim,BMS_Fig_xmaxlim)+
  ylim(BMS_Fig_yminlim,BMS_Fig_ymaxlim)+
  labs(x = "", y ="",color="") +
  scale_fill_gradient(low = "white", high = "red",name="RSA",na.value="grey") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.line=element_blank())

RSA_plot15
```

```{r eval=FALSE, echo=FALSE}
#Saving 13.3 x 6.51 in images
ggsave(file="plots/BMS/RSA_Lib15_Complementation_Legend.pdf", plot=RSA_plot15,
       width=13.3, height=6.5, units="in")

#Plot without legend and save copy
RSA_plot15_2 <- RSA_plot15 + theme(legend.position="none")

#Saving 13.3 x 6.51 in images
ggsave(file="plots/BMS/RSA_Lib15_Complementation_no_Legend.pdf", plot=RSA_plot15_2,
       width=13.3, height=6.5, units="in")
```

Plot the RSA again with different color parameters:
```{r}
RSA2_plot15 <- ggplot(protein_info_1H1T)+
  geom_rect(aes(xmin=pos, xmax=pos+1, ymin=26.6, ymax=27.6, fill=cons))+
  xlim(BMS_Fig_xminlim,BMS_Fig_xmaxlim)+
  ylim(BMS_Fig_yminlim,BMS_Fig_ymaxlim)+
  labs(x = "", y ="",color="") +
  scale_fill_gradient(low = "white", high = "red",name="Cons",na.value="grey") +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.line=element_blank())

RSA2_plot15
```

```{r eval=FALSE, echo=FALSE}
#Saving 13.3 x 6.51 in images
ggsave(file="plots/BMS/RSA2_Lib15_Complementation_Legend.pdf", plot=RSA2_plot15,
       width=13.3, height=6.5, units="in")

#Plot without legend and save copy
RSA2_plot15_2 <- RSA2_plot15 + theme(legend.position="none")

#Saving 13.3 x 6.51 in images
ggsave(file="plots/BMS/RSA2_Lib15_Complementation_no_Legend.pdf", plot=RSA2_plot15_2,
       width=13.3, height=6.5, units="in")
```

## Summary Plots

Plot site coverage versus average fitness and conservation:
```{r}
RSA_cons_plot15 <- ggplot(protein_info_1H1T,aes(x=avgfit,y=numcov/20*100))+
  geom_smooth(fill="deepskyblue2")+
  geom_point()+
  labs(x = "Average fitness at position", y ="Position mutational coverage (%)",color="") +
  theme(title = element_text(size = 18),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        panel.background = element_blank()) +
  panel_border(color = "black")

RSA_cons_plot15
```

```{r echo=FALSE}
#Saving 6 x 5 in images
ggsave(file="plots/BMS/Lib15_Complementation_Coverage_vs_Avg_Fit.pdf", plot=RSA_cons_plot15,
       width=6, height=5, units="in")
```

Correlation Tests:
```{r class.output="goodCode"}
cor.test(protein_info_1H1T$avgfit,protein_info_1H1T$numcov/20*100)
cor(protein_info_1H1T$avgfit,protein_info_1H1T$numcov)
```

Plot Average Fit versus SS:
```{r}
SS_fit_plot15 <- ggplot(protein_info_1H1T,aes(x=SS,y=avgfit))+
  geom_boxplot(color="black", fill="deepskyblue2")+
  geom_jitter()+
  labs(x = "Secondary structure", y ="Average fitness at position",color="")+
  theme(title = element_text(size = 18),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        panel.background = element_blank()) +
  panel_border(color = "black")

SS_fit_plot15
```

```{r echo=FALSE}
#Saving 6 x 5 in images
ggsave(file="plots/BMS/Lib15_Complementation_Avg_Fit_vs_SS.pdf", plot=SS_fit_plot15,
       width=6, height=5, units="in")
```

Plot Average Fit versus RSA:
```{r}
RSA_fit_plot15 <- ggplot(protein_info_1H1T,aes(x=RSA,y=avgfit))+
  geom_smooth()+
  geom_point(alpha=0.7)+
  labs(x = "Relative solvent accesibility", y ="Average fitness at position",color="")+
  ylim(-2.7,2.7)+
  theme(title = element_text(size = 18),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        panel.background = element_blank()) +
  panel_border(color = "black")

RSA_fit_plot15 <- ggExtra::ggMarginal(RSA_fit_plot15,type = "histogram",
                         xparams = list(bins=30),
                         yparams = list(bins=20),
                         col = 'black',
                         fill = 'deepskyblue2') 

RSA_fit_plot15
```

```{r echo=FALSE}
#Saving 6 x 5 in images
ggsave(file="plots/BMS/Lib15_Complementation_Avg_Fit_vs_RSA.pdf", plot=RSA_fit_plot15,
       width=6, height=5, units="in")
```

Correlation Tests:
```{r class.output="goodCode"}
cor.test(protein_info_1H1T$RSA,protein_info_1H1T$avgfit)
cor(protein_info_1H1T$RSA,protein_info_1H1T$avgfit)
```

Put the plots together:
```{r}
plot_BMS_2SUP <- plot_grid(SS_fit_plot15, RSA_fit_plot15, labels = c("A", "B"))
plot_BMS_2SUP
```

```{r}
save_plot("plots/BMS/avg_fit_vs_cons_vs_RSA.pdf", plot_BMS_2SUP,
          ncol = 2, # we're saving a grid plot of 2 columns
          # each individual subplot should have an aspect ratio of 1.3
          base_aspect_ratio = 1.3)
```

```{r}
patch21<- (RSA_cons_plot15 | SS_fit_plot15) / (RSA_fit_plot15)
patch21
```

```{r echo=FALSE}
ggsave(file="plots/BMS/Lib15.Avg_Fit_vs_Cons_vs_RSA.png", plot=patch21,
       dpi=600, width = 18, height = 14, units = "in")
```

```{r}
RSA_WT_plot15 <- ggplot(BMS_matrix15_perfects_and_1_melt,aes(x=WTcolor,y=value))+
  geom_boxplot(color="black", fill="deepskyblue2")+
  labs(x = "Residue", y ="Fitness",color="")+ 
  scale_x_discrete(name ="Residue type",
                   labels=c("Wildtype E. coli DHFR","Other"))+
  theme(title = element_text(size = 18),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        panel.background = element_blank()) +
  panel_border(color = "black")

RSA_WT_plot15
```

```{r echo=FALSE}
#Saving 6 x 5 in images
ggsave(file="plots/BMS/Lib15_Complementation_WT_vs_other_fitness.pdf", plot=RSA_WT_plot15,
       width=6, height=5, units="in")
```

Summary Stats:
```{r}
# WT Summary Stats
mean(as.numeric(unlist(BMS_matrix15_perfects_and_1_melt %>% filter(WTcolor=="red") %>% dplyr::select(value))))
median(as.numeric(unlist(BMS_matrix15_perfects_and_1_melt %>% filter(WTcolor=="red") %>% dplyr::select(value))))
sd(as.numeric(unlist(BMS_matrix15_perfects_and_1_melt %>% filter(WTcolor=="red") %>% dplyr::select(value))))

# Non-WT Summary Stats
mean(as.numeric(unlist(BMS_matrix15_perfects_and_1_melt %>% filter(is.na(WTcolor) & !is.na(value)) %>% dplyr::select(value))))
median(as.numeric(unlist(BMS_matrix15_perfects_and_1_melt %>% filter(is.na(WTcolor) & !is.na(value)) %>% dplyr::select(value))))
sd(as.numeric(unlist(BMS_matrix15_perfects_and_1_melt %>% filter(is.na(WTcolor) & !is.na(value)) %>% dplyr::select(value))))
```

## BMS STD Plots

Establish plotting parameters:
```{r}
BMS_matrix15_perfects_and_1_sd_melt <- BMS_matrix15_perfects_and_1_sd_melt %>%
  filter(X1!="X")

BMS_matrix15_perfects_and_1_sd_melt$aanum <- 0

BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="A")] <- 12
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="C")] <- 10
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="D")] <- 5
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="E")] <- 4
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="F")] <- 19
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="G")] <- 11
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="H")] <- 3
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="I")] <- 15
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="K")] <- 1
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="L")] <- 14
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="M")] <- 16
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="N")] <- 6
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="P")] <- 17
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="Q")] <- 7
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="R")] <- 2
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="S")] <- 9
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="T")] <- 8
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="V")] <- 13
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="W")] <- 20
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="Y")] <- 18
BMS_matrix15_perfects_and_1_sd_melt$aanum[which(BMS_matrix15_perfects_and_1_sd_melt$X1=="X")] <- 22.6
```

Plot the STD values of the BMS analysis:
```{r}
BMS_std_plot15 <- ggplot() +
  #BMS matrix
  geom_rect(data=BMS_matrix15_perfects_and_1_sd_melt,aes(xmin=X2, xmax=X2+1, ymin=aanum, ymax=aanum+1, fill=value))+
  #WT seq
  geom_rect(data=BMS_matrix15_perfects_and_1_melt_WT,aes(xmin=X2, xmax=X2+1, ymin=aanum, ymax=aanum+1), color="green",alpha=0)+
  labs(x = "Position (aa)", y ="Amino acid",color="") +
  scale_fill_gradient2(low = "blue", high = "red", mid="gold",name="Std",na.value="grey", midpoint = 3, limit = c(0,1.1*max(BMS_matrix15_perfects_and_1_sd_melt$value))) +#
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.line=element_blank())

BMS_std_plot15
```

Plot epistatis:
```{r}
BMS_epistasis15 <- BMS_matrix15_perfects_and_1_sd_melt %>%
  dplyr::rename(sd=value) %>%
  inner_join(BMS_matrix15_perfects_and_1_num_melt, by=c("X1","X2")) %>%
  dplyr::rename(num=value) %>%
  filter(num>4)

BMS_epistasis_std_plot15 <- ggplot() +
  #BMS matrix
  geom_rect(data=BMS_epistasis15,aes(xmin=X2, xmax=X2+1, ymin=aanum, ymax=aanum+1, fill=sd))+
  #WT seq
  geom_rect(data=BMS_matrix15_perfects_and_1_melt_WT,aes(xmin=X2, xmax=X2+1, ymin=aanum, ymax=aanum+1), color="green",alpha=0)+
  geom_text(data=BMS_matrix15_perfects_and_1_melt[1:21,], aes(x=-1, y=aanum+0.5, label=X1), size=3.5)+
  geom_text(data=data.frame(pos=seq(0,150,30)),aes(x=pos+0.5,y=0,label=pos))+
  labs(x = "Position (aa)", y ="Amino acid",color="") +
  scale_fill_gradient(low = "gold", high = "red", name="Std",na.value="grey", limit = c(3,1.1*max(BMS_epistasis15$sd))) +#
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.line=element_blank())

BMS_epistasis_std_plot15
```

```{r}
BMS_epistasis15_pos <- BMS_epistasis15 %>%
  group_by(X2) %>%
  summarise(numaa=n(),meansd=mean(sd),stdsd=sd(sd))
  
ggplot(BMS_epistasis15_pos,aes(x=X2,y=numaa)) +
  geom_point()+
  theme(title = element_text(size = 18),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        panel.background = element_blank()) +
  panel_border(color = "black")
ggplot(BMS_epistasis15_pos,aes(x=X2,y=meansd)) +
  geom_point()+
  theme(title = element_text(size = 18),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        panel.background = element_blank()) +
  panel_border(color = "black")
ggplot(BMS_epistasis15_pos,aes(x=X2,y=stdsd)) +
  geom_point()+
  theme(title = element_text(size = 18),
        axis.text.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.x = element_text(size = 16),
        axis.title.y = element_text(size = 16),
        panel.background = element_blank()) +
  panel_border(color = "black")
```

Save BMS Info as dataframe (and write to csv file):
```{r}
BMS_info15 <- right_join(BMS_matrix15_perfects_and_1_melt %>%
                         select(X1,X2,value) %>%
                         dplyr::rename(AA=X1,Pos=X2,avgfitness=value),
                       BMS_matrix15_perfects_and_1_num_melt %>%
                         select(X1,X2,value) %>%
                         dplyr::rename(AA=X1,Pos=X2,numpoints=value),
                       by=c("AA", "Pos"))

BMS_info15 <- right_join(BMS_info15,
                       BMS_matrix15_perfects_and_1_sd_melt%>%
                         select(X1,X2,value) %>%
                         dplyr::rename(AA=X1,Pos=X2,sd=value),
                       by=c("AA", "Pos"))
```

```{r echo=FALSE}
#save CSV
write.table(BMS_info15, file = paste("OUTPUT/BMS_Fitness/BMS_info_L15.csv",sep=""), 
            sep = ",", row.names = F,quote=F,col.names = T)
```

# GOF Mutants
<font color="blue">**This section is based on the R file: "R_dropout_GOF.R".**</font> It describes how to determine if certain mutant versions of a designed homolog increase in fitness under trimethoprim selection (i.e., gain of function after mutation).

## Dropout Mutants

Start by retrieving all dropout mutants with a log-fold change value less than -2.5.
```{r}
# Lib15

# Get dropouts
dropout_mutants15_GOF <- mut_collapse_15 %>%
  filter(fitD05D03 < -2.5) %>%
  dplyr::select(ID, mutID, mutations, fitD05D03)
```

Make sure none of the collapsed info has corresponding perfects with high fitness:
```{r}
dropout_fake_index = numeric()
for (i in 1:nrow(dropout_mutants15_GOF)){
  if (dropout_mutants15_GOF$ID[i] %in% perfects15$ID){
    if (perfects15$fitD05D03[which(perfects15$ID==dropout_mutants15_GOF$ID[i])] > -2.5){
      dropout_fake_index[length(dropout_fake_index)+1] <- i
    }
  }
}
if (length(dropout_fake_index) > 0){
  dropout_mutants15_GOF <- dropout_mutants15_GOF[-dropout_fake_index,]
}
```

Create a temporary dataframe compiling the total number of mutants for dropouts:
```{r}
deltemp <- mutants15 %>%
  dplyr::rename(ID=IDalign) %>%
  filter(mutations > 0 &
           mutations < 6 &
           numprunedBCs > 0 &
           (ID %in% dropout_mutants15_GOF$ID))
```

Gather all dropout mutants and select those with positive fitness
```{r}
# Mutants15 df is generated in R_plot_all_mutants.R above
dropout_mutants15_GOF <- mutants15 %>%
  dplyr::rename(ID=IDalign) %>%
  filter(fitD05D03 > 0 &
           mutations > 0 &
           mutations < 6 &
           numprunedBCs > 0) %>%
  inner_join(dropout_mutants15_GOF, by="ID") %>%
  ungroup()
```

Sum the number of unique dropouts with GOF mutants
```{r class.output="goodCode"}
length(unique(dropout_mutants15_GOF$ID))
```

## GOF Plotting

Find GOF mutants for dropouts:
```{r eval=FALSE, class.output="badCode"}
mutants15_to_plot <- data.frame(ID=unique(dropout_mutants15_GOF$ID))
```

Add median fitness values for each unique ID

Make sure all of the chosen dropouts are in the MSA:
```{r eval=FALSE, class.output="badCode"}
mutants15_to_plot_index_of_mut_to_drop = numeric()
for (i in 1:nrow(mutants15_to_plot)){
  mutant15_current_temp <- mutants15_to_plot$ID[i]
  if(!file.exists(paste("MSAdropouts/",mutant15_current_temp,".csv",sep=""))){
    print(mutant15_current_temp)
    mutants15_to_plot_index_of_mut_to_drop[length(mutants15_to_plot_index_of_mut_to_drop)+1] <- which(mutants15_to_plot$ID==mutant15_current_temp)
  }
}
```
Determine if any are not in MSA:
```{r eval=FALSE, class.output="badCode"}
if (length(mutants15_to_plot_index_of_mut_to_drop) > 0){
  mutants15_to_plot <- mutants15_to_plot[-mutants15_to_plot_index_of_mut_to_drop,]
}
```

Read in the E. coli map:
```{r eval=FALSE, class.output="badCode"}
ecoli_map <- read.csv(file=paste("PPATtrees/MSAdropouts/NP_418091.csv",sep=""),head=TRUE,sep=",")
ecoli_map_all <- read.csv(file=paste("PPATtrees/MSAmap_all/NP_418091.csv",sep=""),head=TRUE,sep=",")
```

# Reproducibility

The session information is provided for full reproducibility.
```{r}
devtools::session_info()
```